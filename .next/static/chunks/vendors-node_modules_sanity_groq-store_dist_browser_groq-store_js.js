(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_sanity_groq-store_dist_browser_groq-store_js"],{

/***/ "./node_modules/@sanity/groq-store/dist/browser/groq-store.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/groq-store/dist/browser/groq-store.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var r=e(__webpack_require__(/*! groq */ "./node_modules/groq/lib/groq.js")),t=e(__webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js")),n=__webpack_require__(/*! throttle-debounce */ "./node_modules/throttle-debounce/cjs/index.js"),o=__webpack_require__(/*! groq-js */ "./node_modules/groq-js/dist/groq-js.esm.js"),i=__webpack_require__(/*! mendoza */ "./node_modules/mendoza/lib/esm/index.js");function u(){return(u=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function s(e,r,t){var n,o=r.token,i=new e("https://"+r.projectId+".api.sanity.io/v1/data/listen/"+r.dataset+"?query=*&effectFormat=mendoza",{withCredentials:!0,headers:o?{Authorization:"Bearer "+o}:void 0});return i.addEventListener("welcome",t.open,!1),i.addEventListener("mutation",(n=t.next,function(e){var r;try{r=JSON.parse(e.data)}catch(e){return}n(r)}),!1),i.addEventListener("channelError",function(e){var r;i.close();try{r=JSON.parse(e.data)}catch(e){return void t.error(new Error("Unknown error parsing listener message"))}t.error(new Error(r.message||r.error||"Listener returned HTTP "+r.statusCode))},!1),i.addEventListener("error",function(e){var r="undefined"!=typeof window&&window.location.origin,n=r?", and that the CORS-origin ("+r+") is allowed":"",o=function(e){return"object"==typeof e&&null!==e&&"message"in e}(e)?" ("+e.message+")":"";t.error(new Error("Error establishing listener - check that the project ID and dataset are correct"+n+o))},!1),{unsubscribe:function(){return Promise.resolve(i.close())}}}function c(e){return e._id.startsWith("drafts.")?e._id.slice(7):e._id}function a(e,r){var t=u({},e);return delete t._rev,i.applyPatch(t,r)}function f(){return Promise.resolve()}function d(){var e,r,t=(e=["*[_id == $id][0]"],r||(r=e.slice(0)),e.raw=r,e);return d=function(){return t},t}function v(e,r,t){if(!e.s){if(t instanceof l){if(!t.s)return void(t.o=v.bind(null,e,r));1&r&&(r=t.s),t=t.v}if(t&&t.then)return void t.then(v.bind(null,e,r),v.bind(null,e,2));e.s=r,e.v=t;var n=e.o;n&&n(e)}}var l=function(){function e(){}return e.prototype.then=function(r,t){var n=new e,o=this.s;if(o){var i=1&o?r:t;if(i){try{v(n,1,i(this.v))}catch(e){v(n,2,e)}return n}return this}return this.o=function(e){try{var o=e.v;1&e.s?v(n,1,r?r(o):o):t?v(n,1,t(o)):v(n,2,o)}catch(e){v(n,2,e)}},n},e}();function h(e){return e instanceof l&&1&e.s}var m=function(e){var r=e.projectId,t=e.dataset,n=e.token,o=e.documentLimit;try{return Promise.resolve(fetch("https://"+r+".api.sanity.io/v1/data/export/"+t,{credentials:"include",headers:n?{Authorization:"Bearer "+n}:void 0})).then(function(e){function r(r){var t,n,i=function(e){if(!e)throw new Error("Failed to read body from response");var r,t=!1;function n(){t=!0,r&&r.cancel()}return new ReadableStream({start:function(o){r=e.getReader();var i=new TextDecoder,u="";r.read().then(function e(s){try{if(s.done)return t?Promise.resolve():0===(u=u.trim()).length?(o.close(),Promise.resolve()):(o.enqueue(JSON.parse(u)),o.close(),Promise.resolve());for(var c=(u+=i.decode(s.value,{stream:!0})).split("\n"),a=0;a<c.length-1;++a){var f=c[a].trim();if(0===f.length)return Promise.resolve();try{o.enqueue(JSON.parse(f))}catch(e){return o.error(e),n(),Promise.resolve()}}if(u=c[c.length-1],!r)return Promise.resolve();var d=function(t,n){try{var o=Promise.resolve(r.read()).then(function(r){e(r)})}catch(e){return n(e)}return o&&o.then?o.then(void 0,n):o}(0,function(e){o.error(e)});return Promise.resolve(d&&d.then?d.then(function(){}):void 0)}catch(e){return Promise.reject(e)}}).catch(function(e){return o.error(e)})},cancel:n})}(e.body).getReader(),u=[],s=function(e,r){var t;do{var n=e();if(n&&n.then){if(!h(n)){t=!0;break}n=n.v}var o=r();if(h(o)&&(o=o.v),!o)return n}while(!o.then);var i=new l,u=v.bind(null,i,2);return(t?n.then(s):o.then(c)).then(void 0,u),i;function s(t){for(n=t;h(o=r())&&(o=o.v),o;){if(o.then)return void o.then(c).then(void 0,u);if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}}v(i,1,n)}function c(t){if(t){do{if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}if(h(t=r())&&(t=t.v),!t)return void v(i,1,n)}while(!t.then);t.then(c).then(void 0,u)}else v(i,1,n)}}(function(){return Promise.resolve(i.read()).then(function(e){if(function(e){return!!e&&"error"in e&&"object"==typeof e.error&&null!==e.error&&"description"in e.error&&"string"==typeof e.error.description&&!("_id"in e)}(n=(t=e).value))throw new Error("Error streaming dataset: "+n.error);if(n&&!n._id.startsWith("_.")&&u.push(n),o&&u.length>o)throw i.cancel("Reached document limit"),new Error("Error streaming dataset: Reached limit of "+o+" documents")})},function(){return!t.done});return s&&s.then?s.then(function(e){return u}):u}var t=function(){if(200!==e.status)return Promise.resolve(e.json()).then(function(e){throw new Error("Error streaming dataset: "+("object"==typeof(r=e)&&"error"in r&&"message"in r?r.message||r.error:"<unknown error>"));var r})}();return t&&t.then?t.then(r):r()})}catch(e){return Promise.reject(e)}};exports.groq=r,exports.groqStore=function(e){if(function(){var e=["EventSource","ReadableStream","fetch"].filter(function(e){return!(e in window)});if(e.length>0)throw new Error("Browser not supported. Missing browser APIs: "+e.join(", "))}(),e.token)throw new Error("`token` option not currently supported in browser");return function(e,i){var v,l=function(e,r){try{return Promise.resolve(h()).then(function(){var t=o.parse(e,{params:r});return Promise.resolve(o.evaluate(t,{dataset:m,params:r})).then(function(e){return e.get()})})}catch(e){return Promise.reject(e)}},h=function(){try{return v||(v=function(e,r,t){var n=t.getDocuments,o=t.EventSource,i=e.projectId,d=e.dataset,v=e.overlayDrafts,l=e.documentLimit;if(!e.listen)return{unsubscribe:f,loaded:n({projectId:i,dataset:d,documentLimit:l}).then(j).then(f)};var h,m,p,w,b,g,y=new Map,P=[],E=new Promise(function(e,r){m=e,p=r});return{unsubscribe:s(o,e,{next:function(e){h?(function(e){if(e.effects&&!e.documentId.startsWith("_.")){var r=y.get(e.documentId)||null;!function(e,r){var t=y.get(e),n=h||[],o=t?n.indexOf(t):-1;-1===o&&r?(n.push(r),y.set(e,r)):r?(n.splice(o,1,r),y.set(e,r)):(n.splice(o,1),y.delete(e))}(e.documentId,a(r,e.effects.apply))}}(e),function(e,r){clearTimeout(g),b!==r.transactionId&&w?(j(w),b=void 0):(b=r.transactionId,w=e.slice()),g=setTimeout(j,25,e.slice())}(h,e)):P.push(e)},open:function(){try{return Promise.resolve(n({projectId:i,dataset:d,documentLimit:l})).then(function(e){(h=function(e,r){var t=new Map;return r.forEach(function(e){var r=t.get(e.documentId)||[];r.push(e),t.set(e.documentId,r)}),t.forEach(function(r,t){var n=e.find(function(e){return e._id===t});if(n){var o=!1,i=n;r.forEach(function(e){(o=o||e.previousRev===n._rev)&&e.effects&&(i=a(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}else console.warn("Received mutation for missing document %s",t)}),e}(e,P)).forEach(function(e){return y.set(e._id,e)}),j(h),m()})}catch(e){return Promise.reject(e)}},error:function(e){return p(e)}}).unsubscribe,loaded:E};function j(e){w=void 0,g=void 0,b=void 0,r(v?function(e){var r=new Map;return e.forEach(function(e){var t=r.get(c(e));e._id.startsWith("drafts.")?r.set(c(e),function(e){return u({},e,{_id:c(e)})}(e)):t||r.set(e._id,e)}),Array.from(r.values())}(e):e)}}(e,function(e){m=e,p()},i)),Promise.resolve(v.loaded).then(function(){})}catch(e){return Promise.reject(e)}},m=[],p=n.throttle(e.subscriptionThrottleMs||50,function(){w.forEach(b)}),w=[];function b(e){return l(e.query,e.params).then(function(r){"previousResult"in e&&t(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(function(r){e.callback(r)})}return{query:l,getDocument:function(e){try{return Promise.resolve(h()).then(function(){return l(r(d()),{id:e})})}catch(e){return Promise.reject(e)}},getDocuments:function(e){try{return Promise.resolve(h()).then(function(){var r=e.map(function(e){return'*[_id == "'+e+'"][0]'}).join(",\n");return l("["+r+"]")})}catch(e){return Promise.reject(e)}},subscribe:function(r,t,n){if(!e.listen)throw new Error("Cannot use `subscribe()` without `listen: true`");var o={query:r,params:t,callback:n};w.push(o);var i=!1;return b(o),{unsubscribe:function(){return i||(i=!0,w.splice(w.indexOf(o),1)),Promise.resolve()}}},close:function(){return p.cancel(),v?v.unsubscribe():Promise.resolve()}}}(e,{EventSource:window.EventSource,getDocuments:m})};
//# sourceMappingURL=groq-store.js.map


/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "./node_modules/groq-js/dist/groq-js.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/groq-js/dist/groq-js.esm.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "evaluate": function() { return /* binding */ evaluateQuery; },
/* harmony export */   "parse": function() { return /* binding */ parse; }
/* harmony export */ });
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
class MarkProcessor {
  constructor(string3, marks, parseOptions) {
    this.allowBoost = false;
    this.string = string3;
    this.marks = marks;
    this.index = 0;
    this.parseOptions = parseOptions;
  }
  hasMark(pos = 0) {
    return this.index + pos < this.marks.length;
  }
  getMark(pos = 0) {
    return this.marks[this.index + pos];
  }
  shift() {
    this.index += 1;
  }
  process(visitor) {
    const mark = this.marks[this.index];
    this.shift();
    const func = visitor[mark.name];
    if (!func) {
      throw new Error(`Unknown handler: ${mark.name}`);
    }
    return func.call(visitor, this, mark);
  }
  processString() {
    this.shift();
    return this.processStringEnd();
  }
  processStringEnd() {
    const prev = this.marks[this.index - 1];
    const curr = this.marks[this.index];
    this.shift();
    return this.string.slice(prev.position, curr.position);
  }
  slice(len) {
    const pos = this.marks[this.index].position;
    return this.string.slice(pos, pos + len);
  }
}
const RFC3339_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|([-+]\d{2}:\d{2}))$/;
function parseRFC3339(str) {
  if (RFC3339_REGEX.test(str)) {
    return new Date(str);
  }
  return null;
}
function formatRFC3339(d) {
  const year = addLeadingZero(d.getUTCFullYear(), 4);
  const month = addLeadingZero(d.getUTCMonth() + 1, 2);
  const day = addLeadingZero(d.getUTCDate(), 2);
  const hour = addLeadingZero(d.getUTCHours(), 2);
  const minute = addLeadingZero(d.getUTCMinutes(), 2);
  const second = addLeadingZero(d.getUTCSeconds(), 2);
  let fractionalSecond = "";
  const millis = d.getMilliseconds();
  if (millis != 0) {
    fractionalSecond = `.${addLeadingZero(millis, 3)}`;
  }
  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;
}
function addLeadingZero(num, targetLength) {
  let str = num.toString();
  while (str.length < targetLength) {
    str = `0${str}`;
  }
  return str;
}
function escapeRegExp(string3) {
  return string3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function pathRegExp(pattern) {
  const re = [];
  for (const part of pattern.split(".")) {
    if (part === "*") {
      re.push("[^.]+");
    } else if (part === "**") {
      re.push(".*");
    } else {
      re.push(escapeRegExp(part));
    }
  }
  return new RegExp(`^${re.join(".")}$`);
}
class Path {
  constructor(pattern) {
    this.pattern = pattern;
    this.patternRe = pathRegExp(pattern);
  }
  matches(str) {
    return this.patternRe.test(str);
  }
  toJSON() {
    return this.pattern;
  }
}
class StreamValue {
  constructor(generator) {
    this.type = "stream";
    this.generator = generator;
    this.ticker = null;
    this.isDone = false;
    this.data = [];
  }
  isArray() {
    return true;
  }
  async get() {
    const result = [];
    for await (const value of this) {
      result.push(await value.get());
    }
    return result;
  }
  async *[Symbol.asyncIterator]() {
    let i = 0;
    while (true) {
      for (; i < this.data.length; i++) {
        yield this.data[i];
      }
      if (this.isDone) {
        return;
      }
      await this._nextTick();
    }
  }
  _nextTick() {
    if (this.ticker) {
      return this.ticker;
    }
    let currentResolver;
    const setupTicker = () => {
      this.ticker = new Promise((resolve) => {
        currentResolver = resolve;
      });
    };
    const tick = () => {
      currentResolver();
      setupTicker();
    };
    const fetch = async () => {
      for await (const value of this.generator()) {
        this.data.push(value);
        tick();
      }
      this.isDone = true;
      tick();
    };
    setupTicker();
    fetch();
    return this.ticker;
  }
}
class StaticValue {
  constructor(data, type) {
    this.data = data;
    this.type = type;
  }
  isArray() {
    return this.type === "array";
  }
  async get() {
    return this.data;
  }
  [Symbol.asyncIterator]() {
    if (Array.isArray(this.data)) {
      return function* (data) {
        for (const element of data) {
          yield fromJS(element);
        }
      }(this.data);
    }
    throw new Error(`Cannot iterate over: ${this.type}`);
  }
}
const NULL_VALUE = new StaticValue(null, "null");
const TRUE_VALUE = new StaticValue(true, "boolean");
const FALSE_VALUE = new StaticValue(false, "boolean");
class DateTime {
  constructor(date) {
    this.date = date;
  }
  static parseToValue(str) {
    const date = parseRFC3339(str);
    if (date) {
      return new StaticValue(new DateTime(date), "datetime");
    }
    return NULL_VALUE;
  }
  equals(other) {
    return this.date.getTime() == other.date.getTime();
  }
  add(secs) {
    const copy = new Date(this.date.getTime());
    copy.setTime(copy.getTime() + secs * 1e3);
    return new DateTime(copy);
  }
  difference(other) {
    return (this.date.getTime() - other.date.getTime()) / 1e3;
  }
  compareTo(other) {
    return this.date.getTime() - other.date.getTime();
  }
  toString() {
    return formatRFC3339(this.date);
  }
  toJSON() {
    return this.toString();
  }
}
function fromNumber(num) {
  if (Number.isFinite(num)) {
    return new StaticValue(num, "number");
  }
  return NULL_VALUE;
}
function fromString(str) {
  return new StaticValue(str, "string");
}
function fromDateTime(dt) {
  return new StaticValue(dt, "datetime");
}
function fromPath(path2) {
  return new StaticValue(path2, "path");
}
function isIterator(obj) {
  return obj && typeof obj.next === "function";
}
function fromJS(val) {
  if (isIterator(val)) {
    return new StreamValue(async function* () {
      for await (const value of val) {
        yield fromJS(value);
      }
    });
  } else if (val === null || val === void 0) {
    return NULL_VALUE;
  }
  return new StaticValue(val, getType(val));
}
function getType(data) {
  if (data === null || typeof data === "undefined") {
    return "null";
  }
  if (Array.isArray(data)) {
    return "array";
  }
  if (data instanceof Path) {
    return "path";
  }
  if (data instanceof DateTime) {
    return "datetime";
  }
  return typeof data;
}
const TYPE_ORDER = {
  datetime: 1,
  number: 2,
  string: 3,
  boolean: 4
};
function partialCompare(a, b) {
  const aType = getType(a);
  const bType = getType(b);
  if (aType !== bType) {
    return null;
  }
  switch (aType) {
    case "number":
    case "boolean":
      return a - b;
    case "string":
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    case "datetime":
      return a.compareTo(b);
    default:
      return null;
  }
}
function totalCompare(a, b) {
  const aType = getType(a);
  const bType = getType(b);
  const aTypeOrder = TYPE_ORDER[aType] || 100;
  const bTypeOrder = TYPE_ORDER[bType] || 100;
  if (aTypeOrder !== bTypeOrder) {
    return aTypeOrder - bTypeOrder;
  }
  let result = partialCompare(a, b);
  if (result === null) {
    result = 0;
  }
  return result;
}
const CHARS = /([^!@#$%^&*(),\\/?";:{}|[\]+<>\s-])+/g;
const CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\/?";:{}|[\]+<>\s-])+/g;
const EDGE_CHARS = /(\b\.+|\.+\b)/g;
const MAX_TERM_LENGTH = 1024;
function matchText(tokens, patterns) {
  if (tokens.length === 0 || patterns.length === 0) {
    return false;
  }
  return patterns.every((pattern) => pattern(tokens));
}
function matchTokenize(text) {
  return text.replace(EDGE_CHARS, "").match(CHARS) || [];
}
function matchAnalyzePattern(text) {
  const termsRe = matchPatternRegex(text);
  return termsRe.map((re) => (tokens) => tokens.some((token) => re.test(token)));
}
function matchPatternRegex(text) {
  const terms = text.replace(EDGE_CHARS, "").match(CHARS_WITH_WILDCARD) || [];
  return terms.map((term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\*/g, ".*")}$`, "i"));
}
async function gatherText(value, cb) {
  if (value.type === "string") {
    cb(value.data);
    return true;
  }
  if (value.isArray()) {
    let success = true;
    for await (const part of value) {
      if (part.type === "string") {
        cb(part.data);
      } else {
        success = false;
      }
    }
    return success;
  }
  return false;
}
const BM25k = 1.2;
async function evaluateScore(node, scope, execute) {
  if (node.type === "OpCall" && node.op === "match") {
    return evaluateMatchScore(node.left, node.right, scope, execute);
  }
  if (node.type === "FuncCall" && node.name === "boost") {
    const innerScore = await evaluateScore(node.args[0], scope, execute);
    const boost2 = await execute(node.args[1], scope);
    if (boost2.type === "number" && innerScore > 0) {
      return innerScore + boost2.data;
    }
    return 0;
  }
  switch (node.type) {
    case "Or": {
      const leftScore = await evaluateScore(node.left, scope, execute);
      const rightScore = await evaluateScore(node.right, scope, execute);
      return leftScore + rightScore;
    }
    case "And": {
      const leftScore = await evaluateScore(node.left, scope, execute);
      const rightScore = await evaluateScore(node.right, scope, execute);
      if (leftScore === 0 || rightScore === 0)
        return 0;
      return leftScore + rightScore;
    }
    default: {
      const res = await execute(node, scope);
      return res.type === "boolean" && res.data === true ? 1 : 0;
    }
  }
}
async function evaluateMatchScore(left, right, scope, execute) {
  const text = await execute(left, scope);
  const pattern = await execute(right, scope);
  let tokens = [];
  let terms = [];
  await gatherText(text, (part) => {
    tokens = tokens.concat(matchTokenize(part));
  });
  const didSucceed = await gatherText(pattern, (part) => {
    terms = terms.concat(matchPatternRegex(part));
  });
  if (!didSucceed) {
    return 0;
  }
  if (tokens.length === 0 || terms.length === 0) {
    return 0;
  }
  let score2 = 0;
  for (const re of terms) {
    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);
    score2 += freq * (BM25k + 1) / (freq + BM25k);
  }
  return score2;
}
async function portableTextContent(value) {
  if (value.type === "object") {
    return blockText(value.data);
  } else if (value.isArray()) {
    const texts = await arrayText(value);
    if (texts.length > 0) {
      return texts.join("\n\n");
    }
  }
  return null;
}
async function arrayText(value, result = []) {
  for await (const block of value) {
    if (block.type === "object") {
      const text = blockText(block.data);
      if (text !== null)
        result.push(text);
    } else if (block.isArray()) {
      await arrayText(block, result);
    }
  }
  return result;
}
function blockText(obj) {
  if (typeof obj._type !== "string")
    return null;
  const children = obj.children;
  if (!Array.isArray(children))
    return null;
  let result = "";
  for (const child of children) {
    if (child && typeof child === "object" && typeof child._type === "string" && child._type === "span" && typeof child.text === "string") {
      result += child.text;
    }
  }
  return result;
}
function hasReference(value, pathSet) {
  switch (getType(value)) {
    case "array":
      for (const v of value) {
        if (hasReference(v, pathSet)) {
          return true;
        }
      }
      break;
    case "object":
      if (value._ref) {
        return pathSet.has(value._ref);
      }
      for (const v of Object.values(value)) {
        if (hasReference(v, pathSet)) {
          return true;
        }
      }
      break;
  }
  return false;
}
function countUTF8(str) {
  let count2 = 0;
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    if (code >= 55296 && code <= 56319) {
      continue;
    }
    count2++;
  }
  return count2;
}
const global = {};
global.coalesce = async function coalesce(args, scope, execute) {
  for (const arg of args) {
    const value = await execute(arg, scope);
    if (value.type !== "null") {
      return value;
    }
  }
  return NULL_VALUE;
};
global.count = async function count(args, scope, execute) {
  const inner = await execute(args[0], scope);
  if (!inner.isArray()) {
    return NULL_VALUE;
  }
  let num = 0;
  for await (const _ of inner) {
    num++;
  }
  return fromNumber(num);
};
global.count.arity = 1;
global.dateTime = async function dateTime(args, scope, execute) {
  const val = await execute(args[0], scope);
  if (val.type === "datetime") {
    return val;
  }
  if (val.type !== "string") {
    return NULL_VALUE;
  }
  return DateTime.parseToValue(val.data);
};
global.dateTime.arity = 1;
global.defined = async function defined(args, scope, execute) {
  const inner = await execute(args[0], scope);
  return inner.type === "null" ? FALSE_VALUE : TRUE_VALUE;
};
global.defined.arity = 1;
global.identity = async function identity(args, scope) {
  return fromString(scope.context.identity);
};
global.identity.arity = 0;
global.length = async function length(args, scope, execute) {
  const inner = await execute(args[0], scope);
  if (inner.type === "string") {
    return fromNumber(countUTF8(inner.data));
  }
  if (inner.isArray()) {
    let num = 0;
    for await (const _ of inner) {
      num++;
    }
    return fromNumber(num);
  }
  return NULL_VALUE;
};
global.length.arity = 1;
global.path = async function path(args, scope, execute) {
  const inner = await execute(args[0], scope);
  if (inner.type !== "string") {
    return NULL_VALUE;
  }
  return fromPath(new Path(inner.data));
};
global.path.arity = 1;
global.string = async function string(args, scope, execute) {
  const value = await execute(args[0], scope);
  switch (value.type) {
    case "number":
    case "string":
    case "boolean":
    case "datetime":
      return fromString(`${value.data}`);
    default:
      return NULL_VALUE;
  }
};
global.string.arity = 1;
global.references = async function references(args, scope, execute) {
  const pathSet = new Set();
  for (const arg of args) {
    const path2 = await execute(arg, scope);
    if (path2.type === "string") {
      pathSet.add(path2.data);
    } else if (path2.isArray()) {
      for await (const elem of path2) {
        if (elem.type === "string") {
          pathSet.add(elem.data);
        }
      }
    }
  }
  if (pathSet.size === 0) {
    return FALSE_VALUE;
  }
  const scopeValue = await scope.value.get();
  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;
};
global.references.arity = (c) => c >= 1;
global.round = async function round(args, scope, execute) {
  const value = await execute(args[0], scope);
  if (value.type !== "number") {
    return NULL_VALUE;
  }
  const num = value.data;
  let prec = 0;
  if (args.length === 2) {
    const precValue = await execute(args[1], scope);
    if (precValue.type !== "number" || precValue.data < 0 || !Number.isInteger(precValue.data)) {
      return NULL_VALUE;
    }
    prec = precValue.data;
  }
  if (prec === 0) {
    if (num < 0) {
      return fromNumber(-Math.round(-num));
    }
    return fromNumber(Math.round(num));
  }
  return fromNumber(Number(num.toFixed(prec)));
};
global.round.arity = (count2) => count2 >= 1 && count2 <= 2;
global.now = async function now(args, scope) {
  return fromString(scope.context.timestamp.toISOString());
};
global.now.arity = 0;
global.boost = async function boost() {
  throw new Error("unexpected boost call");
};
global.boost.arity = 2;
const string2 = {};
string2.lower = async function(args, scope, execute) {
  const value = await execute(args[0], scope);
  if (value.type !== "string") {
    return NULL_VALUE;
  }
  return fromString(value.data.toLowerCase());
};
string2.lower.arity = 1;
string2.upper = async function(args, scope, execute) {
  const value = await execute(args[0], scope);
  if (value.type !== "string") {
    return NULL_VALUE;
  }
  return fromString(value.data.toUpperCase());
};
string2.upper.arity = 1;
global.lower = string2.lower;
global.upper = string2.upper;
const pt = {};
pt.text = async function(args, scope, execute) {
  const value = await execute(args[0], scope);
  const text = await portableTextContent(value);
  if (text === null) {
    return NULL_VALUE;
  }
  return fromString(text);
};
pt.text.arity = 1;
const sanity = {};
sanity.projectId = async function(args, scope) {
  if (scope.context.sanity) {
    return fromString(scope.context.sanity.projectId);
  }
  return NULL_VALUE;
};
sanity.dataset = async function(args, scope) {
  if (scope.context.sanity) {
    return fromString(scope.context.sanity.dataset);
  }
  return NULL_VALUE;
};
const pipeFunctions = {};
pipeFunctions.order = async function order(base, args, scope, execute) {
  await true;
  if (!base.isArray()) {
    return NULL_VALUE;
  }
  const mappers = [];
  const directions = [];
  let n = 0;
  for (let mapper of args) {
    let direction = "asc";
    if (mapper.type === "Desc") {
      direction = "desc";
      mapper = mapper.base;
    } else if (mapper.type === "Asc") {
      mapper = mapper.base;
    }
    mappers.push(mapper);
    directions.push(direction);
    n++;
  }
  const aux = [];
  let idx = 0;
  for await (const value of base) {
    const newScope = scope.createNested(value);
    const tuple = [await value.get(), idx];
    for (let i = 0; i < n; i++) {
      const result = await execute(mappers[i], newScope);
      tuple.push(await result.get());
    }
    aux.push(tuple);
    idx++;
  }
  aux.sort((aTuple, bTuple) => {
    for (let i = 0; i < n; i++) {
      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);
      if (directions[i] === "desc") {
        c = -c;
      }
      if (c !== 0) {
        return c;
      }
    }
    return aTuple[1] - bTuple[1];
  });
  return fromJS(aux.map((v) => v[0]));
};
pipeFunctions.order.arity = (count2) => count2 >= 1;
pipeFunctions.score = async function score(base, args, scope, execute) {
  if (!base.isArray())
    return NULL_VALUE;
  const unknown = [];
  const scored = [];
  for await (const value of base) {
    if (value.type !== "object") {
      unknown.push(await value.get());
      continue;
    }
    const newScope = scope.createNested(value);
    let valueScore = typeof value.data._score === "number" ? value.data._score : 0;
    for (const arg of args) {
      valueScore += await evaluateScore(arg, newScope, execute);
    }
    const newObject = Object.assign({}, value.data, { _score: valueScore });
    scored.push(newObject);
  }
  scored.sort((a, b) => b._score - a._score);
  return fromJS(scored);
};
pipeFunctions.score.arity = (count2) => count2 >= 1;
const delta = {};
delta.operation = async function(args, scope) {
  const hasBefore = scope.context.before !== null;
  const hasAfter = scope.context.after !== null;
  if (hasBefore && hasAfter) {
    return fromString("update");
  }
  if (hasAfter) {
    return fromString("create");
  }
  if (hasBefore) {
    return fromString("delete");
  }
  return NULL_VALUE;
};
delta.changedAny = () => {
  throw new Error("not implemented");
};
delta.changedAny.arity = 1;
delta.changedAny.mode = "delta";
delta.changedOnly = () => {
  throw new Error("not implemented");
};
delta.changedOnly.arity = 1;
delta.changedOnly.mode = "delta";
const diff = {};
diff.changedAny = () => {
  throw new Error("not implemented");
};
diff.changedAny.arity = 3;
diff.changedOnly = () => {
  throw new Error("not implemented");
};
diff.changedOnly.arity = 3;
const namespaces = {
  global,
  string: string2,
  pt,
  delta,
  diff,
  sanity
};
const WS = /^([\t\n\v\f\r \u0085\u00A0]|(\/\/[^\n]*\n))+/;
const NUM = /^\d+/;
const IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;
const PREC_PAIR = 1;
const PREC_OR = 2;
const PREC_AND = 3;
const PREC_COMP = 4;
const PREC_ORDER = 4;
const PREC_ADD = 6;
const PREC_SUB = 6;
const PREC_MUL = 7;
const PREC_DIV = 7;
const PREC_MOD = 7;
const PREC_POW = 8;
const PREC_POS = 10;
const PREC_NOT = 10;
const PREC_NEG = 8;
function parse$1(str) {
  let pos = 0;
  pos = skipWS(str, pos);
  let result = parseExpr(str, pos, 0);
  if (result.type === "error")
    return result;
  pos = skipWS(str, result.position);
  if (pos !== str.length) {
    if (result.failPosition) {
      pos = result.failPosition - 1;
    }
    return { type: "error", position: pos };
  }
  delete result.position;
  delete result.failPosition;
  return result;
}
function parseExpr(str, pos, level) {
  let startPos = pos;
  let token = str[pos];
  let marks;
  switch (token) {
    case "+": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);
      if (rhs.type === "error")
        return rhs;
      marks = [{ name: "pos", position: startPos }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "-": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);
      if (rhs.type === "error")
        return rhs;
      marks = [{ name: "neg", position: startPos }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "(": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);
      if (rhs.type === "error")
        return rhs;
      pos = skipWS(str, rhs.position);
      switch (str[pos]) {
        case ",": {
          marks = [{ name: "tuple", position: startPos }].concat(rhs.marks);
          pos = skipWS(str, pos + 1);
          while (true) {
            rhs = parseExpr(str, pos, 0);
            if (rhs.type === "error")
              return rhs;
            pos = skipWS(str, rhs.position);
            if (str[pos] !== ",")
              break;
            pos = skipWS(str, pos + 1);
          }
          if (str[pos] !== ")")
            return { type: "error", position: pos };
          pos++;
          marks.push({ name: "tuple_end", position: pos });
          break;
        }
        case ")": {
          pos++;
          marks = [{ name: "group", position: startPos }].concat(rhs.marks);
          break;
        }
        default:
          return { type: "error", position: pos };
      }
      break;
    }
    case "!": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);
      if (rhs.type === "error")
        return rhs;
      marks = [{ name: "not", position: startPos }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "{": {
      let result = parseObject(str, pos);
      if (result.type === "error")
        return result;
      marks = result.marks;
      pos = result.position;
      break;
    }
    case "[":
      marks = [{ name: "array", position: pos }];
      pos = skipWS(str, pos + 1);
      if (str[pos] !== "]") {
        while (true) {
          if (str.slice(pos, pos + 3) === "...") {
            marks.push({ name: "array_splat", position: pos });
            pos = skipWS(str, pos + 3);
          }
          let res = parseExpr(str, pos, 0);
          if (res.type === "error")
            return res;
          marks = marks.concat(res.marks);
          pos = res.position;
          pos = skipWS(str, pos);
          if (str[pos] !== ",")
            break;
          pos = skipWS(str, pos + 1);
          if (str[pos] === "]")
            break;
        }
      }
      if (str[pos] === "]") {
        pos++;
        marks.push({ name: "array_end", position: pos });
      } else {
        return { type: "error", position: pos };
      }
      break;
    case "'":
    case '"': {
      let result = parseString(str, pos);
      if (result.type === "error")
        return result;
      marks = result.marks;
      pos = result.position;
      break;
    }
    case "^": {
      pos++;
      marks = [];
      while (str[pos] === "." && str[pos + 1] === "^") {
        marks.push({ name: "dblparent", position: startPos });
        pos += 2;
      }
      marks.push({ name: "parent", position: startPos });
      break;
    }
    case "@":
      marks = [{ name: "this", position: startPos }];
      pos++;
      break;
    case "*":
      marks = [{ name: "everything", position: startPos }];
      pos++;
      break;
    case "$": {
      let identLen = parseRegex(str, pos + 1, IDENT);
      if (identLen) {
        pos += 1 + identLen;
        marks = [
          { name: "param", position: startPos },
          { name: "ident", position: startPos + 1 },
          { name: "ident_end", position: pos }
        ];
      }
      break;
    }
    default: {
      let numLen = parseRegex(str, pos, NUM);
      if (numLen) {
        pos += numLen;
        let name = "integer";
        if (str[pos] === ".") {
          let fracLen = parseRegex(str, pos + 1, NUM);
          if (fracLen) {
            name = "float";
            pos += 1 + fracLen;
          }
        }
        if (str[pos] === "e" || str[pos] === "E") {
          name = "sci";
          pos++;
          if (str[pos] === "+" || str[pos] === "-") {
            pos++;
          }
          let expLen = parseRegex(str, pos, NUM);
          if (!expLen)
            return { type: "error", position: pos };
          pos += expLen;
        }
        marks = [
          { name, position: startPos },
          { name: name + "_end", position: pos }
        ];
        break;
      }
      let identLen = parseRegex(str, pos, IDENT);
      if (identLen) {
        pos += identLen;
        switch (str[pos]) {
          case ":":
          case "(": {
            let result = parseFuncCall(str, startPos, pos);
            if (result.type === "error")
              return result;
            marks = result.marks;
            pos = result.position;
            break;
          }
          default: {
            marks = [
              { name: "this_attr", position: startPos },
              { name: "ident", position: startPos },
              { name: "ident_end", position: pos }
            ];
          }
        }
        break;
      }
    }
  }
  if (!marks) {
    return { type: "error", position: pos };
  }
  let lhsLevel = 12;
  let trav;
  loop:
    while (true) {
      let innerPos = skipWS(str, pos);
      if (innerPos === str.length) {
        pos = innerPos;
        break;
      }
      trav = parseTraversal(str, innerPos);
      if (trav.type === "success") {
        marks.unshift({ name: "traverse", position: startPos });
        while (trav.type === "success") {
          marks = marks.concat(trav.marks);
          pos = trav.position;
          trav = parseTraversal(str, skipWS(str, pos));
        }
        marks.push({ name: "traversal_end", position: pos });
        continue;
      }
      let token2 = str[innerPos];
      switch (token2) {
        case "=": {
          let nextToken = str[innerPos + 1];
          switch (nextToken) {
            case ">": {
              if (level > PREC_PAIR || lhsLevel <= PREC_PAIR)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);
              if (rhs.type === "error")
                return rhs;
              marks = marks.concat(rhs.marks);
              marks.unshift({ name: "pair", position: startPos });
              pos = rhs.position;
              lhsLevel = PREC_PAIR;
              break;
            }
            case "=": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);
              if (rhs.type === "error")
                return rhs;
              marks.unshift({ name: "comp", position: startPos });
              marks.push({ name: "op", position: innerPos }, { name: "op_end", position: innerPos + 2 });
              marks = marks.concat(rhs.marks);
              pos = rhs.position;
              lhsLevel = PREC_COMP;
              break;
            }
            default:
              break loop;
          }
          break;
        }
        case "+": {
          if (level > PREC_ADD || lhsLevel < PREC_ADD)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "add", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_ADD;
          break;
        }
        case "-": {
          if (level > PREC_SUB || lhsLevel < PREC_SUB)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "sub", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_SUB;
          break;
        }
        case "*": {
          if (str[innerPos + 1] === "*") {
            if (level > PREC_POW || lhsLevel <= PREC_POW)
              break loop;
            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);
            if (rhs2.type === "error")
              return rhs2;
            marks = marks.concat(rhs2.marks);
            marks.unshift({ name: "pow", position: startPos });
            pos = rhs2.position;
            lhsLevel = PREC_POW;
            break;
          }
          if (level > PREC_MUL || lhsLevel < PREC_MUL)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "mul", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_MUL;
          break;
        }
        case "/": {
          if (level > PREC_DIV || lhsLevel < PREC_DIV)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "div", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_DIV;
          break;
        }
        case "%": {
          if (level > PREC_MOD || lhsLevel < PREC_MOD)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "mod", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_MOD;
          break;
        }
        case "<":
        case ">": {
          if (level > PREC_COMP || lhsLevel <= PREC_COMP)
            break loop;
          let nextPos = innerPos + 1;
          if (str[nextPos] === "=") {
            nextPos++;
          }
          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);
          if (rhs.type === "error")
            return rhs;
          marks.unshift({ name: "comp", position: startPos });
          marks.push({ name: "op", position: innerPos }, { name: "op_end", position: nextPos });
          marks = marks.concat(rhs.marks);
          pos = rhs.position;
          lhsLevel = PREC_COMP;
          break;
        }
        case "|": {
          if (str[innerPos + 1] === "|") {
            if (level > PREC_OR || lhsLevel < PREC_OR)
              break loop;
            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);
            if (rhs.type === "error")
              return rhs;
            marks = marks.concat(rhs.marks);
            marks.unshift({ name: "or", position: startPos });
            pos = rhs.position;
            lhsLevel = PREC_OR;
          } else {
            if (level > 11 || lhsLevel < 11)
              break loop;
            let identPos = skipWS(str, innerPos + 1);
            let identLen = parseRegex(str, identPos, IDENT);
            if (!identLen)
              return { type: "error", position: identPos };
            pos = identPos + identLen;
            if (str[pos] === "(" || str[pos] === ":") {
              let result = parseFuncCall(str, identPos, pos);
              if (result.type === "error")
                return result;
              marks = marks.concat(result.marks);
              marks.unshift({ name: "pipecall", position: startPos });
              pos = result.position;
              lhsLevel = 11;
            }
          }
          break;
        }
        case "&": {
          if (str[innerPos + 1] != "&")
            break loop;
          if (level > PREC_AND || lhsLevel < PREC_AND)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "and", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_AND;
          break;
        }
        case "!": {
          if (str[innerPos + 1] !== "=")
            break loop;
          if (level > PREC_COMP || lhsLevel < PREC_COMP)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);
          if (rhs.type === "error")
            return rhs;
          marks.unshift({ name: "comp", position: startPos });
          marks.push({ name: "op", position: innerPos }, { name: "op_end", position: innerPos + 2 });
          marks = marks.concat(rhs.marks);
          pos = rhs.position;
          lhsLevel = PREC_COMP;
          break;
        }
        case "d": {
          if (str.slice(innerPos, innerPos + 4) !== "desc")
            break loop;
          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)
            break loop;
          marks.unshift({ name: "desc", position: startPos });
          pos = innerPos + 4;
          lhsLevel = PREC_ORDER;
          break;
        }
        case "a": {
          if (str.slice(innerPos, innerPos + 3) !== "asc")
            break loop;
          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)
            break loop;
          marks.unshift({ name: "asc", position: startPos });
          pos = innerPos + 3;
          lhsLevel = PREC_ORDER;
          break;
        }
        default: {
          let ident = parseRegexStr(str, innerPos, IDENT);
          switch (ident) {
            case "in": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              pos = skipWS(str, innerPos + 2);
              let isGroup = false;
              if (str[pos] === "(") {
                isGroup = true;
                pos = skipWS(str, pos + 1);
              }
              let rangePos = pos;
              let result = parseExpr(str, pos, PREC_COMP + 1);
              if (result.type === "error")
                return result;
              pos = skipWS(str, result.position);
              if (str[pos] === "." && str[pos + 1] === ".") {
                let type = "inc_range";
                if (str[pos + 2] === ".") {
                  type = "exc_range";
                  pos = skipWS(str, pos + 3);
                } else {
                  pos = skipWS(str, pos + 2);
                }
                let rhs = parseExpr(str, pos, PREC_COMP + 1);
                if (rhs.type === "error")
                  return rhs;
                marks.unshift({ name: "in_range", position: startPos });
                marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks);
                pos = rhs.position;
              } else {
                marks.unshift({ name: "comp", position: startPos });
                marks.push({ name: "op", position: innerPos }, { name: "op_end", position: innerPos + 2 });
                marks = marks.concat(result.marks);
              }
              if (isGroup) {
                pos = skipWS(str, pos);
                if (str[pos] !== ")")
                  return { type: "error", position: pos };
                pos++;
              }
              lhsLevel = PREC_COMP;
              break;
            }
            case "match": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);
              if (rhs.type === "error")
                return rhs;
              marks.unshift({ name: "comp", position: startPos });
              marks.push({ name: "op", position: innerPos }, { name: "op_end", position: innerPos + 5 });
              marks = marks.concat(rhs.marks);
              pos = rhs.position;
              lhsLevel = 4;
              break;
            }
            default: {
              break loop;
            }
          }
        }
      }
    }
  let failPosition = (trav == null ? void 0 : trav.type) === "error" && trav.position;
  return { type: "success", marks, position: pos, failPosition };
}
function parseTraversal(str, pos) {
  let startPos = pos;
  switch (str[pos]) {
    case ".": {
      pos = skipWS(str, pos + 1);
      let identStart = pos;
      let identLen2 = parseRegex(str, pos, IDENT);
      if (!identLen2)
        return { type: "error", position: pos };
      pos += identLen2;
      return {
        type: "success",
        marks: [
          { name: "attr_access", position: startPos },
          { name: "ident", position: identStart },
          { name: "ident_end", position: pos }
        ],
        position: pos
      };
    }
    case "-":
      if (str[pos + 1] !== ">")
        return { type: "error", position: pos };
      let marks = [{ name: "deref", position: startPos }];
      pos += 2;
      let identPos = skipWS(str, pos);
      let identLen = parseRegex(str, identPos, IDENT);
      if (identLen) {
        pos = identPos + identLen;
        marks.push({ name: "deref_attr", position: identPos }, { name: "ident", position: identPos }, { name: "ident_end", position: pos });
      }
      return {
        type: "success",
        marks,
        position: pos
      };
    case "[": {
      pos = skipWS(str, pos + 1);
      if (str[pos] === "]") {
        return {
          type: "success",
          marks: [{ name: "array_postfix", position: startPos }],
          position: pos + 1
        };
      }
      let rangePos = pos;
      let result = parseExpr(str, pos, 0);
      if (result.type === "error")
        return result;
      pos = skipWS(str, result.position);
      if (str[pos] === "." && str[pos + 1] === ".") {
        let type = "inc_range";
        if (str[pos + 2] === ".") {
          type = "exc_range";
          pos += 3;
        } else {
          pos += 2;
        }
        pos = skipWS(str, pos);
        let rhs = parseExpr(str, pos, 0);
        if (rhs.type === "error")
          return rhs;
        pos = skipWS(str, rhs.position);
        if (str[pos] !== "]")
          return { type: "error", position: pos };
        return {
          type: "success",
          marks: [
            { name: "slice", position: startPos },
            { name: type, position: rangePos }
          ].concat(result.marks, rhs.marks),
          position: pos + 1
        };
      }
      if (str[pos] !== "]")
        return { type: "error", position: pos };
      return {
        type: "success",
        marks: [{ name: "square_bracket", position: startPos }].concat(result.marks),
        position: pos + 1
      };
    }
    case "|": {
      pos = skipWS(str, pos + 1);
      if (str[pos] === "{") {
        let result = parseObject(str, pos);
        if (result.type === "error")
          return result;
        result.marks.unshift({ name: "projection", position: startPos });
        return result;
      }
      break;
    }
    case "{": {
      let result = parseObject(str, pos);
      if (result.type === "error")
        return result;
      result.marks.unshift({ name: "projection", position: startPos });
      return result;
    }
  }
  return { type: "error", position: pos };
}
function parseFuncCall(str, startPos, pos) {
  let marks = [];
  marks.push({ name: "func_call", position: startPos });
  if (str[pos] === ":" && str[pos + 1] === ":") {
    marks.push({ name: "namespace", position: startPos });
    marks.push({ name: "ident", position: startPos }, { name: "ident_end", position: pos });
    pos = skipWS(str, pos + 2);
    let nameLen = parseRegex(str, pos, IDENT);
    if (!nameLen)
      return { type: "error", position: pos };
    marks.push({ name: "ident", position: pos }, { name: "ident_end", position: pos + nameLen });
    pos = skipWS(str, pos + nameLen);
    if (str[pos] !== "(")
      return { type: "error", position: pos };
    pos++;
  } else {
    marks.push({ name: "ident", position: startPos }, { name: "ident_end", position: pos });
    pos = skipWS(str, pos + 1);
  }
  let lastPos = pos;
  if (str[pos] !== ")") {
    while (true) {
      let result = parseExpr(str, pos, 0);
      if (result.type === "error")
        return result;
      marks = marks.concat(result.marks);
      lastPos = result.position;
      pos = skipWS(str, result.position);
      if (str[pos] !== ",")
        break;
      pos = skipWS(str, pos + 1);
      if (str[pos] === ")")
        break;
    }
  }
  if (str[pos] !== ")") {
    return { type: "error", position: pos };
  }
  marks.push({ name: "func_args_end", position: lastPos });
  return {
    type: "success",
    marks,
    position: pos + 1
  };
}
function parseObject(str, pos) {
  let marks = [{ name: "object", position: pos }];
  pos = skipWS(str, pos + 1);
  while (str[pos] !== "}") {
    let pairPos = pos;
    if (str.slice(pos, pos + 3) === "...") {
      pos = skipWS(str, pos + 3);
      if (str[pos] !== "}" && str[pos] !== ",") {
        let expr = parseExpr(str, pos, 0);
        if (expr.type === "error")
          return expr;
        marks.push({ name: "object_splat", position: pairPos });
        marks = marks.concat(expr.marks);
        pos = expr.position;
      } else {
        marks.push({ name: "object_splat_this", position: pairPos });
      }
    } else {
      let expr = parseExpr(str, pos, 0);
      if (expr.type === "error")
        return expr;
      let nextPos = skipWS(str, expr.position);
      if (expr.marks[0].name === "str" && str[nextPos] === ":") {
        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);
        if (value.type === "error")
          return value;
        marks.push({ name: "object_pair", position: pairPos });
        marks = marks.concat(expr.marks, value.marks);
        pos = value.position;
      } else {
        marks = marks.concat({ name: "object_expr", position: pos }, expr.marks);
        pos = expr.position;
      }
    }
    pos = skipWS(str, pos);
    if (str[pos] !== ",")
      break;
    pos = skipWS(str, pos + 1);
  }
  if (str[pos] !== "}") {
    return { type: "error", position: pos };
  }
  pos++;
  marks.push({ name: "object_end", position: pos });
  return { type: "success", marks, position: pos };
}
function parseString(str, pos) {
  let token = str[pos];
  pos = pos + 1;
  const marks = [{ name: "str", position: pos }];
  str:
    for (; ; pos++) {
      if (pos > str.length)
        return { type: "error", position: pos };
      switch (str[pos]) {
        case token: {
          marks.push({ name: "str_end", position: pos });
          pos++;
          break str;
        }
        case "\\": {
          marks.push({ name: "str_pause", position: pos });
          if (str[pos + 1] === "u") {
            if (str[pos + 2] === "{") {
              marks.push({ name: "unicode_hex", position: pos + 3 });
              pos = str.indexOf("}", pos + 3);
              marks.push({ name: "unicode_hex_end", position: pos });
              pos++;
            } else {
              marks.push({ name: "unicode_hex", position: pos + 2 });
              marks.push({ name: "unicode_hex_end", position: pos + 6 });
              pos += 5;
            }
          } else {
            marks.push({ name: "single_escape", position: pos + 1 });
            pos += 1;
          }
          marks.push({ name: "str_start", position: pos + 1 });
        }
      }
    }
  return { type: "success", marks, position: pos };
}
function skipWS(str, pos) {
  return pos + parseRegex(str, pos, WS);
}
function parseRegex(str, pos, re) {
  let m = re.exec(str.slice(pos));
  return m ? m[0].length : 0;
}
function parseRegexStr(str, pos, re) {
  let m = re.exec(str.slice(pos));
  return m ? m[0] : null;
}
function join(a, b) {
  return (base) => b(a(base));
}
function map(inner) {
  return (base) => ({ type: "Map", base, expr: inner({ type: "This" }) });
}
function flatMap(inner) {
  return (base) => ({ type: "FlatMap", base, expr: inner({ type: "This" }) });
}
function traverseArray(build, right) {
  if (!right) {
    return {
      type: "a-a",
      build
    };
  }
  switch (right.type) {
    case "a-a":
      return {
        type: "a-a",
        build: join(build, right.build)
      };
    case "a-b":
      return {
        type: "a-b",
        build: join(build, right.build)
      };
    case "b-b":
      return {
        type: "a-a",
        build: join(build, map(right.build))
      };
    case "b-a":
      return {
        type: "a-a",
        build: join(build, flatMap(right.build))
      };
    default:
      throw new Error(`unknown type: ${right.type}`);
  }
}
function traversePlain(mapper, right) {
  if (!right) {
    return {
      type: "b-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
    case "b-a":
      return {
        type: "b-a",
        build: join(mapper, right.build)
      };
    case "a-b":
    case "b-b":
      return {
        type: "b-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error(`unknown type: ${right.type}`);
  }
}
function traverseElement(mapper, right) {
  if (!right) {
    return {
      type: "a-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
    case "b-a":
      return {
        type: "a-a",
        build: join(mapper, right.build)
      };
    case "a-b":
    case "b-b":
      return {
        type: "a-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error(`unknown type: ${right.type}`);
  }
}
function traverseProjection(mapper, right) {
  if (!right) {
    return {
      type: "b-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
      return {
        type: "a-a",
        build: join(map(mapper), right.build)
      };
    case "a-b":
      return {
        type: "a-b",
        build: join(map(mapper), right.build)
      };
    case "b-a":
      return {
        type: "b-a",
        build: join(mapper, right.build)
      };
    case "b-b":
      return {
        type: "b-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error(`unknown type: ${right.type}`);
  }
}
const isEqual = equality;
function equality(a, b) {
  if (a.type === "string" && b.type === "string" || a.type === "boolean" && b.type === "boolean" || a.type === "null" && b.type === "null" || a.type === "number" && b.type === "number") {
    return a.data === b.data;
  }
  if (a.type === "datetime" && b.type === "datetime") {
    return a.data.equals(b.data);
  }
  return false;
}
const operators = {
  "==": function eq(left, right) {
    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;
  },
  "!=": function neq(left, right) {
    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;
  },
  ">": function gt(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result > 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  ">=": function gte(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  "<": function lt(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result < 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  "<=": function lte(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  in: async function inop(left, right) {
    if (right.type === "path") {
      if (left.type !== "string") {
        return NULL_VALUE;
      }
      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;
    }
    if (right.isArray()) {
      for await (const b of right) {
        if (isEqual(left, b)) {
          return TRUE_VALUE;
        }
      }
      return FALSE_VALUE;
    }
    return NULL_VALUE;
  },
  match: async function match(left, right) {
    let tokens = [];
    let patterns = [];
    await gatherText(left, (part) => {
      tokens = tokens.concat(matchTokenize(part));
    });
    const didSucceed = await gatherText(right, (part) => {
      patterns = patterns.concat(matchAnalyzePattern(part));
    });
    if (!didSucceed) {
      return FALSE_VALUE;
    }
    const matched = matchText(tokens, patterns);
    return matched ? TRUE_VALUE : FALSE_VALUE;
  },
  "+": function plus(left, right) {
    if (left.type === "datetime" && right.type === "number") {
      return fromDateTime(left.data.add(right.data));
    }
    if (left.type === "number" && right.type === "number") {
      return fromNumber(left.data + right.data);
    }
    if (left.type === "string" && right.type === "string") {
      return fromString(left.data + right.data);
    }
    if (left.type === "object" && right.type === "object") {
      return fromJS(__spreadValues(__spreadValues({}, left.data), right.data));
    }
    if (left.type === "array" && right.type === "array") {
      return fromJS(left.data.concat(right.data));
    }
    if (left.isArray() && right.isArray()) {
      return new StreamValue(async function* () {
        for await (const val of left) {
          yield val;
        }
        for await (const val of right) {
          yield val;
        }
      });
    }
    return NULL_VALUE;
  },
  "-": function minus(left, right) {
    if (left.type === "datetime" && right.type === "number") {
      return fromDateTime(left.data.add(-right.data));
    }
    if (left.type === "datetime" && right.type === "datetime") {
      return fromNumber(left.data.difference(right.data));
    }
    if (left.type === "number" && right.type === "number") {
      return fromNumber(left.data - right.data);
    }
    return NULL_VALUE;
  },
  "*": numericOperator((a, b) => a * b),
  "/": numericOperator((a, b) => a / b),
  "%": numericOperator((a, b) => a % b),
  "**": numericOperator((a, b) => Math.pow(a, b))
};
function numericOperator(impl) {
  return function(left, right) {
    if (left.type === "number" && right.type === "number") {
      const result = impl(left.data, right.data);
      return fromNumber(result);
    }
    return NULL_VALUE;
  };
}
class Scope {
  constructor(params, source, value, context, parent) {
    this.isHidden = false;
    this.params = params;
    this.source = source;
    this.value = value;
    this.context = context;
    this.parent = parent;
  }
  createNested(value) {
    if (this.isHidden) {
      return new Scope(this.params, this.source, value, this.context, this.parent);
    }
    return new Scope(this.params, this.source, value, this.context, this);
  }
  createHidden(value) {
    const result = this.createNested(value);
    result.isHidden = true;
    return result;
  }
}
function evaluate(node, scope, execute = evaluate) {
  const func = EXECUTORS[node.type];
  return func(node, scope, execute);
}
function promiselessApply(value, cb) {
  if ("then" in value) {
    return value.then(cb);
  }
  return cb(value);
}
const EXECUTORS = {
  This(_, scope) {
    return scope.value;
  },
  Everything(_, scope) {
    return scope.source;
  },
  Parameter({ name }, scope) {
    return fromJS(scope.params[name]);
  },
  Context({ key }, scope) {
    if (key === "before" || key === "after") {
      const value = scope.context[key];
      return value || NULL_VALUE;
    }
    throw new Error(`unknown context key: ${key}`);
  },
  Parent({ n }, scope) {
    let current = scope;
    for (let i = 0; i < n; i++) {
      if (!current.parent) {
        return NULL_VALUE;
      }
      current = current.parent;
    }
    return current.value;
  },
  OpCall({ op, left, right }, scope, execute) {
    const func = operators[op];
    if (!func) {
      throw new Error(`Unknown operator: ${op}`);
    }
    const leftValue = execute(left, scope);
    const rightValue = execute(right, scope);
    if ("then" in leftValue || "then" in rightValue) {
      return (async () => func(await leftValue, await rightValue))();
    }
    return func(leftValue, rightValue);
  },
  async Select({ alternatives, fallback }, scope, execute) {
    for (const alt of alternatives) {
      const altCond = await execute(alt.condition, scope);
      if (altCond.type === "boolean" && altCond.data === true) {
        return execute(alt.value, scope);
      }
    }
    if (fallback) {
      return execute(fallback, scope);
    }
    return NULL_VALUE;
  },
  async InRange({ base, left, right, isInclusive }, scope, execute) {
    const value = await execute(base, scope);
    const leftValue = await execute(left, scope);
    const rightValue = await execute(right, scope);
    const leftCmp = partialCompare(await value.get(), await leftValue.get());
    if (leftCmp === null) {
      return NULL_VALUE;
    }
    const rightCmp = partialCompare(await value.get(), await rightValue.get());
    if (rightCmp === null) {
      return NULL_VALUE;
    }
    if (isInclusive) {
      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;
    }
    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  async Filter({ base, expr }, scope, execute) {
    const baseValue = await execute(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of baseValue) {
        const newScope = scope.createNested(elem);
        const exprValue = await execute(expr, newScope);
        if (exprValue.type === "boolean" && exprValue.data === true) {
          yield elem;
        }
      }
    });
  },
  async Projection({ base, expr }, scope, execute) {
    const baseValue = await execute(base, scope);
    if (baseValue.type !== "object") {
      return NULL_VALUE;
    }
    const newScope = scope.createNested(baseValue);
    return execute(expr, newScope);
  },
  FuncCall({ func, args }, scope, execute) {
    return func(args, scope, execute);
  },
  async PipeFuncCall({ func, base, args }, scope, execute) {
    const baseValue = await execute(base, scope);
    return func(baseValue, args, scope, execute);
  },
  async AccessAttribute({ base, name }, scope, execute) {
    let value = scope.value;
    if (base) {
      value = await execute(base, scope);
    }
    if (value.type === "object") {
      if (value.data.hasOwnProperty(name)) {
        return fromJS(value.data[name]);
      }
    }
    return NULL_VALUE;
  },
  async AccessElement({ base, index }, scope, execute) {
    const baseValue = await execute(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    const data = await baseValue.get();
    const finalIndex = index < 0 ? index + data.length : index;
    return fromJS(data[finalIndex]);
  },
  async Slice({ base, left, right, isInclusive }, scope, execute) {
    const baseValue = await execute(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    const array = await baseValue.get();
    let leftIdx = left;
    let rightIdx = right;
    if (leftIdx < 0) {
      leftIdx = array.length + leftIdx;
    }
    if (rightIdx < 0) {
      rightIdx = array.length + rightIdx;
    }
    if (isInclusive) {
      rightIdx++;
    }
    if (leftIdx < 0) {
      leftIdx = 0;
    }
    if (rightIdx < 0) {
      rightIdx = 0;
    }
    return fromJS(array.slice(leftIdx, rightIdx));
  },
  async Deref({ base }, scope, execute) {
    const value = await execute(base, scope);
    if (!scope.source.isArray()) {
      return NULL_VALUE;
    }
    if (value.type !== "object") {
      return NULL_VALUE;
    }
    const id = value.data._ref;
    if (typeof id !== "string") {
      return NULL_VALUE;
    }
    for await (const doc of scope.source) {
      if (doc.type === "object" && id === doc.data._id) {
        return doc;
      }
    }
    return NULL_VALUE;
  },
  Value({ value }) {
    return fromJS(value);
  },
  Group({ base }, scope, execute) {
    return execute(base, scope);
  },
  async Object({ attributes }, scope, execute) {
    const result = {};
    for (const attr of attributes) {
      const attrType = attr.type;
      switch (attr.type) {
        case "ObjectAttributeValue": {
          const value = await execute(attr.value, scope);
          result[attr.name] = await value.get();
          break;
        }
        case "ObjectConditionalSplat": {
          const cond = await execute(attr.condition, scope);
          if (cond.type !== "boolean" || cond.data === false) {
            continue;
          }
          const value = await execute(attr.value, scope);
          if (value.type === "object") {
            Object.assign(result, value.data);
          }
          break;
        }
        case "ObjectSplat": {
          const value = await execute(attr.value, scope);
          if (value.type === "object") {
            Object.assign(result, value.data);
          }
          break;
        }
        default:
          throw new Error(`Unknown node type: ${attrType}`);
      }
    }
    return fromJS(result);
  },
  Array({ elements }, scope, execute) {
    return new StreamValue(async function* () {
      for (const element of elements) {
        const value = await execute(element.value, scope);
        if (element.isSplat) {
          if (value.isArray()) {
            for await (const v of value) {
              yield v;
            }
          }
        } else {
          yield value;
        }
      }
    });
  },
  Tuple() {
    throw new Error("tuples can not be evaluated");
  },
  async Or({ left, right }, scope, execute) {
    const leftValue = await execute(left, scope);
    const rightValue = await execute(right, scope);
    if (leftValue.type === "boolean") {
      if (leftValue.data === true) {
        return TRUE_VALUE;
      }
    }
    if (rightValue.type === "boolean") {
      if (rightValue.data === true) {
        return TRUE_VALUE;
      }
    }
    if (leftValue.type !== "boolean" || rightValue.type !== "boolean") {
      return NULL_VALUE;
    }
    return FALSE_VALUE;
  },
  async And({ left, right }, scope, execute) {
    const leftValue = await execute(left, scope);
    const rightValue = await execute(right, scope);
    if (leftValue.type === "boolean") {
      if (leftValue.data === false) {
        return FALSE_VALUE;
      }
    }
    if (rightValue.type === "boolean") {
      if (rightValue.data === false) {
        return FALSE_VALUE;
      }
    }
    if (leftValue.type !== "boolean" || rightValue.type !== "boolean") {
      return NULL_VALUE;
    }
    return TRUE_VALUE;
  },
  async Not({ base }, scope, execute) {
    const value = await execute(base, scope);
    if (value.type !== "boolean") {
      return NULL_VALUE;
    }
    return value.data ? FALSE_VALUE : TRUE_VALUE;
  },
  Neg({ base }, scope, execute) {
    return promiselessApply(execute(base, scope), (value) => {
      if (value.type !== "number") {
        return NULL_VALUE;
      }
      return fromNumber(-value.data);
    });
  },
  Pos({ base }, scope, execute) {
    return promiselessApply(execute(base, scope), (value) => {
      if (value.type !== "number") {
        return NULL_VALUE;
      }
      return fromNumber(value.data);
    });
  },
  Asc() {
    return NULL_VALUE;
  },
  Desc() {
    return NULL_VALUE;
  },
  async ArrayCoerce({ base }, scope, execute) {
    const value = await execute(base, scope);
    return value.isArray() ? value : NULL_VALUE;
  },
  async Map({ base, expr }, scope, execute) {
    const value = await execute(base, scope);
    if (!value.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of value) {
        const newScope = scope.createHidden(elem);
        yield await execute(expr, newScope);
      }
    });
  },
  async FlatMap({ base, expr }, scope, execute) {
    const value = await execute(base, scope);
    if (!value.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of value) {
        const newScope = scope.createHidden(elem);
        const innerValue = await execute(expr, newScope);
        if (innerValue.isArray()) {
          for await (const inner of innerValue) {
            yield inner;
          }
        } else {
          yield innerValue;
        }
      }
    });
  }
};
function evaluateQuery(tree, options = {}) {
  const root = fromJS(options.root);
  const dataset = fromJS(options.dataset);
  const params = __spreadValues({}, options.params);
  const scope = new Scope(params, dataset, root, {
    timestamp: options.timestamp || new Date(),
    identity: options.identity === void 0 ? "me" : options.identity,
    sanity: options.sanity,
    after: options.after ? fromJS(options.after) : null,
    before: options.before ? fromJS(options.before) : null
  }, null);
  return evaluate(tree, scope);
}
function canConstantEvaluate(node) {
  switch (node.type) {
    case "Group":
    case "Value":
    case "Parameter":
    case "Pos":
    case "Neg":
      return true;
    case "OpCall":
      switch (node.op) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "**":
          return true;
        default:
          return false;
      }
    default:
      return false;
  }
}
const DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: "me", before: null, after: null }, null);
class ConstantEvaluateError extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConstantEvaluateError";
  }
}
function tryConstantEvaluate(node) {
  try {
    return constantEvaluate(node);
  } catch (err) {
    if (err.name === "ConstantEvaluateError") {
      return null;
    }
    throw err;
  }
}
function constantEvaluate(node) {
  if (!canConstantEvaluate(node)) {
    throw new ConstantEvaluateError("cannot constant evaluate");
  }
  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);
  if ("then" in value) {
    throw new Error("BUG: constant evaluate should never return a promise");
  }
  return value;
}
const ESCAPE_SEQUENCE = {
  "'": "'",
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
};
function expandHex(str) {
  const charCode = parseInt(str, 16);
  return String.fromCharCode(charCode);
}
class GroqQueryError extends Error {
  constructor() {
    super(...arguments);
    this.name = "GroqQueryError";
  }
}
const EXPR_BUILDER = {
  group(p) {
    const inner = p.process(EXPR_BUILDER);
    return {
      type: "Group",
      base: inner
    };
  },
  everything() {
    return { type: "Everything" };
  },
  this() {
    return { type: "This" };
  },
  parent() {
    return {
      type: "Parent",
      n: 1
    };
  },
  dblparent(p) {
    const next = p.process(EXPR_BUILDER);
    return {
      type: "Parent",
      n: next.n + 1
    };
  },
  traverse(p) {
    const base = p.process(EXPR_BUILDER);
    const traversalList = [];
    while (p.getMark().name !== "traversal_end") {
      traversalList.push(p.process(TRAVERSE_BUILDER));
    }
    p.shift();
    let traversal = null;
    for (let i = traversalList.length - 1; i >= 0; i--) {
      traversal = traversalList[i](traversal);
    }
    if (base.type === "Everything" || base.type === "Array" || base.type === "PipeFuncCall") {
      traversal = traverseArray((val) => val, traversal);
    }
    if (traversal === null)
      throw new Error("BUG: unexpected empty traversal");
    return traversal.build(base);
  },
  this_attr(p) {
    const name = p.processString();
    if (name === "null") {
      return { type: "Value", value: null };
    }
    if (name === "true") {
      return { type: "Value", value: true };
    }
    if (name === "false") {
      return { type: "Value", value: false };
    }
    return {
      type: "AccessAttribute",
      name
    };
  },
  neg(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Neg",
      base
    };
  },
  pos(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Pos",
      base
    };
  },
  add(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "+",
      left,
      right
    };
  },
  sub(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "-",
      left,
      right
    };
  },
  mul(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "*",
      left,
      right
    };
  },
  div(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "/",
      left,
      right
    };
  },
  mod(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "%",
      left,
      right
    };
  },
  pow(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "**",
      left,
      right
    };
  },
  comp(p) {
    const left = p.process(EXPR_BUILDER);
    const op = p.processString();
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op,
      left,
      right
    };
  },
  in_range(p) {
    const base = p.process(EXPR_BUILDER);
    const isInclusive = p.getMark().name === "inc_range";
    p.shift();
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "InRange",
      base,
      left,
      right,
      isInclusive
    };
  },
  str(p) {
    let value = "";
    loop:
      while (p.hasMark()) {
        const mark = p.getMark();
        switch (mark.name) {
          case "str_end":
            value += p.processStringEnd();
            break loop;
          case "str_pause":
            value += p.processStringEnd();
            break;
          case "str_start":
            p.shift();
            break;
          case "single_escape": {
            const char = p.slice(1);
            p.shift();
            value += ESCAPE_SEQUENCE[char];
            break;
          }
          case "unicode_hex":
            p.shift();
            value += expandHex(p.processStringEnd());
            break;
          default:
            throw new Error(`unexpected mark: ${mark.name}`);
        }
      }
    return { type: "Value", value };
  },
  integer(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  float(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  sci(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  object(p) {
    const attributes = [];
    while (p.getMark().name !== "object_end") {
      attributes.push(p.process(OBJECT_BUILDER));
    }
    p.shift();
    return {
      type: "Object",
      attributes
    };
  },
  array(p) {
    const elements = [];
    while (p.getMark().name !== "array_end") {
      let isSplat = false;
      if (p.getMark().name === "array_splat") {
        isSplat = true;
        p.shift();
      }
      const value = p.process(EXPR_BUILDER);
      elements.push({
        type: "ArrayElement",
        value,
        isSplat
      });
    }
    p.shift();
    return {
      type: "Array",
      elements
    };
  },
  tuple(p) {
    const members = [];
    while (p.getMark().name !== "tuple_end") {
      members.push(p.process(EXPR_BUILDER));
    }
    p.shift();
    return {
      type: "Tuple",
      members
    };
  },
  func_call(p) {
    let namespace = "global";
    if (p.getMark().name === "namespace") {
      p.shift();
      namespace = p.processString();
    }
    const name = p.processString();
    if (namespace === "global" && name === "select") {
      const result = {
        type: "Select",
        alternatives: []
      };
      while (p.getMark().name !== "func_args_end") {
        if (p.getMark().name === "pair") {
          if (result.fallback)
            throw new GroqQueryError(`unexpected argument to select()`);
          p.shift();
          const condition = p.process(EXPR_BUILDER);
          const value = p.process(EXPR_BUILDER);
          result.alternatives.push({
            type: "SelectAlternative",
            condition,
            value
          });
        } else {
          if (result.fallback)
            throw new GroqQueryError(`unexpected argument to select()`);
          const value = p.process(EXPR_BUILDER);
          result.fallback = value;
        }
      }
      p.shift();
      return result;
    }
    const args = [];
    while (p.getMark().name !== "func_args_end") {
      args.push(p.process(EXPR_BUILDER));
    }
    p.shift();
    if (namespace === "global" && (name === "before" || name === "after")) {
      if (p.parseOptions.mode === "delta") {
        return {
          type: "Context",
          key: name
        };
      }
    }
    if (namespace === "global" && name === "boost" && !p.allowBoost)
      throw new GroqQueryError("unexpected boost");
    const funcs = namespaces[namespace];
    if (!funcs) {
      throw new GroqQueryError(`Undefined namespace: ${namespace}`);
    }
    const func = funcs[name];
    if (!func) {
      throw new GroqQueryError(`Undefined function: ${name}`);
    }
    if (func.arity !== void 0) {
      validateArity(name, func.arity, args.length);
    }
    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {
      throw new GroqQueryError(`Undefined function: ${name}`);
    }
    return {
      type: "FuncCall",
      func,
      name,
      args
    };
  },
  pipecall(p) {
    const base = p.process(EXPR_BUILDER);
    p.shift();
    let namespace = "global";
    if (p.getMark().name === "namespace") {
      p.shift();
      namespace = p.processString();
    }
    if (namespace !== "global") {
      throw new GroqQueryError(`Undefined namespace: ${namespace}`);
    }
    const name = p.processString();
    const args = [];
    const oldAllowBoost = p.allowBoost;
    if (name === "score") {
      p.allowBoost = true;
    }
    for (; ; ) {
      const markName = p.getMark().name;
      if (markName === "func_args_end") {
        break;
      }
      if (name === "order") {
        if (markName === "asc") {
          p.shift();
          args.push({ type: "Asc", base: p.process(EXPR_BUILDER) });
          continue;
        } else if (markName === "desc") {
          p.shift();
          args.push({ type: "Desc", base: p.process(EXPR_BUILDER) });
          continue;
        }
      }
      args.push(p.process(EXPR_BUILDER));
    }
    p.shift();
    p.allowBoost = oldAllowBoost;
    const func = pipeFunctions[name];
    if (!func) {
      throw new GroqQueryError(`Undefined pipe function: ${name}`);
    }
    if (func.arity) {
      validateArity(name, func.arity, args.length);
    }
    return {
      type: "PipeFuncCall",
      func,
      base,
      name,
      args
    };
  },
  pair(p) {
    throw new GroqQueryError(`unexpected =>`);
  },
  and(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "And",
      left,
      right
    };
  },
  or(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "Or",
      left,
      right
    };
  },
  not(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Not",
      base
    };
  },
  asc(p) {
    throw new GroqQueryError("unexpected asc");
  },
  desc(p) {
    throw new GroqQueryError("unexpected desc");
  },
  param(p) {
    const name = p.processString();
    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {
      return {
        type: "Value",
        value: p.parseOptions.params[name]
      };
    }
    return {
      type: "Parameter",
      name
    };
  }
};
const OBJECT_BUILDER = {
  object_expr(p) {
    if (p.getMark().name === "pair") {
      p.shift();
      const condition = p.process(EXPR_BUILDER);
      const value2 = p.process(EXPR_BUILDER);
      return {
        type: "ObjectConditionalSplat",
        condition,
        value: value2
      };
    }
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectAttributeValue",
      name: extractPropertyKey(value),
      value
    };
  },
  object_pair(p) {
    const name = p.process(EXPR_BUILDER);
    if (name.type !== "Value")
      throw new Error("name must be string");
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectAttributeValue",
      name: name.value,
      value
    };
  },
  object_splat(p) {
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectSplat",
      value
    };
  },
  object_splat_this() {
    return {
      type: "ObjectSplat",
      value: { type: "This" }
    };
  }
};
const TRAVERSE_BUILDER = {
  square_bracket(p) {
    const expr = p.process(EXPR_BUILDER);
    const value = tryConstantEvaluate(expr);
    if (value && value.type === "number") {
      return (right) => traverseElement((base) => ({ type: "AccessElement", base, index: value.data }), right);
    }
    if (value && value.type === "string") {
      return (right) => traversePlain((base) => ({ type: "AccessAttribute", base, name: value.data }), right);
    }
    return (right) => traverseArray((base) => ({
      type: "Filter",
      base,
      expr
    }), right);
  },
  slice(p) {
    const isInclusive = p.getMark().name === "inc_range";
    p.shift();
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    const leftValue = tryConstantEvaluate(left);
    const rightValue = tryConstantEvaluate(right);
    if (!leftValue || !rightValue || leftValue.type !== "number" || rightValue.type !== "number") {
      throw new GroqQueryError("slicing must use constant numbers");
    }
    return (rhs) => traverseArray((base) => ({
      type: "Slice",
      base,
      left: leftValue.data,
      right: rightValue.data,
      isInclusive
    }), rhs);
  },
  projection(p) {
    const obj = p.process(EXPR_BUILDER);
    return (right) => traverseProjection((base) => ({ type: "Projection", base, expr: obj }), right);
  },
  attr_access(p) {
    const name = p.processString();
    return (right) => traversePlain((base) => ({ type: "AccessAttribute", base, name }), right);
  },
  deref(p) {
    let attr = null;
    if (p.getMark().name === "deref_attr") {
      p.shift();
      attr = p.processString();
    }
    const wrap = (base) => attr ? { type: "AccessAttribute", base, name: attr } : base;
    return (right) => traversePlain((base) => wrap({
      type: "Deref",
      base
    }), right);
  },
  array_postfix(p) {
    return (right) => traverseArray((base) => ({ type: "ArrayCoerce", base }), right);
  }
};
function extractPropertyKey(node) {
  if (node.type === "AccessAttribute" && !node.base) {
    return node.name;
  }
  if (node.type === "Deref" || node.type === "Map" || node.type === "Projection" || node.type === "Slice" || node.type === "Filter" || node.type === "AccessElement" || node.type === "ArrayCoerce") {
    return extractPropertyKey(node.base);
  }
  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);
}
function validateArity(name, arity, count2) {
  if (typeof arity === "number") {
    if (count2 !== arity) {
      throw new GroqQueryError(`Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count2}.`);
    }
  } else if (arity) {
    if (!arity(count2)) {
      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);
    }
  }
}
class GroqSyntaxError extends Error {
  constructor(position) {
    super(`Syntax error in GROQ query at position ${position}`);
    this.name = "GroqSyntaxError";
    this.position = position;
  }
}
function parse(input, options = {}) {
  const result = parse$1(input);
  if (result.type === "error") {
    throw new GroqSyntaxError(result.position);
  }
  const processor = new MarkProcessor(input, result.marks, options);
  return processor.process(EXPR_BUILDER);
}

//# sourceMappingURL=groq-js.esm.js.map


/***/ }),

/***/ "./node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!*************************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wrap": function() { return /* binding */ wrap; },
/* harmony export */   "unwrap": function() { return /* binding */ unwrap; },
/* harmony export */   "getType": function() { return /* binding */ getType; },
/* harmony export */   "rebaseValue": function() { return /* binding */ rebaseValue; },
/* harmony export */   "applyPatch": function() { return /* binding */ applyPatch; }
/* harmony export */ });
/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ "./node_modules/mendoza/lib/esm/internal-patcher.js");
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ "./node_modules/mendoza/lib/esm/utf8.js");


var Model = /** @class */ (function () {
    function Model(meta) {
        this.meta = meta;
    }
    Model.prototype.wrap = function (data) {
        return this.wrapWithMeta(data, this.meta, this.meta);
    };
    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {
        if (endMeta === void 0) { endMeta = this.meta; }
        return { data: data, startMeta: startMeta, endMeta: endMeta };
    };
    Model.prototype.asObject = function (value) {
        if (!value.content) {
            var fields = {};
            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], val = _b[1];
                fields[key] = this.wrapWithMeta(val, value.startMeta);
            }
            value.content = { type: 'object', fields: fields };
        }
        return value.content;
    };
    Model.prototype.asArray = function (value) {
        var _this = this;
        if (!value.content) {
            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });
            var metas = elements.map(function () { return _this.meta; });
            value.content = { type: 'array', elements: elements, metas: metas };
        }
        return value.content;
    };
    Model.prototype.asString = function (value) {
        if (!value.content) {
            var str = value.data;
            var part = {
                value: str,
                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),
                uses: [],
                startMeta: value.startMeta,
                endMeta: value.endMeta
            };
            value.content = this.stringFromParts([part]);
        }
        return value.content;
    };
    Model.prototype.stringFromParts = function (parts) {
        var str = {
            type: 'string',
            parts: parts
        };
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var part = parts_1[_i];
            part.uses.push(str);
        }
        return str;
    };
    Model.prototype.objectGetKeys = function (value) {
        if (value.content) {
            return Object.keys(value.content.fields);
        }
        else {
            return Object.keys(value.data);
        }
    };
    Model.prototype.objectGetField = function (value, key) {
        var obj = this.asObject(value);
        return obj.fields[key];
    };
    Model.prototype.arrayGetElement = function (value, idx) {
        var arr = this.asArray(value);
        return arr.elements[idx];
    };
    Model.prototype.finalize = function (content) {
        this.updateEndMeta(content);
        return { content: content, startMeta: this.meta, endMeta: this.meta };
    };
    Model.prototype.markChanged = function (value) {
        return this.wrap(unwrap(value));
    };
    Model.prototype.updateEndMeta = function (content) {
        if (content.type == 'string') {
            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {
                var part = _a[_i];
                part.endMeta = this.meta;
            }
        }
        else {
            if (content.type === 'array') {
                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {
                    var val = _c[_b];
                    if (val.content && val.endMeta !== this.meta) {
                        this.updateEndMeta(val.content);
                    }
                    val.endMeta = this.meta;
                }
            }
            else {
                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {
                    var val = _e[_d];
                    if (val.content && val.endMeta !== this.meta) {
                        this.updateEndMeta(val.content);
                    }
                    val.endMeta = this.meta;
                }
            }
        }
    };
    Model.prototype.copyString = function (value) {
        if (value) {
            var other = this.asString(value);
            return this.stringFromParts(other.parts.slice());
        }
        else {
            return {
                type: 'string',
                parts: []
            };
        }
    };
    Model.prototype.copyObject = function (value) {
        var obj = {
            type: 'object',
            fields: {}
        };
        if (value) {
            var other = this.asObject(value);
            Object.assign(obj.fields, other.fields);
        }
        return obj;
    };
    Model.prototype.copyArray = function (value) {
        var arr = value ? this.asArray(value) : null;
        var elements = arr ? arr.elements : [];
        var metas = arr ? arr.metas : [];
        return {
            type: 'array',
            elements: elements,
            metas: metas
        };
    };
    Model.prototype.objectSetField = function (target, key, value) {
        target.fields[key] = value;
    };
    Model.prototype.objectDeleteField = function (target, key) {
        delete target.fields[key];
    };
    Model.prototype.arrayAppendValue = function (target, value) {
        target.elements.push(value);
        target.metas.push(this.meta);
    };
    Model.prototype.arrayAppendSlice = function (target, source, left, right) {
        var _a, _b;
        var arr = this.asArray(source);
        var samePosition = arr.elements.length === left;
        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));
        if (samePosition) {
            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));
        }
        else {
            for (var i = left; i < right; i++) {
                target.metas.push(this.meta);
            }
        }
    };
    Model.prototype.stringAppendValue = function (target, value) {
        var str = this.asString(value);
        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {
            var part = _a[_i];
            this.stringAppendPart(target, part);
        }
    };
    Model.prototype.stringAppendPart = function (target, part) {
        target.parts.push(part);
        part.uses.push(target);
    };
    Model.prototype.resolveStringPart = function (str, from, len) {
        if (len === 0)
            return from;
        for (var i = from; i < str.parts.length; i++) {
            var part = str.parts[i];
            if (len === part.utf8size) {
                // Matches perfect!
                return i + 1;
            }
            if (len < part.utf8size) {
                // It's a part of this chunk. We now need to split it up.
                this.splitString(part, len);
                return i + 1;
            }
            len -= part.utf8size;
        }
        throw new Error('splitting string out of bounds');
    };
    Model.prototype.splitString = function (part, idx) {
        var leftValue;
        var rightValue;
        var leftSize = idx;
        var rightSize = part.utf8size - leftSize;
        // idx is here in UTF-8 index, not codepoint index.
        // This means we might to adjust for multi-byte characters.
        if (part.utf8size !== part.value.length) {
            var byteCount = 0;
            for (idx = 0; byteCount < leftSize; idx++) {
                var code = part.value.codePointAt(idx);
                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);
                if (size === 4)
                    idx++; // Surrogate pair.
                byteCount += size;
            }
        }
        leftValue = part.value.slice(0, idx);
        rightValue = part.value.slice(idx);
        var newPart = {
            value: rightValue,
            utf8size: rightSize,
            uses: part.uses.slice(),
            startMeta: part.startMeta,
            endMeta: part.endMeta
        };
        part.value = leftValue;
        part.utf8size = leftSize;
        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {
            var use = _a[_i];
            // Insert the new part.
            var idx_1 = use.parts.indexOf(part);
            if (idx_1 === -1)
                throw new Error('bug: mismatch between string parts and use.');
            use.parts.splice(idx_1 + 1, 0, newPart);
        }
    };
    Model.prototype.stringAppendSlice = function (target, source, left, right) {
        var str = this.asString(source);
        var firstPart = this.resolveStringPart(str, 0, left);
        var lastPart = this.resolveStringPart(str, firstPart, right - left);
        for (var i = firstPart; i < lastPart; i++) {
            var part = str.parts[i];
            this.stringAppendPart(target, part);
        }
    };
    return Model;
}());
// Turns a native JavaScript object into a Value with a given origin.
function wrap(data, meta) {
    return { data: data, startMeta: meta, endMeta: meta };
}
// Converts a Value into a native JavaScript type.
function unwrap(value) {
    if (typeof value.data !== 'undefined')
        return value.data;
    var result;
    var content = value.content;
    switch (content.type) {
        case 'string':
            result = content.parts.map(function (part) { return part.value; }).join('');
            break;
        case 'array':
            result = content.elements.map(function (val) { return unwrap(val); });
            break;
        case 'object': {
            result = {};
            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], val = _b[1];
                result[key] = unwrap(val);
            }
        }
    }
    value.data = result;
    return result;
}
// Returns the type of a Value.
function getType(value) {
    if (value.content)
        return value.content.type;
    if (Array.isArray(value.data))
        return 'array';
    if (value.data === null)
        return 'null';
    return typeof value.data;
}
// Updates the `right` value such that it reuses as much as possible from the `left` value.
function rebaseValue(left, right) {
    var leftType = getType(left);
    var rightType = getType(right);
    if (leftType !== rightType)
        return right;
    var leftModel = new Model(left.endMeta);
    var rightModel = new Model(right.endMeta);
    switch (leftType) {
        case 'object': {
            var leftObj = leftModel.asObject(left);
            var rightObj = rightModel.asObject(right);
            // Number of fields which are identical in left and right.
            var identicalFieldCount = 0;
            var leftFieldCount = Object.keys(leftObj.fields).length;
            var rightFieldCount = Object.keys(rightObj.fields).length;
            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], rightVal = _b[1];
                var leftVal = leftObj.fields[key];
                if (leftVal) {
                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);
                    if (rightObj.fields[key] === leftVal) {
                        identicalFieldCount++;
                    }
                }
            }
            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;
            return isIdentical ? left : right;
        }
        case 'array': {
            var leftArr = leftModel.asArray(left);
            var rightArr = rightModel.asArray(right);
            if (leftArr.elements.length !== rightArr.elements.length) {
                break;
            }
            var numRebased = 0;
            for (var i = 0; i < rightArr.elements.length; i++) {
                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);
                if (rightArr.elements[i] !== leftArr.elements[i]) {
                    numRebased++;
                }
            }
            return numRebased === 0 ? left : right;
        }
        case 'null':
        case 'boolean':
        case 'number': {
            if (unwrap(left) === unwrap(right))
                return left;
            break;
        }
        case 'string': {
            var leftRaw = unwrap(left);
            var rightRaw = unwrap(right);
            if (leftRaw === rightRaw)
                return left;
            var result = rightModel.copyString(null);
            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);
            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);
            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);
            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);
            if (0 < prefix) {
                rightModel.stringAppendSlice(result, left, 0, prefix);
            }
            if (prefix < rightLen - suffix) {
                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);
            }
            if (leftLen - suffix < leftLen) {
                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);
            }
            var value = rightModel.finalize(result);
            if (unwrap(value) !== rightRaw)
                throw new Error('incorrect string rebase');
            return value;
        }
    }
    return right;
}
function applyPatch(left, patch, startMeta) {
    var model = new Model(startMeta);
    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);
    return patcher.process();
}
//# sourceMappingURL=incremental-patcher.js.map

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "incremental": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; },
/* harmony export */   "applyPatch": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; }
/* harmony export */ });
/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ "./node_modules/mendoza/lib/esm/incremental-patcher.js");
/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ "./node_modules/mendoza/lib/esm/simple-patcher.js");



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/internal-patcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Patcher": function() { return /* binding */ Patcher; }
/* harmony export */ });
var OPS = [
    'Value',
    'Copy',
    'Blank',
    'ReturnIntoArray',
    'ReturnIntoObject',
    'ReturnIntoObjectSameKey',
    'PushField',
    'PushElement',
    'PushParent',
    'Pop',
    'PushFieldCopy',
    'PushFieldBlank',
    'PushElementCopy',
    'PushElementBlank',
    'ReturnIntoObjectPop',
    'ReturnIntoObjectSameKeyPop',
    'ReturnIntoArrayPop',
    'ObjectSetFieldValue',
    'ObjectCopyField',
    'ObjectDeleteField',
    'ArrayAppendValue',
    'ArrayAppendSlice',
    'StringAppendString',
    'StringAppendSlice'
];
var Patcher = /** @class */ (function () {
    function Patcher(model, root, patch) {
        this.i = 0;
        this.inputStack = [];
        this.outputStack = [];
        this.model = model;
        this.root = root;
        this.patch = patch;
    }
    Patcher.prototype.read = function () {
        return this.patch[this.i++];
    };
    Patcher.prototype.process = function () {
        this.inputStack.push({ value: this.root });
        this.outputStack.push({ value: this.root });
        for (; this.i < this.patch.length;) {
            var opcode = this.read();
            var op = OPS[opcode];
            if (!op)
                throw new Error("Unknown opcode: " + opcode);
            var processor = "process" + op;
            this[processor].apply(this);
        }
        var entry = this.outputStack.pop();
        return this.finalizeOutput(entry);
    };
    Patcher.prototype.inputEntry = function () {
        return this.inputStack[this.inputStack.length - 1];
    };
    Patcher.prototype.inputKey = function (entry, idx) {
        if (!entry.keys) {
            entry.keys = this.model.objectGetKeys(entry.value).sort();
        }
        return entry.keys[idx];
    };
    Patcher.prototype.outputEntry = function () {
        return this.outputStack[this.outputStack.length - 1];
    };
    Patcher.prototype.outputArray = function () {
        var entry = this.outputEntry();
        if (!entry.writeValue) {
            entry.writeValue = this.model.copyArray(entry.value);
        }
        return entry.writeValue;
    };
    Patcher.prototype.outputObject = function () {
        var entry = this.outputEntry();
        if (!entry.writeValue) {
            entry.writeValue = this.model.copyObject(entry.value);
        }
        return entry.writeValue;
    };
    Patcher.prototype.outputString = function () {
        var entry = this.outputEntry();
        if (!entry.writeValue) {
            entry.writeValue = this.model.copyString(entry.value);
        }
        return entry.writeValue;
    };
    Patcher.prototype.finalizeOutput = function (entry) {
        if (entry.writeValue) {
            return this.model.finalize(entry.writeValue);
        }
        else {
            return entry.value;
        }
    };
    // Processors:
    Patcher.prototype.processValue = function () {
        var value = this.model.wrap(this.read());
        this.outputStack.push({ value: value });
    };
    Patcher.prototype.processCopy = function () {
        var input = this.inputEntry();
        this.outputStack.push({ value: input.value });
    };
    Patcher.prototype.processBlank = function () {
        this.outputStack.push({ value: null });
    };
    Patcher.prototype.processReturnIntoArray = function () {
        var entry = this.outputStack.pop();
        var result = this.finalizeOutput(entry);
        var arr = this.outputArray();
        this.model.arrayAppendValue(arr, result);
    };
    Patcher.prototype.processReturnIntoObject = function () {
        var key = this.read();
        var entry = this.outputStack.pop();
        var result = this.finalizeOutput(entry);
        result = this.model.markChanged(result);
        var obj = this.outputObject();
        this.model.objectSetField(obj, key, result);
    };
    Patcher.prototype.processReturnIntoObjectSameKey = function () {
        var input = this.inputEntry();
        var entry = this.outputStack.pop();
        var result = this.finalizeOutput(entry);
        var obj = this.outputObject();
        this.model.objectSetField(obj, input.key, result);
    };
    Patcher.prototype.processPushField = function () {
        var idx = this.read();
        var entry = this.inputEntry();
        var key = this.inputKey(entry, idx);
        var value = this.model.objectGetField(entry.value, key);
        this.inputStack.push({ value: value, key: key });
    };
    Patcher.prototype.processPushElement = function () {
        var idx = this.read();
        var entry = this.inputEntry();
        var value = this.model.arrayGetElement(entry.value, idx);
        this.inputStack.push({ value: value });
    };
    Patcher.prototype.processPop = function () {
        this.inputStack.pop();
    };
    Patcher.prototype.processPushFieldCopy = function () {
        this.processPushField();
        this.processCopy();
    };
    Patcher.prototype.processPushFieldBlank = function () {
        this.processPushField();
        this.processBlank();
    };
    Patcher.prototype.processPushElementCopy = function () {
        this.processPushElement();
        this.processCopy();
    };
    Patcher.prototype.processPushElementBlank = function () {
        this.processPushElement();
        this.processBlank();
    };
    Patcher.prototype.processReturnIntoObjectPop = function () {
        this.processReturnIntoObject();
        this.processPop();
    };
    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {
        this.processReturnIntoObjectSameKey();
        this.processPop();
    };
    Patcher.prototype.processReturnIntoArrayPop = function () {
        this.processReturnIntoArray();
        this.processPop();
    };
    Patcher.prototype.processObjectSetFieldValue = function () {
        this.processValue();
        this.processReturnIntoObject();
    };
    Patcher.prototype.processObjectCopyField = function () {
        this.processPushField();
        this.processCopy();
        this.processReturnIntoObjectSameKey();
        this.processPop();
    };
    Patcher.prototype.processObjectDeleteField = function () {
        var idx = this.read();
        var entry = this.inputEntry();
        var key = this.inputKey(entry, idx);
        var obj = this.outputObject();
        this.model.objectDeleteField(obj, key);
    };
    Patcher.prototype.processArrayAppendValue = function () {
        var value = this.model.wrap(this.read());
        var arr = this.outputArray();
        this.model.arrayAppendValue(arr, value);
    };
    Patcher.prototype.processArrayAppendSlice = function () {
        var left = this.read();
        var right = this.read();
        var str = this.outputArray();
        var val = this.inputEntry().value;
        this.model.arrayAppendSlice(str, val, left, right);
    };
    Patcher.prototype.processStringAppendString = function () {
        var value = this.model.wrap(this.read());
        var str = this.outputString();
        this.model.stringAppendValue(str, value);
    };
    Patcher.prototype.processStringAppendSlice = function () {
        var left = this.read();
        var right = this.read();
        var str = this.outputString();
        var val = this.inputEntry().value;
        this.model.stringAppendSlice(str, val, left, right);
    };
    return Patcher;
}());

//# sourceMappingURL=internal-patcher.js.map

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/simple-patcher.js":
/*!********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPatch": function() { return /* binding */ applyPatch; }
/* harmony export */ });
/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ "./node_modules/mendoza/lib/esm/internal-patcher.js");
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ "./node_modules/mendoza/lib/esm/utf8.js");


var Model = {
    wrap: function (data) {
        return data;
    },
    finalize: function (b) {
        if (Array.isArray(b)) {
            return b;
        }
        else {
            return b.data;
        }
    },
    markChanged: function (value) {
        return value;
    },
    objectGetKeys: function (value) {
        return Object.keys(value);
    },
    objectGetField: function (value, key) {
        return value[key];
    },
    arrayGetElement: function (value, idx) {
        return value[idx];
    },
    copyObject: function (value) {
        var res = {
            type: 'object',
            data: {}
        };
        if (value !== null) {
            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], val = _b[1];
                res.data[key] = val;
            }
        }
        return res;
    },
    copyArray: function (value) {
        if (value === null)
            return [];
        return value.slice();
    },
    copyString: function (value) {
        return {
            type: 'string',
            data: value === null ? '' : value
        };
    },
    objectSetField: function (target, key, value) {
        target.data[key] = value;
    },
    objectDeleteField: function (target, key) {
        delete target.data[key];
    },
    arrayAppendValue: function (target, value) {
        target.push(value);
    },
    arrayAppendSlice: function (target, source, left, right) {
        target.push.apply(target, source.slice(left, right));
    },
    stringAppendSlice: function (target, source, left, right) {
        var sourceString = source;
        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);
        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);
        target.data += sourceString.slice(leftPos, rightPos);
    },
    stringAppendValue: function (target, value) {
        target.data += value;
    }
};
// Applies a patch on a JavaScript object.
function applyPatch(left, patch) {
    var root = left; // No need to wrap because the representation is the same.
    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);
    return patcher.process();
}
//# sourceMappingURL=simple-patcher.js.map

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/utf8.js":
/*!**********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/utf8.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utf8charSize": function() { return /* binding */ utf8charSize; },
/* harmony export */   "utf8stringSize": function() { return /* binding */ utf8stringSize; },
/* harmony export */   "utf8resolveIndex": function() { return /* binding */ utf8resolveIndex; },
/* harmony export */   "commonPrefix": function() { return /* binding */ commonPrefix; },
/* harmony export */   "commonSuffix": function() { return /* binding */ commonSuffix; }
/* harmony export */ });
function utf8charSize(code) {
    if (code >> 16) {
        return 4;
    }
    else if (code >> 11) {
        return 3;
    }
    else if (code >> 7) {
        return 2;
    }
    else {
        return 1;
    }
}
function utf8stringSize(str) {
    var b = 0;
    for (var i = 0; i < str.length; i++) {
        var code = str.codePointAt(i);
        var size = utf8charSize(code);
        if (size == 4)
            i++;
        b += size;
    }
    return b;
}
/** Converts an UTF-8 byte index into a UCS-2 index. */
function utf8resolveIndex(str, idx, start) {
    if (start === void 0) { start = 0; }
    var byteCount = start;
    var ucsIdx = 0;
    for (ucsIdx = start; byteCount < idx; ucsIdx++) {
        var code = str.codePointAt(ucsIdx);
        var size = utf8charSize(code);
        if (size === 4)
            ucsIdx++; // Surrogate pair.
        byteCount += size;
    }
    return ucsIdx;
}
function commonPrefix(str, str2) {
    var len = Math.min(str.length, str2.length);
    var b = 0;
    for (var i = 0; i < len;) {
        var aPoint = str.codePointAt(i);
        var bPoint = str2.codePointAt(i);
        if (aPoint !== bPoint)
            return b;
        var size = utf8charSize(aPoint);
        b += size;
        i += size === 4 ? 2 : 1;
    }
    return b;
}
function commonSuffix(str, str2, prefix) {
    if (prefix === void 0) { prefix = 0; }
    var len = Math.min(str.length, str2.length) - prefix;
    var b = 0;
    for (var i = 0; i < len;) {
        var aPoint = str.codePointAt(str.length - 1 - i);
        var bPoint = str2.codePointAt(str2.length - 1 - i);
        if (aPoint !== bPoint)
            return b;
        var size = utf8charSize(aPoint);
        b += size;
        i += size === 4 ? 2 : 1;
    }
    return b;
}
//# sourceMappingURL=utf8.js.map

/***/ }),

/***/ "./node_modules/throttle-debounce/cjs/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/throttle-debounce/cjs/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset).
 * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function}  A new, throttled, function.
 */
function throttle (delay, noTrailing, callback, debounceMode) {
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */
  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  } // `noTrailing` defaults to falsy.


  if (typeof noTrailing !== 'boolean') {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = undefined;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      /*
       * In throttle mode, if `delay` time has been exceeded, execute
       * `callback`.
       */
      exec();
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

/* eslint-disable no-undefined */
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @returns {Function} A new, debounced function.
 */

function debounce (delay, atBegin, callback) {
  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
}

exports.debounce = debounce;
exports.throttle = throttle;
//# sourceMappingURL=index.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9kaXN0L2Jyb3dzZXIvZ3JvcS1zdG9yZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC9ncm9xLWpzLmVzbS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbmNyZW1lbnRhbC1wYXRjaGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vc2ltcGxlLXBhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vdXRmOC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm90dGxlLWRlYm91bmNlL2Nqcy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGNBQWMsd0RBQXdELFFBQVEsbUJBQU8sQ0FBQyw2Q0FBTSxPQUFPLG1CQUFPLENBQUMsZ0VBQWlCLEtBQUssbUJBQU8sQ0FBQyx3RUFBbUIsSUFBSSxtQkFBTyxDQUFDLDJEQUFTLElBQUksbUJBQU8sQ0FBQyx3REFBUyxFQUFFLGFBQWEsb0NBQW9DLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHdCQUF3QixrQkFBa0IsMkhBQTJILDhCQUE4QiwwQkFBMEIsUUFBUSxFQUFFLG1HQUFtRyxNQUFNLElBQUkscUJBQXFCLFNBQVMsT0FBTyxLQUFLLG9E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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRztBQUN0QyxnREFBZ0QsR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFvRDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlLHFCQUFxQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQsT0FBTztBQUNQLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0NBQXdDO0FBQzVEO0FBQ0E7QUFDQSxrQkFBa0IscUNBQXFDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQ0FBbUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0NBQW9DO0FBQy9DLFdBQVcsd0NBQXdDO0FBQ25ELFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0NBQXdDO0FBQ3ZELGVBQWUsb0NBQW9DO0FBQ25ELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1Q0FBdUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1Q0FBdUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFLDBCQUEwQixpQ0FBaUMsR0FBRyx5Q0FBeUM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtDQUFrQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1DQUFtQztBQUM1RCxzQkFBc0IsaUNBQWlDLEdBQUcsb0NBQW9DO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlDQUFpQztBQUM1RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0NBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQsc0JBQXNCLGlDQUFpQyxHQUFHLHlDQUF5QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUNBQXVDO0FBQ3RFLHNDQUFzQyxpQ0FBaUM7QUFDdkU7QUFDQSxlQUFlO0FBQ2YsK0JBQStCLG1DQUFtQztBQUNsRSw0QkFBNEIsaUNBQWlDLEdBQUcseUNBQXlDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEUsMEJBQTBCLGlDQUFpQyxHQUFHLHlDQUF5QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUEwQztBQUNyRCxXQUFXLHNDQUFzQztBQUNqRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5Q0FBeUMsR0FBRyxvQ0FBb0MsR0FBRyxtQ0FBbUM7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9DQUFvQztBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsaUJBQWlCLDZDQUE2QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlDQUF5QztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3Q0FBd0M7QUFDdEQ7QUFDQSxnQkFBZ0Isd0NBQXdDO0FBQ3hELGdCQUFnQixvQ0FBb0MsR0FBRyxtQ0FBbUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQiwrQkFBK0IsR0FBRyw2Q0FBNkM7QUFDL0Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEdBQUc7QUFDSCxnQkFBZ0Isb0NBQW9DLEdBQUcsbUNBQW1DO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsY0FBYywyQ0FBMkM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMENBQTBDO0FBQzlEO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0EsT0FBTztBQUNQLDhCQUE4QixxQ0FBcUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQSxVQUFVLEVBQUU7QUFDWjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQ7QUFDQSxtQ0FBbUM7QUFDbkMsMEJBQTBCLHlDQUF5QztBQUNuRSxrQ0FBa0M7QUFDbEMsMEJBQTBCLHlDQUF5QztBQUNuRTtBQUNBLGFBQWE7QUFDYiwwQkFBMEIseUNBQXlDO0FBQ25FLDBCQUEwQiw2Q0FBNkM7QUFDdkU7QUFDQTtBQUNBLFdBQVc7QUFDWCx3QkFBd0IsMkNBQTJDO0FBQ25FO0FBQ0E7QUFDQSxzQkFBc0IsdUNBQXVDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQ0FBaUMsZUFBZSxHQUFHO0FBQ3hFO0FBQ0E7QUFDQSxxQkFBcUIscUNBQXFDLGVBQWUsR0FBRztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsR0FBRztBQUNILFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hELEdBQUc7QUFDSCxVQUFVLElBQUk7QUFDZDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0EsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGFBQWE7QUFDekI7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyxRQUFRO0FBQ2pCO0FBQ0EsR0FBRztBQUNILFNBQVMsT0FBTztBQUNoQjtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLFdBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNILGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQixvRUFBb0U7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsVUFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFVBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEVBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2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QUNBOzs7QUFHQTtBQUNBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQiIsImZpbGUiOiJzdGF0aWMvY2h1bmtzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3Nhbml0eV9ncm9xLXN0b3JlX2Rpc3RfYnJvd3Nlcl9ncm9xLXN0b3JlX2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZShlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZX12YXIgcj1lKHJlcXVpcmUoXCJncm9xXCIpKSx0PWUocmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKSksbj1yZXF1aXJlKFwidGhyb3R0bGUtZGVib3VuY2VcIiksbz1yZXF1aXJlKFwiZ3JvcS1qc1wiKSxpPXJlcXVpcmUoXCJtZW5kb3phXCIpO2Z1bmN0aW9uIHUoKXtyZXR1cm4odT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt2YXIgdD1hcmd1bWVudHNbcl07Zm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pfXJldHVybiBlfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIHMoZSxyLHQpe3ZhciBuLG89ci50b2tlbixpPW5ldyBlKFwiaHR0cHM6Ly9cIityLnByb2plY3RJZCtcIi5hcGkuc2FuaXR5LmlvL3YxL2RhdGEvbGlzdGVuL1wiK3IuZGF0YXNldCtcIj9xdWVyeT0qJmVmZmVjdEZvcm1hdD1tZW5kb3phXCIse3dpdGhDcmVkZW50aWFsczohMCxoZWFkZXJzOm8/e0F1dGhvcml6YXRpb246XCJCZWFyZXIgXCIrb306dm9pZCAwfSk7cmV0dXJuIGkuYWRkRXZlbnRMaXN0ZW5lcihcIndlbGNvbWVcIix0Lm9wZW4sITEpLGkuYWRkRXZlbnRMaXN0ZW5lcihcIm11dGF0aW9uXCIsKG49dC5uZXh0LGZ1bmN0aW9uKGUpe3ZhciByO3RyeXtyPUpTT04ucGFyc2UoZS5kYXRhKX1jYXRjaChlKXtyZXR1cm59bihyKX0pLCExKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFubmVsRXJyb3JcIixmdW5jdGlvbihlKXt2YXIgcjtpLmNsb3NlKCk7dHJ5e3I9SlNPTi5wYXJzZShlLmRhdGEpfWNhdGNoKGUpe3JldHVybiB2b2lkIHQuZXJyb3IobmV3IEVycm9yKFwiVW5rbm93biBlcnJvciBwYXJzaW5nIGxpc3RlbmVyIG1lc3NhZ2VcIikpfXQuZXJyb3IobmV3IEVycm9yKHIubWVzc2FnZXx8ci5lcnJvcnx8XCJMaXN0ZW5lciByZXR1cm5lZCBIVFRQIFwiK3Iuc3RhdHVzQ29kZSkpfSwhMSksaS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbihlKXt2YXIgcj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24ub3JpZ2luLG49cj9cIiwgYW5kIHRoYXQgdGhlIENPUlMtb3JpZ2luIChcIityK1wiKSBpcyBhbGxvd2VkXCI6XCJcIixvPWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJtZXNzYWdlXCJpbiBlfShlKT9cIiAoXCIrZS5tZXNzYWdlK1wiKVwiOlwiXCI7dC5lcnJvcihuZXcgRXJyb3IoXCJFcnJvciBlc3RhYmxpc2hpbmcgbGlzdGVuZXIgLSBjaGVjayB0aGF0IHRoZSBwcm9qZWN0IElEIGFuZCBkYXRhc2V0IGFyZSBjb3JyZWN0XCIrbitvKSl9LCExKSx7dW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGkuY2xvc2UoKSl9fX1mdW5jdGlvbiBjKGUpe3JldHVybiBlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9lLl9pZC5zbGljZSg3KTplLl9pZH1mdW5jdGlvbiBhKGUscil7dmFyIHQ9dSh7fSxlKTtyZXR1cm4gZGVsZXRlIHQuX3JldixpLmFwcGx5UGF0Y2godCxyKX1mdW5jdGlvbiBmKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIGQoKXt2YXIgZSxyLHQ9KGU9W1wiKltfaWQgPT0gJGlkXVswXVwiXSxyfHwocj1lLnNsaWNlKDApKSxlLnJhdz1yLGUpO3JldHVybiBkPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gdihlLHIsdCl7aWYoIWUucyl7aWYodCBpbnN0YW5jZW9mIGwpe2lmKCF0LnMpcmV0dXJuIHZvaWQodC5vPXYuYmluZChudWxsLGUscikpOzEmciYmKHI9dC5zKSx0PXQudn1pZih0JiZ0LnRoZW4pcmV0dXJuIHZvaWQgdC50aGVuKHYuYmluZChudWxsLGUsciksdi5iaW5kKG51bGwsZSwyKSk7ZS5zPXIsZS52PXQ7dmFyIG49ZS5vO24mJm4oZSl9fXZhciBsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihyLHQpe3ZhciBuPW5ldyBlLG89dGhpcy5zO2lmKG8pe3ZhciBpPTEmbz9yOnQ7aWYoaSl7dHJ5e3YobiwxLGkodGhpcy52KSl9Y2F0Y2goZSl7dihuLDIsZSl9cmV0dXJuIG59cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMubz1mdW5jdGlvbihlKXt0cnl7dmFyIG89ZS52OzEmZS5zP3YobiwxLHI/cihvKTpvKTp0P3YobiwxLHQobykpOnYobiwyLG8pfWNhdGNoKGUpe3YobiwyLGUpfX0sbn0sZX0oKTtmdW5jdGlvbiBoKGUpe3JldHVybiBlIGluc3RhbmNlb2YgbCYmMSZlLnN9dmFyIG09ZnVuY3Rpb24oZSl7dmFyIHI9ZS5wcm9qZWN0SWQsdD1lLmRhdGFzZXQsbj1lLnRva2VuLG89ZS5kb2N1bWVudExpbWl0O3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZldGNoKFwiaHR0cHM6Ly9cIityK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9leHBvcnQvXCIrdCx7Y3JlZGVudGlhbHM6XCJpbmNsdWRlXCIsaGVhZGVyczpuP3tBdXRob3JpemF0aW9uOlwiQmVhcmVyIFwiK259OnZvaWQgMH0pKS50aGVuKGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIocil7dmFyIHQsbixpPWZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZWFkIGJvZHkgZnJvbSByZXNwb25zZVwiKTt2YXIgcix0PSExO2Z1bmN0aW9uIG4oKXt0PSEwLHImJnIuY2FuY2VsKCl9cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7c3RhcnQ6ZnVuY3Rpb24obyl7cj1lLmdldFJlYWRlcigpO3ZhciBpPW5ldyBUZXh0RGVjb2Rlcix1PVwiXCI7ci5yZWFkKCkudGhlbihmdW5jdGlvbiBlKHMpe3RyeXtpZihzLmRvbmUpcmV0dXJuIHQ/UHJvbWlzZS5yZXNvbHZlKCk6MD09PSh1PXUudHJpbSgpKS5sZW5ndGg/KG8uY2xvc2UoKSxQcm9taXNlLnJlc29sdmUoKSk6KG8uZW5xdWV1ZShKU09OLnBhcnNlKHUpKSxvLmNsb3NlKCksUHJvbWlzZS5yZXNvbHZlKCkpO2Zvcih2YXIgYz0odSs9aS5kZWNvZGUocy52YWx1ZSx7c3RyZWFtOiEwfSkpLnNwbGl0KFwiXFxuXCIpLGE9MDthPGMubGVuZ3RoLTE7KythKXt2YXIgZj1jW2FdLnRyaW0oKTtpZigwPT09Zi5sZW5ndGgpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO3RyeXtvLmVucXVldWUoSlNPTi5wYXJzZShmKSl9Y2F0Y2goZSl7cmV0dXJuIG8uZXJyb3IoZSksbigpLFByb21pc2UucmVzb2x2ZSgpfX1pZih1PWNbYy5sZW5ndGgtMV0sIXIpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO3ZhciBkPWZ1bmN0aW9uKHQsbil7dHJ5e3ZhciBvPVByb21pc2UucmVzb2x2ZShyLnJlYWQoKSkudGhlbihmdW5jdGlvbihyKXtlKHIpfSl9Y2F0Y2goZSl7cmV0dXJuIG4oZSl9cmV0dXJuIG8mJm8udGhlbj9vLnRoZW4odm9pZCAwLG4pOm99KDAsZnVuY3Rpb24oZSl7by5lcnJvcihlKX0pO3JldHVybiBQcm9taXNlLnJlc29sdmUoZCYmZC50aGVuP2QudGhlbihmdW5jdGlvbigpe30pOnZvaWQgMCl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0pLmNhdGNoKGZ1bmN0aW9uKGUpe3JldHVybiBvLmVycm9yKGUpfSl9LGNhbmNlbDpufSl9KGUuYm9keSkuZ2V0UmVhZGVyKCksdT1bXSxzPWZ1bmN0aW9uKGUscil7dmFyIHQ7ZG97dmFyIG49ZSgpO2lmKG4mJm4udGhlbil7aWYoIWgobikpe3Q9ITA7YnJlYWt9bj1uLnZ9dmFyIG89cigpO2lmKGgobykmJihvPW8udiksIW8pcmV0dXJuIG59d2hpbGUoIW8udGhlbik7dmFyIGk9bmV3IGwsdT12LmJpbmQobnVsbCxpLDIpO3JldHVybih0P24udGhlbihzKTpvLnRoZW4oYykpLnRoZW4odm9pZCAwLHUpLGk7ZnVuY3Rpb24gcyh0KXtmb3Iobj10O2gobz1yKCkpJiYobz1vLnYpLG87KXtpZihvLnRoZW4pcmV0dXJuIHZvaWQgby50aGVuKGMpLnRoZW4odm9pZCAwLHUpO2lmKChuPWUoKSkmJm4udGhlbil7aWYoIWgobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fX12KGksMSxuKX1mdW5jdGlvbiBjKHQpe2lmKHQpe2Rve2lmKChuPWUoKSkmJm4udGhlbil7aWYoIWgobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fWlmKGgodD1yKCkpJiYodD10LnYpLCF0KXJldHVybiB2b2lkIHYoaSwxLG4pfXdoaWxlKCF0LnRoZW4pO3QudGhlbihjKS50aGVuKHZvaWQgMCx1KX1lbHNlIHYoaSwxLG4pfX0oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGkucmVhZCgpKS50aGVuKGZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKGUpe3JldHVybiEhZSYmXCJlcnJvclwiaW4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUuZXJyb3ImJm51bGwhPT1lLmVycm9yJiZcImRlc2NyaXB0aW9uXCJpbiBlLmVycm9yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5lcnJvci5kZXNjcmlwdGlvbiYmIShcIl9pZFwiaW4gZSl9KG49KHQ9ZSkudmFsdWUpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHN0cmVhbWluZyBkYXRhc2V0OiBcIituLmVycm9yKTtpZihuJiYhbi5faWQuc3RhcnRzV2l0aChcIl8uXCIpJiZ1LnB1c2gobiksbyYmdS5sZW5ndGg+byl0aHJvdyBpLmNhbmNlbChcIlJlYWNoZWQgZG9jdW1lbnQgbGltaXRcIiksbmV3IEVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6IFJlYWNoZWQgbGltaXQgb2YgXCIrbytcIiBkb2N1bWVudHNcIil9KX0sZnVuY3Rpb24oKXtyZXR1cm4hdC5kb25lfSk7cmV0dXJuIHMmJnMudGhlbj9zLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHV9KTp1fXZhciB0PWZ1bmN0aW9uKCl7aWYoMjAwIT09ZS5zdGF0dXMpcmV0dXJuIFByb21pc2UucmVzb2x2ZShlLmpzb24oKSkudGhlbihmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogXCIrKFwib2JqZWN0XCI9PXR5cGVvZihyPWUpJiZcImVycm9yXCJpbiByJiZcIm1lc3NhZ2VcImluIHI/ci5tZXNzYWdlfHxyLmVycm9yOlwiPHVua25vd24gZXJyb3I+XCIpKTt2YXIgcn0pfSgpO3JldHVybiB0JiZ0LnRoZW4/dC50aGVuKHIpOnIoKX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19O2V4cG9ydHMuZ3JvcT1yLGV4cG9ydHMuZ3JvcVN0b3JlPWZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKCl7dmFyIGU9W1wiRXZlbnRTb3VyY2VcIixcIlJlYWRhYmxlU3RyZWFtXCIsXCJmZXRjaFwiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIShlIGluIHdpbmRvdyl9KTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgbm90IHN1cHBvcnRlZC4gTWlzc2luZyBicm93c2VyIEFQSXM6IFwiK2Uuam9pbihcIiwgXCIpKX0oKSxlLnRva2VuKXRocm93IG5ldyBFcnJvcihcImB0b2tlbmAgb3B0aW9uIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIGJyb3dzZXJcIik7cmV0dXJuIGZ1bmN0aW9uKGUsaSl7dmFyIHYsbD1mdW5jdGlvbihlLHIpe3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGgoKSkudGhlbihmdW5jdGlvbigpe3ZhciB0PW8ucGFyc2UoZSx7cGFyYW1zOnJ9KTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG8uZXZhbHVhdGUodCx7ZGF0YXNldDptLHBhcmFtczpyfSkpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0KCl9KX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19LGg9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIHZ8fCh2PWZ1bmN0aW9uKGUscix0KXt2YXIgbj10LmdldERvY3VtZW50cyxvPXQuRXZlbnRTb3VyY2UsaT1lLnByb2plY3RJZCxkPWUuZGF0YXNldCx2PWUub3ZlcmxheURyYWZ0cyxsPWUuZG9jdW1lbnRMaW1pdDtpZighZS5saXN0ZW4pcmV0dXJue3Vuc3Vic2NyaWJlOmYsbG9hZGVkOm4oe3Byb2plY3RJZDppLGRhdGFzZXQ6ZCxkb2N1bWVudExpbWl0Omx9KS50aGVuKGopLnRoZW4oZil9O3ZhciBoLG0scCx3LGIsZyx5PW5ldyBNYXAsUD1bXSxFPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGUscil7bT1lLHA9cn0pO3JldHVybnt1bnN1YnNjcmliZTpzKG8sZSx7bmV4dDpmdW5jdGlvbihlKXtoPyhmdW5jdGlvbihlKXtpZihlLmVmZmVjdHMmJiFlLmRvY3VtZW50SWQuc3RhcnRzV2l0aChcIl8uXCIpKXt2YXIgcj15LmdldChlLmRvY3VtZW50SWQpfHxudWxsOyFmdW5jdGlvbihlLHIpe3ZhciB0PXkuZ2V0KGUpLG49aHx8W10sbz10P24uaW5kZXhPZih0KTotMTstMT09PW8mJnI/KG4ucHVzaChyKSx5LnNldChlLHIpKTpyPyhuLnNwbGljZShvLDEscikseS5zZXQoZSxyKSk6KG4uc3BsaWNlKG8sMSkseS5kZWxldGUoZSkpfShlLmRvY3VtZW50SWQsYShyLGUuZWZmZWN0cy5hcHBseSkpfX0oZSksZnVuY3Rpb24oZSxyKXtjbGVhclRpbWVvdXQoZyksYiE9PXIudHJhbnNhY3Rpb25JZCYmdz8oaih3KSxiPXZvaWQgMCk6KGI9ci50cmFuc2FjdGlvbklkLHc9ZS5zbGljZSgpKSxnPXNldFRpbWVvdXQoaiwyNSxlLnNsaWNlKCkpfShoLGUpKTpQLnB1c2goZSl9LG9wZW46ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShuKHtwcm9qZWN0SWQ6aSxkYXRhc2V0OmQsZG9jdW1lbnRMaW1pdDpsfSkpLnRoZW4oZnVuY3Rpb24oZSl7KGg9ZnVuY3Rpb24oZSxyKXt2YXIgdD1uZXcgTWFwO3JldHVybiByLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHI9dC5nZXQoZS5kb2N1bWVudElkKXx8W107ci5wdXNoKGUpLHQuc2V0KGUuZG9jdW1lbnRJZCxyKX0pLHQuZm9yRWFjaChmdW5jdGlvbihyLHQpe3ZhciBuPWUuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5faWQ9PT10fSk7aWYobil7dmFyIG89ITEsaT1uO3IuZm9yRWFjaChmdW5jdGlvbihlKXsobz1vfHxlLnByZXZpb3VzUmV2PT09bi5fcmV2KSYmZS5lZmZlY3RzJiYoaT1hKGksZS5lZmZlY3RzLmFwcGx5KSl9KSxlLnNwbGljZShlLmluZGV4T2YobiksMSxpKX1lbHNlIGNvbnNvbGUud2FybihcIlJlY2VpdmVkIG11dGF0aW9uIGZvciBtaXNzaW5nIGRvY3VtZW50ICVzXCIsdCl9KSxlfShlLFApKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB5LnNldChlLl9pZCxlKX0pLGooaCksbSgpfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sZXJyb3I6ZnVuY3Rpb24oZSl7cmV0dXJuIHAoZSl9fSkudW5zdWJzY3JpYmUsbG9hZGVkOkV9O2Z1bmN0aW9uIGooZSl7dz12b2lkIDAsZz12b2lkIDAsYj12b2lkIDAscih2P2Z1bmN0aW9uKGUpe3ZhciByPW5ldyBNYXA7cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1yLmdldChjKGUpKTtlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9yLnNldChjKGUpLGZ1bmN0aW9uKGUpe3JldHVybiB1KHt9LGUse19pZDpjKGUpfSl9KGUpKTp0fHxyLnNldChlLl9pZCxlKX0pLEFycmF5LmZyb20oci52YWx1ZXMoKSl9KGUpOmUpfX0oZSxmdW5jdGlvbihlKXttPWUscCgpfSxpKSksUHJvbWlzZS5yZXNvbHZlKHYubG9hZGVkKS50aGVuKGZ1bmN0aW9uKCl7fSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sbT1bXSxwPW4udGhyb3R0bGUoZS5zdWJzY3JpcHRpb25UaHJvdHRsZU1zfHw1MCxmdW5jdGlvbigpe3cuZm9yRWFjaChiKX0pLHc9W107ZnVuY3Rpb24gYihlKXtyZXR1cm4gbChlLnF1ZXJ5LGUucGFyYW1zKS50aGVuKGZ1bmN0aW9uKHIpe1wicHJldmlvdXNSZXN1bHRcImluIGUmJnQoZS5wcmV2aW91c1Jlc3VsdCxyKXx8KGUucHJldmlvdXNSZXN1bHQ9cixlLmNhbGxiYWNrKHZvaWQgMCxyKSl9KS5jYXRjaChmdW5jdGlvbihyKXtlLmNhbGxiYWNrKHIpfSl9cmV0dXJue3F1ZXJ5OmwsZ2V0RG9jdW1lbnQ6ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoaCgpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGwocihkKCkpLHtpZDplfSl9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxnZXREb2N1bWVudHM6ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoaCgpKS50aGVuKGZ1bmN0aW9uKCl7dmFyIHI9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuJypbX2lkID09IFwiJytlKydcIl1bMF0nfSkuam9pbihcIixcXG5cIik7cmV0dXJuIGwoXCJbXCIrcitcIl1cIil9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxzdWJzY3JpYmU6ZnVuY3Rpb24ocix0LG4pe2lmKCFlLmxpc3Rlbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGBzdWJzY3JpYmUoKWAgd2l0aG91dCBgbGlzdGVuOiB0cnVlYFwiKTt2YXIgbz17cXVlcnk6cixwYXJhbXM6dCxjYWxsYmFjazpufTt3LnB1c2gobyk7dmFyIGk9ITE7cmV0dXJuIGIobykse3Vuc3Vic2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJuIGl8fChpPSEwLHcuc3BsaWNlKHcuaW5kZXhPZihvKSwxKSksUHJvbWlzZS5yZXNvbHZlKCl9fX0sY2xvc2U6ZnVuY3Rpb24oKXtyZXR1cm4gcC5jYW5jZWwoKSx2P3YudW5zdWJzY3JpYmUoKTpQcm9taXNlLnJlc29sdmUoKX19fShlLHtFdmVudFNvdXJjZTp3aW5kb3cuRXZlbnRTb3VyY2UsZ2V0RG9jdW1lbnRzOm19KX07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3Etc3RvcmUuanMubWFwXHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxyXG5cclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcclxuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XHJcblxyXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcclxuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XHJcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xyXG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcclxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xyXG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xyXG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcclxuXHJcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcclxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcclxuICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcblxyXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xyXG59O1xyXG4iLCJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xyXG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XHJcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcclxudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xyXG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xyXG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcclxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcclxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxyXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XHJcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcclxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XHJcbiAgICB9XHJcbiAgcmV0dXJuIGE7XHJcbn07XHJcbmNsYXNzIE1hcmtQcm9jZXNzb3Ige1xyXG4gIGNvbnN0cnVjdG9yKHN0cmluZzMsIG1hcmtzLCBwYXJzZU9wdGlvbnMpIHtcclxuICAgIHRoaXMuYWxsb3dCb29zdCA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmczO1xyXG4gICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xyXG4gICAgdGhpcy5pbmRleCA9IDA7XHJcbiAgICB0aGlzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcclxuICB9XHJcbiAgaGFzTWFyayhwb3MgPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5pbmRleCArIHBvcyA8IHRoaXMubWFya3MubGVuZ3RoO1xyXG4gIH1cclxuICBnZXRNYXJrKHBvcyA9IDApIHtcclxuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xyXG4gIH1cclxuICBzaGlmdCgpIHtcclxuICAgIHRoaXMuaW5kZXggKz0gMTtcclxuICB9XHJcbiAgcHJvY2Vzcyh2aXNpdG9yKSB7XHJcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcclxuICAgIHRoaXMuc2hpZnQoKTtcclxuICAgIGNvbnN0IGZ1bmMgPSB2aXNpdG9yW21hcmsubmFtZV07XHJcbiAgICBpZiAoIWZ1bmMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGhhbmRsZXI6ICR7bWFyay5uYW1lfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmMuY2FsbCh2aXNpdG9yLCB0aGlzLCBtYXJrKTtcclxuICB9XHJcbiAgcHJvY2Vzc1N0cmluZygpIHtcclxuICAgIHRoaXMuc2hpZnQoKTtcclxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJpbmdFbmQoKTtcclxuICB9XHJcbiAgcHJvY2Vzc1N0cmluZ0VuZCgpIHtcclxuICAgIGNvbnN0IHByZXYgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXggLSAxXTtcclxuICAgIGNvbnN0IGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xyXG4gICAgdGhpcy5zaGlmdCgpO1xyXG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xyXG4gIH1cclxuICBzbGljZShsZW4pIHtcclxuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XHJcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBwb3MgKyBsZW4pO1xyXG4gIH1cclxufVxyXG5jb25zdCBSRkMzMzM5X1JFR0VYID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT8oWnwoWy0rXVxcZHsyfTpcXGR7Mn0pKSQvO1xyXG5mdW5jdGlvbiBwYXJzZVJGQzMzMzkoc3RyKSB7XHJcbiAgaWYgKFJGQzMzMzlfUkVHRVgudGVzdChzdHIpKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoc3RyKTtcclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkKSB7XHJcbiAgY29uc3QgeWVhciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDRnVsbFllYXIoKSwgNCk7XHJcbiAgY29uc3QgbW9udGggPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01vbnRoKCkgKyAxLCAyKTtcclxuICBjb25zdCBkYXkgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0RhdGUoKSwgMik7XHJcbiAgY29uc3QgaG91ciA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDSG91cnMoKSwgMik7XHJcbiAgY29uc3QgbWludXRlID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNaW51dGVzKCksIDIpO1xyXG4gIGNvbnN0IHNlY29uZCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDU2Vjb25kcygpLCAyKTtcclxuICBsZXQgZnJhY3Rpb25hbFNlY29uZCA9IFwiXCI7XHJcbiAgY29uc3QgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcclxuICBpZiAobWlsbGlzICE9IDApIHtcclxuICAgIGZyYWN0aW9uYWxTZWNvbmQgPSBgLiR7YWRkTGVhZGluZ1plcm8obWlsbGlzLCAzKX1gO1xyXG4gIH1cclxuICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9VCR7aG91cn06JHttaW51dGV9OiR7c2Vjb25kfSR7ZnJhY3Rpb25hbFNlY29uZH1aYDtcclxufVxyXG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xyXG4gIGxldCBzdHIgPSBudW0udG9TdHJpbmcoKTtcclxuICB3aGlsZSAoc3RyLmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xyXG4gICAgc3RyID0gYDAke3N0cn1gO1xyXG4gIH1cclxuICByZXR1cm4gc3RyO1xyXG59XHJcbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmczKSB7XHJcbiAgcmV0dXJuIHN0cmluZzMucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xyXG4gIGNvbnN0IHJlID0gW107XHJcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4uc3BsaXQoXCIuXCIpKSB7XHJcbiAgICBpZiAocGFydCA9PT0gXCIqXCIpIHtcclxuICAgICAgcmUucHVzaChcIlteLl0rXCIpO1xyXG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIioqXCIpIHtcclxuICAgICAgcmUucHVzaChcIi4qXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmUucHVzaChlc2NhcGVSZWdFeHAocGFydCkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmUuam9pbihcIi5cIil9JGApO1xyXG59XHJcbmNsYXNzIFBhdGgge1xyXG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcclxuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XHJcbiAgICB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XHJcbiAgfVxyXG4gIG1hdGNoZXMoc3RyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xyXG4gIH1cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xyXG4gIH1cclxufVxyXG5jbGFzcyBTdHJlYW1WYWx1ZSB7XHJcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XHJcbiAgICB0aGlzLnR5cGUgPSBcInN0cmVhbVwiO1xyXG4gICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XHJcbiAgICB0aGlzLnRpY2tlciA9IG51bGw7XHJcbiAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5kYXRhID0gW107XHJcbiAgfVxyXG4gIGlzQXJyYXkoKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgYXN5bmMgZ2V0KCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMpIHtcclxuICAgICAgcmVzdWx0LnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICBmb3IgKDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHlpZWxkIHRoaXMuZGF0YVtpXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5pc0RvbmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgYXdhaXQgdGhpcy5fbmV4dFRpY2soKTtcclxuICAgIH1cclxuICB9XHJcbiAgX25leHRUaWNrKCkge1xyXG4gICAgaWYgKHRoaXMudGlja2VyKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcclxuICAgIH1cclxuICAgIGxldCBjdXJyZW50UmVzb2x2ZXI7XHJcbiAgICBjb25zdCBzZXR1cFRpY2tlciA9ICgpID0+IHtcclxuICAgICAgdGhpcy50aWNrZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XHJcbiAgICAgIGN1cnJlbnRSZXNvbHZlcigpO1xyXG4gICAgICBzZXR1cFRpY2tlcigpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGZldGNoID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMuZ2VuZXJhdG9yKCkpIHtcclxuICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgdGljaygpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcclxuICAgICAgdGljaygpO1xyXG4gICAgfTtcclxuICAgIHNldHVwVGlja2VyKCk7XHJcbiAgICBmZXRjaCgpO1xyXG4gICAgcmV0dXJuIHRoaXMudGlja2VyO1xyXG4gIH1cclxufVxyXG5jbGFzcyBTdGF0aWNWYWx1ZSB7XHJcbiAgY29uc3RydWN0b3IoZGF0YSwgdHlwZSkge1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgfVxyXG4gIGlzQXJyYXkoKSB7XHJcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBcImFycmF5XCI7XHJcbiAgfVxyXG4gIGFzeW5jIGdldCgpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgfVxyXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGEpKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YSkge1xyXG4gICAgICAgICAgeWllbGQgZnJvbUpTKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSh0aGlzLmRhdGEpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaXRlcmF0ZSBvdmVyOiAke3RoaXMudHlwZX1gKTtcclxuICB9XHJcbn1cclxuY29uc3QgTlVMTF9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShudWxsLCBcIm51bGxcIik7XHJcbmNvbnN0IFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUodHJ1ZSwgXCJib29sZWFuXCIpO1xyXG5jb25zdCBGQUxTRV9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShmYWxzZSwgXCJib29sZWFuXCIpO1xyXG5jbGFzcyBEYXRlVGltZSB7XHJcbiAgY29uc3RydWN0b3IoZGF0ZSkge1xyXG4gICAgdGhpcy5kYXRlID0gZGF0ZTtcclxuICB9XHJcbiAgc3RhdGljIHBhcnNlVG9WYWx1ZShzdHIpIHtcclxuICAgIGNvbnN0IGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcclxuICAgIGlmIChkYXRlKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobmV3IERhdGVUaW1lKGRhdGUpLCBcImRhdGV0aW1lXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfVxyXG4gIGVxdWFscyhvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XHJcbiAgfVxyXG4gIGFkZChzZWNzKSB7XHJcbiAgICBjb25zdCBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XHJcbiAgICBjb3B5LnNldFRpbWUoY29weS5nZXRUaW1lKCkgKyBzZWNzICogMWUzKTtcclxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoY29weSk7XHJcbiAgfVxyXG4gIGRpZmZlcmVuY2Uob3RoZXIpIHtcclxuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcclxuICB9XHJcbiAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xyXG4gIH1cclxuICB0b1N0cmluZygpIHtcclxuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XHJcbiAgfVxyXG4gIHRvSlNPTigpIHtcclxuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XHJcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShudW0pKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG51bSwgXCJudW1iZXJcIik7XHJcbiAgfVxyXG4gIHJldHVybiBOVUxMX1ZBTFVFO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XHJcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsIFwic3RyaW5nXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xyXG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsIFwiZGF0ZXRpbWVcIik7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aDIpIHtcclxuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgyLCBcInBhdGhcIik7XHJcbn1cclxuZnVuY3Rpb24gaXNJdGVyYXRvcihvYmopIHtcclxuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoubmV4dCA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21KUyh2YWwpIHtcclxuICBpZiAoaXNJdGVyYXRvcih2YWwpKSB7XHJcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdmFsKSB7XHJcbiAgICAgICAgeWllbGQgZnJvbUpTKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDApIHtcclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHZhbCwgZ2V0VHlwZSh2YWwpKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUeXBlKGRhdGEpIHtcclxuICBpZiAoZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgcmV0dXJuIFwibnVsbFwiO1xyXG4gIH1cclxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcclxuICB9XHJcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBQYXRoKSB7XHJcbiAgICByZXR1cm4gXCJwYXRoXCI7XHJcbiAgfVxyXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZVRpbWUpIHtcclxuICAgIHJldHVybiBcImRhdGV0aW1lXCI7XHJcbiAgfVxyXG4gIHJldHVybiB0eXBlb2YgZGF0YTtcclxufVxyXG5jb25zdCBUWVBFX09SREVSID0ge1xyXG4gIGRhdGV0aW1lOiAxLFxyXG4gIG51bWJlcjogMixcclxuICBzdHJpbmc6IDMsXHJcbiAgYm9vbGVhbjogNFxyXG59O1xyXG5mdW5jdGlvbiBwYXJ0aWFsQ29tcGFyZShhLCBiKSB7XHJcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpO1xyXG4gIGNvbnN0IGJUeXBlID0gZ2V0VHlwZShiKTtcclxuICBpZiAoYVR5cGUgIT09IGJUeXBlKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgc3dpdGNoIChhVHlwZSkge1xyXG4gICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICBpZiAoYSA8IGIpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICBpZiAoYSA+IGIpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XHJcbiAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xyXG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKTtcclxuICBjb25zdCBiVHlwZSA9IGdldFR5cGUoYik7XHJcbiAgY29uc3QgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMDtcclxuICBjb25zdCBiVHlwZU9yZGVyID0gVFlQRV9PUkRFUltiVHlwZV0gfHwgMTAwO1xyXG4gIGlmIChhVHlwZU9yZGVyICE9PSBiVHlwZU9yZGVyKSB7XHJcbiAgICByZXR1cm4gYVR5cGVPcmRlciAtIGJUeXBlT3JkZXI7XHJcbiAgfVxyXG4gIGxldCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShhLCBiKTtcclxuICBpZiAocmVzdWx0ID09PSBudWxsKSB7XHJcbiAgICByZXN1bHQgPSAwO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XHJcbmNvbnN0IENIQVJTX1dJVEhfV0lMRENBUkQgPSAvKFteIUAjJCVeJigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nO1xyXG5jb25zdCBFREdFX0NIQVJTID0gLyhcXGJcXC4rfFxcLitcXGIpL2c7XHJcbmNvbnN0IE1BWF9URVJNX0xFTkdUSCA9IDEwMjQ7XHJcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XHJcbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgcGF0dGVybnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiBwYXR0ZXJucy5ldmVyeSgocGF0dGVybikgPT4gcGF0dGVybih0b2tlbnMpKTtcclxufVxyXG5mdW5jdGlvbiBtYXRjaFRva2VuaXplKHRleHQpIHtcclxuICByZXR1cm4gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTKSB8fCBbXTtcclxufVxyXG5mdW5jdGlvbiBtYXRjaEFuYWx5emVQYXR0ZXJuKHRleHQpIHtcclxuICBjb25zdCB0ZXJtc1JlID0gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCk7XHJcbiAgcmV0dXJuIHRlcm1zUmUubWFwKChyZSkgPT4gKHRva2VucykgPT4gdG9rZW5zLnNvbWUoKHRva2VuKSA9PiByZS50ZXN0KHRva2VuKSkpO1xyXG59XHJcbmZ1bmN0aW9uIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpIHtcclxuICBjb25zdCB0ZXJtcyA9IHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSU19XSVRIX1dJTERDQVJEKSB8fCBbXTtcclxuICByZXR1cm4gdGVybXMubWFwKCh0ZXJtKSA9PiBuZXcgUmVnRXhwKGBeJHt0ZXJtLnNsaWNlKDAsIE1BWF9URVJNX0xFTkdUSCkucmVwbGFjZSgvXFwqL2csIFwiLipcIil9JGAsIFwiaVwiKSk7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZ2F0aGVyVGV4dCh2YWx1ZSwgY2IpIHtcclxuICBpZiAodmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgY2IodmFsdWUuZGF0YSk7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xyXG4gICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHZhbHVlKSB7XHJcbiAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBjYihwYXJ0LmRhdGEpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1Y2Nlc3M7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5jb25zdCBCTTI1ayA9IDEuMjtcclxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVTY29yZShub2RlLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGlmIChub2RlLnR5cGUgPT09IFwiT3BDYWxsXCIgJiYgbm9kZS5vcCA9PT0gXCJtYXRjaFwiKSB7XHJcbiAgICByZXR1cm4gZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xyXG4gIH1cclxuICBpZiAobm9kZS50eXBlID09PSBcIkZ1bmNDYWxsXCIgJiYgbm9kZS5uYW1lID09PSBcImJvb3N0XCIpIHtcclxuICAgIGNvbnN0IGlubmVyU2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUuYXJnc1swXSwgc2NvcGUsIGV4ZWN1dGUpO1xyXG4gICAgY29uc3QgYm9vc3QyID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcclxuICAgIGlmIChib29zdDIudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCkge1xyXG4gICAgICByZXR1cm4gaW5uZXJTY29yZSArIGJvb3N0Mi5kYXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XHJcbiAgICBjYXNlIFwiT3JcIjoge1xyXG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xyXG4gICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XHJcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xyXG4gICAgfVxyXG4gICAgY2FzZSBcIkFuZFwiOiB7XHJcbiAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSk7XHJcbiAgICAgIGNvbnN0IHJpZ2h0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcclxuICAgICAgaWYgKGxlZnRTY29yZSA9PT0gMCB8fCByaWdodFNjb3JlID09PSAwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcclxuICAgIH1cclxuICAgIGRlZmF1bHQ6IHtcclxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZXhlY3V0ZShub2RlLCBzY29wZSk7XHJcbiAgICAgIHJldHVybiByZXMudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmVzLmRhdGEgPT09IHRydWUgPyAxIDogMDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVNYXRjaFNjb3JlKGxlZnQsIHJpZ2h0LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGNvbnN0IHRleHQgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcclxuICBjb25zdCBwYXR0ZXJuID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xyXG4gIGxldCB0b2tlbnMgPSBbXTtcclxuICBsZXQgdGVybXMgPSBbXTtcclxuICBhd2FpdCBnYXRoZXJUZXh0KHRleHQsIChwYXJ0KSA9PiB7XHJcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xyXG4gIH0pO1xyXG4gIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHBhdHRlcm4sIChwYXJ0KSA9PiB7XHJcbiAgICB0ZXJtcyA9IHRlcm1zLmNvbmNhdChtYXRjaFBhdHRlcm5SZWdleChwYXJ0KSk7XHJcbiAgfSk7XHJcbiAgaWYgKCFkaWRTdWNjZWVkKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgbGV0IHNjb3JlMiA9IDA7XHJcbiAgZm9yIChjb25zdCByZSBvZiB0ZXJtcykge1xyXG4gICAgY29uc3QgZnJlcSA9IHRva2Vucy5yZWR1Y2UoKGMsIHRva2VuKSA9PiBjICsgKHJlLnRlc3QodG9rZW4pID8gMSA6IDApLCAwKTtcclxuICAgIHNjb3JlMiArPSBmcmVxICogKEJNMjVrICsgMSkgLyAoZnJlcSArIEJNMjVrKTtcclxuICB9XHJcbiAgcmV0dXJuIHNjb3JlMjtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKSB7XHJcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIHJldHVybiBibG9ja1RleHQodmFsdWUuZGF0YSk7XHJcbiAgfSBlbHNlIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcclxuICAgIGNvbnN0IHRleHRzID0gYXdhaXQgYXJyYXlUZXh0KHZhbHVlKTtcclxuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHJldHVybiB0ZXh0cy5qb2luKFwiXFxuXFxuXCIpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5hc3luYyBmdW5jdGlvbiBhcnJheVRleHQodmFsdWUsIHJlc3VsdCA9IFtdKSB7XHJcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSkge1xyXG4gICAgaWYgKGJsb2NrLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcclxuICAgICAgaWYgKHRleHQgIT09IG51bGwpXHJcbiAgICAgICAgcmVzdWx0LnB1c2godGV4dCk7XHJcbiAgICB9IGVsc2UgaWYgKGJsb2NrLmlzQXJyYXkoKSkge1xyXG4gICAgICBhd2FpdCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gYmxvY2tUZXh0KG9iaikge1xyXG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9PSBcInN0cmluZ1wiKVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSlcclxuICAgIHJldHVybiBudWxsO1xyXG4gIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcclxuICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNoaWxkLl90eXBlID09PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICByZXN1bHQgKz0gY2hpbGQudGV4dDtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBoYXNSZWZlcmVuY2UodmFsdWUsIHBhdGhTZXQpIHtcclxuICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XHJcbiAgICBjYXNlIFwiYXJyYXlcIjpcclxuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIm9iamVjdFwiOlxyXG4gICAgICBpZiAodmFsdWUuX3JlZikge1xyXG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpIHtcclxuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XHJcbiAgbGV0IGNvdW50MiA9IDA7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgIGlmIChjb2RlID49IDU1Mjk2ICYmIGNvZGUgPD0gNTYzMTkpIHtcclxuICAgICAgY29udGludWU7XHJcbiAgICB9XHJcbiAgICBjb3VudDIrKztcclxuICB9XHJcbiAgcmV0dXJuIGNvdW50MjtcclxufVxyXG5jb25zdCBnbG9iYWwgPSB7fTtcclxuZ2xvYmFsLmNvYWxlc2NlID0gYXN5bmMgZnVuY3Rpb24gY29hbGVzY2UoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XHJcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudWxsXCIpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gTlVMTF9WQUxVRTtcclxufTtcclxuZ2xvYmFsLmNvdW50ID0gYXN5bmMgZnVuY3Rpb24gY291bnQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xyXG4gIGlmICghaW5uZXIuaXNBcnJheSgpKSB7XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbiAgbGV0IG51bSA9IDA7XHJcbiAgZm9yIGF3YWl0IChjb25zdCBfIG9mIGlubmVyKSB7XHJcbiAgICBudW0rKztcclxuICB9XHJcbiAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcclxufTtcclxuZ2xvYmFsLmNvdW50LmFyaXR5ID0gMTtcclxuZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24gZGF0ZVRpbWUoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCB2YWwgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcclxuICBpZiAodmFsLnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xyXG4gICAgcmV0dXJuIHZhbDtcclxuICB9XHJcbiAgaWYgKHZhbC50eXBlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbiAgcmV0dXJuIERhdGVUaW1lLnBhcnNlVG9WYWx1ZSh2YWwuZGF0YSk7XHJcbn07XHJcbmdsb2JhbC5kYXRlVGltZS5hcml0eSA9IDE7XHJcbmdsb2JhbC5kZWZpbmVkID0gYXN5bmMgZnVuY3Rpb24gZGVmaW5lZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XHJcbiAgcmV0dXJuIGlubmVyLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xyXG59O1xyXG5nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XHJcbmdsb2JhbC5pZGVudGl0eSA9IGFzeW5jIGZ1bmN0aW9uIGlkZW50aXR5KGFyZ3MsIHNjb3BlKSB7XHJcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSk7XHJcbn07XHJcbmdsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XHJcbmdsb2JhbC5sZW5ndGggPSBhc3luYyBmdW5jdGlvbiBsZW5ndGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xyXG4gIGlmIChpbm5lci50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICByZXR1cm4gZnJvbU51bWJlcihjb3VudFVURjgoaW5uZXIuZGF0YSkpO1xyXG4gIH1cclxuICBpZiAoaW5uZXIuaXNBcnJheSgpKSB7XHJcbiAgICBsZXQgbnVtID0gMDtcclxuICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xyXG4gICAgICBudW0rKztcclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XHJcbiAgfVxyXG4gIHJldHVybiBOVUxMX1ZBTFVFO1xyXG59O1xyXG5nbG9iYWwubGVuZ3RoLmFyaXR5ID0gMTtcclxuZ2xvYmFsLnBhdGggPSBhc3luYyBmdW5jdGlvbiBwYXRoKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcclxuICBpZiAoaW5uZXIudHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfVxyXG4gIHJldHVybiBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSk7XHJcbn07XHJcbmdsb2JhbC5wYXRoLmFyaXR5ID0gMTtcclxuZ2xvYmFsLnN0cmluZyA9IGFzeW5jIGZ1bmN0aW9uIHN0cmluZyhhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XHJcbiAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XHJcbiAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICBjYXNlIFwic3RyaW5nXCI6XHJcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxyXG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XHJcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGAke3ZhbHVlLmRhdGF9YCk7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbn07XHJcbmdsb2JhbC5zdHJpbmcuYXJpdHkgPSAxO1xyXG5nbG9iYWwucmVmZXJlbmNlcyA9IGFzeW5jIGZ1bmN0aW9uIHJlZmVyZW5jZXMoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCBwYXRoU2V0ID0gbmV3IFNldCgpO1xyXG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcclxuICAgIGNvbnN0IHBhdGgyID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcclxuICAgIGlmIChwYXRoMi50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHBhdGhTZXQuYWRkKHBhdGgyLmRhdGEpO1xyXG4gICAgfSBlbHNlIGlmIChwYXRoMi5pc0FycmF5KCkpIHtcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHBhdGgyKSB7XHJcbiAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgcGF0aFNldC5hZGQoZWxlbS5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHBhdGhTZXQuc2l6ZSA9PT0gMCkge1xyXG4gICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xyXG4gIH1cclxuICBjb25zdCBzY29wZVZhbHVlID0gYXdhaXQgc2NvcGUudmFsdWUuZ2V0KCk7XHJcbiAgcmV0dXJuIGhhc1JlZmVyZW5jZShzY29wZVZhbHVlLCBwYXRoU2V0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcclxufTtcclxuZ2xvYmFsLnJlZmVyZW5jZXMuYXJpdHkgPSAoYykgPT4gYyA+PSAxO1xyXG5nbG9iYWwucm91bmQgPSBhc3luYyBmdW5jdGlvbiByb3VuZChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XHJcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH1cclxuICBjb25zdCBudW0gPSB2YWx1ZS5kYXRhO1xyXG4gIGxldCBwcmVjID0gMDtcclxuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcclxuICAgIGNvbnN0IHByZWNWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xyXG4gICAgaWYgKHByZWNWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHByZWNWYWx1ZS5kYXRhIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihwcmVjVmFsdWUuZGF0YSkpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBwcmVjID0gcHJlY1ZhbHVlLmRhdGE7XHJcbiAgfVxyXG4gIGlmIChwcmVjID09PSAwKSB7XHJcbiAgICBpZiAobnVtIDwgMCkge1xyXG4gICAgICByZXR1cm4gZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnJvbU51bWJlcihNYXRoLnJvdW5kKG51bSkpO1xyXG4gIH1cclxuICByZXR1cm4gZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKTtcclxufTtcclxuZ2xvYmFsLnJvdW5kLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDEgJiYgY291bnQyIDw9IDI7XHJcbmdsb2JhbC5ub3cgPSBhc3luYyBmdW5jdGlvbiBub3coYXJncywgc2NvcGUpIHtcclxuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnRpbWVzdGFtcC50b0lTT1N0cmluZygpKTtcclxufTtcclxuZ2xvYmFsLm5vdy5hcml0eSA9IDA7XHJcbmdsb2JhbC5ib29zdCA9IGFzeW5jIGZ1bmN0aW9uIGJvb3N0KCkge1xyXG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcclxufTtcclxuZ2xvYmFsLmJvb3N0LmFyaXR5ID0gMjtcclxuY29uc3Qgc3RyaW5nMiA9IHt9O1xyXG5zdHJpbmcyLmxvd2VyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xyXG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbiAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKTtcclxufTtcclxuc3RyaW5nMi5sb3dlci5hcml0eSA9IDE7XHJcbnN0cmluZzIudXBwZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XHJcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH1cclxuICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xyXG59O1xyXG5zdHJpbmcyLnVwcGVyLmFyaXR5ID0gMTtcclxuZ2xvYmFsLmxvd2VyID0gc3RyaW5nMi5sb3dlcjtcclxuZ2xvYmFsLnVwcGVyID0gc3RyaW5nMi51cHBlcjtcclxuY29uc3QgcHQgPSB7fTtcclxucHQudGV4dCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcclxuICBjb25zdCB0ZXh0ID0gYXdhaXQgcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSk7XHJcbiAgaWYgKHRleHQgPT09IG51bGwpIHtcclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH1cclxuICByZXR1cm4gZnJvbVN0cmluZyh0ZXh0KTtcclxufTtcclxucHQudGV4dC5hcml0eSA9IDE7XHJcbmNvbnN0IHNhbml0eSA9IHt9O1xyXG5zYW5pdHkucHJvamVjdElkID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcclxuICBpZiAoc2NvcGUuY29udGV4dC5zYW5pdHkpIHtcclxuICAgIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LnByb2plY3RJZCk7XHJcbiAgfVxyXG4gIHJldHVybiBOVUxMX1ZBTFVFO1xyXG59O1xyXG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XHJcbiAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XHJcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KTtcclxuICB9XHJcbiAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbn07XHJcbmNvbnN0IHBpcGVGdW5jdGlvbnMgPSB7fTtcclxucGlwZUZ1bmN0aW9ucy5vcmRlciA9IGFzeW5jIGZ1bmN0aW9uIG9yZGVyKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgYXdhaXQgdHJ1ZTtcclxuICBpZiAoIWJhc2UuaXNBcnJheSgpKSB7XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbiAgY29uc3QgbWFwcGVycyA9IFtdO1xyXG4gIGNvbnN0IGRpcmVjdGlvbnMgPSBbXTtcclxuICBsZXQgbiA9IDA7XHJcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcclxuICAgIGxldCBkaXJlY3Rpb24gPSBcImFzY1wiO1xyXG4gICAgaWYgKG1hcHBlci50eXBlID09PSBcIkRlc2NcIikge1xyXG4gICAgICBkaXJlY3Rpb24gPSBcImRlc2NcIjtcclxuICAgICAgbWFwcGVyID0gbWFwcGVyLmJhc2U7XHJcbiAgICB9IGVsc2UgaWYgKG1hcHBlci50eXBlID09PSBcIkFzY1wiKSB7XHJcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xyXG4gICAgfVxyXG4gICAgbWFwcGVycy5wdXNoKG1hcHBlcik7XHJcbiAgICBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcclxuICAgIG4rKztcclxuICB9XHJcbiAgY29uc3QgYXV4ID0gW107XHJcbiAgbGV0IGlkeCA9IDA7XHJcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XHJcbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XHJcbiAgICBjb25zdCB0dXBsZSA9IFthd2FpdCB2YWx1ZS5nZXQoKSwgaWR4XTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpO1xyXG4gICAgICB0dXBsZS5wdXNoKGF3YWl0IHJlc3VsdC5nZXQoKSk7XHJcbiAgICB9XHJcbiAgICBhdXgucHVzaCh0dXBsZSk7XHJcbiAgICBpZHgrKztcclxuICB9XHJcbiAgYXV4LnNvcnQoKGFUdXBsZSwgYlR1cGxlKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcclxuICAgICAgaWYgKGRpcmVjdGlvbnNbaV0gPT09IFwiZGVzY1wiKSB7XHJcbiAgICAgICAgYyA9IC1jO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjICE9PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhVHVwbGVbMV0gLSBiVHVwbGVbMV07XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGZyb21KUyhhdXgubWFwKCh2KSA9PiB2WzBdKSk7XHJcbn07XHJcbnBpcGVGdW5jdGlvbnMub3JkZXIuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcclxucGlwZUZ1bmN0aW9ucy5zY29yZSA9IGFzeW5jIGZ1bmN0aW9uIHNjb3JlKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSlcclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIGNvbnN0IHVua25vd24gPSBbXTtcclxuICBjb25zdCBzY29yZWQgPSBbXTtcclxuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcclxuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIHVua25vd24ucHVzaChhd2FpdCB2YWx1ZS5nZXQoKSk7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xyXG4gICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWUuZGF0YS5fc2NvcmUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XHJcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XHJcbiAgICAgIHZhbHVlU2NvcmUgKz0gYXdhaXQgZXZhbHVhdGVTY29yZShhcmcsIG5ld1Njb3BlLCBleGVjdXRlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlLmRhdGEsIHsgX3Njb3JlOiB2YWx1ZVNjb3JlIH0pO1xyXG4gICAgc2NvcmVkLnB1c2gobmV3T2JqZWN0KTtcclxuICB9XHJcbiAgc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpO1xyXG4gIHJldHVybiBmcm9tSlMoc2NvcmVkKTtcclxufTtcclxucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xyXG5jb25zdCBkZWx0YSA9IHt9O1xyXG5kZWx0YS5vcGVyYXRpb24gPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xyXG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsO1xyXG4gIGNvbnN0IGhhc0FmdGVyID0gc2NvcGUuY29udGV4dC5hZnRlciAhPT0gbnVsbDtcclxuICBpZiAoaGFzQmVmb3JlICYmIGhhc0FmdGVyKSB7XHJcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcInVwZGF0ZVwiKTtcclxuICB9XHJcbiAgaWYgKGhhc0FmdGVyKSB7XHJcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcImNyZWF0ZVwiKTtcclxuICB9XHJcbiAgaWYgKGhhc0JlZm9yZSkge1xyXG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJkZWxldGVcIik7XHJcbiAgfVxyXG4gIHJldHVybiBOVUxMX1ZBTFVFO1xyXG59O1xyXG5kZWx0YS5jaGFuZ2VkQW55ID0gKCkgPT4ge1xyXG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcclxufTtcclxuZGVsdGEuY2hhbmdlZEFueS5hcml0eSA9IDE7XHJcbmRlbHRhLmNoYW5nZWRBbnkubW9kZSA9IFwiZGVsdGFcIjtcclxuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xyXG59O1xyXG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XHJcbmRlbHRhLmNoYW5nZWRPbmx5Lm1vZGUgPSBcImRlbHRhXCI7XHJcbmNvbnN0IGRpZmYgPSB7fTtcclxuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xyXG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcclxufTtcclxuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcclxuZGlmZi5jaGFuZ2VkT25seSA9ICgpID0+IHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XHJcbn07XHJcbmRpZmYuY2hhbmdlZE9ubHkuYXJpdHkgPSAzO1xyXG5jb25zdCBuYW1lc3BhY2VzID0ge1xyXG4gIGdsb2JhbCxcclxuICBzdHJpbmc6IHN0cmluZzIsXHJcbiAgcHQsXHJcbiAgZGVsdGEsXHJcbiAgZGlmZixcclxuICBzYW5pdHlcclxufTtcclxuY29uc3QgV1MgPSAvXihbXFx0XFxuXFx2XFxmXFxyIFxcdTAwODVcXHUwMEEwXXwoXFwvXFwvW15cXG5dKlxcbikpKy87XHJcbmNvbnN0IE5VTSA9IC9eXFxkKy87XHJcbmNvbnN0IElERU5UID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qLztcclxuY29uc3QgUFJFQ19QQUlSID0gMTtcclxuY29uc3QgUFJFQ19PUiA9IDI7XHJcbmNvbnN0IFBSRUNfQU5EID0gMztcclxuY29uc3QgUFJFQ19DT01QID0gNDtcclxuY29uc3QgUFJFQ19PUkRFUiA9IDQ7XHJcbmNvbnN0IFBSRUNfQUREID0gNjtcclxuY29uc3QgUFJFQ19TVUIgPSA2O1xyXG5jb25zdCBQUkVDX01VTCA9IDc7XHJcbmNvbnN0IFBSRUNfRElWID0gNztcclxuY29uc3QgUFJFQ19NT0QgPSA3O1xyXG5jb25zdCBQUkVDX1BPVyA9IDg7XHJcbmNvbnN0IFBSRUNfUE9TID0gMTA7XHJcbmNvbnN0IFBSRUNfTk9UID0gMTA7XHJcbmNvbnN0IFBSRUNfTkVHID0gODtcclxuZnVuY3Rpb24gcGFyc2UkMShzdHIpIHtcclxuICBsZXQgcG9zID0gMDtcclxuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xyXG4gIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xyXG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xyXG4gIGlmIChwb3MgIT09IHN0ci5sZW5ndGgpIHtcclxuICAgIGlmIChyZXN1bHQuZmFpbFBvc2l0aW9uKSB7XHJcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgfVxyXG4gIGRlbGV0ZSByZXN1bHQucG9zaXRpb247XHJcbiAgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb247XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XHJcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xyXG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xyXG4gIGxldCBtYXJrcztcclxuICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICBjYXNlIFwiK1wiOiB7XHJcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19QT1MpO1xyXG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwicG9zXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNhc2UgXCItXCI6IHtcclxuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX05FRyk7XHJcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJuZWdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgY2FzZSBcIihcIjoge1xyXG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xyXG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xyXG4gICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XHJcbiAgICAgICAgY2FzZSBcIixcIjoge1xyXG4gICAgICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInR1cGxlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xyXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcclxuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxyXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidHVwbGVfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIilcIjoge1xyXG4gICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZ3JvdXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNhc2UgXCIhXCI6IHtcclxuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX05PVCk7XHJcbiAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJub3RcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgY2FzZSBcIntcIjoge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xyXG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcclxuICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNhc2UgXCJbXCI6XHJcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJhcnJheVwiLCBwb3NpdGlvbjogcG9zIH1dO1xyXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcclxuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIikge1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpIHtcclxuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfc3BsYXRcIiwgcG9zaXRpb246IHBvcyB9KTtcclxuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsZXQgcmVzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcclxuICAgICAgICAgIGlmIChyZXMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzLm1hcmtzKTtcclxuICAgICAgICAgIHBvcyA9IHJlcy5wb3NpdGlvbjtcclxuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XHJcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xyXG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIilcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpIHtcclxuICAgICAgICBwb3MrKztcclxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJhcnJheV9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCInXCI6XHJcbiAgICBjYXNlICdcIic6IHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlU3RyaW5nKHN0ciwgcG9zKTtcclxuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XHJcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBjYXNlIFwiXlwiOiB7XHJcbiAgICAgIHBvcysrO1xyXG4gICAgICBtYXJrcyA9IFtdO1xyXG4gICAgICB3aGlsZSAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCJeXCIpIHtcclxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJkYmxwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgIHBvcyArPSAyO1xyXG4gICAgICB9XHJcbiAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInBhcmVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgY2FzZSBcIkBcIjpcclxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInRoaXNcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xyXG4gICAgICBwb3MrKztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiKlwiOlxyXG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZXZlcnl0aGluZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XHJcbiAgICAgIHBvcysrO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCIkXCI6IHtcclxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIElERU5UKTtcclxuICAgICAgaWYgKGlkZW50TGVuKSB7XHJcbiAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcclxuICAgICAgICBtYXJrcyA9IFtcclxuICAgICAgICAgIHsgbmFtZTogXCJwYXJhbVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcclxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxIH0sXHJcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0OiB7XHJcbiAgICAgIGxldCBudW1MZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBOVU0pO1xyXG4gICAgICBpZiAobnVtTGVuKSB7XHJcbiAgICAgICAgcG9zICs9IG51bUxlbjtcclxuICAgICAgICBsZXQgbmFtZSA9IFwiaW50ZWdlclwiO1xyXG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIpIHtcclxuICAgICAgICAgIGxldCBmcmFjTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIE5VTSk7XHJcbiAgICAgICAgICBpZiAoZnJhY0xlbikge1xyXG4gICAgICAgICAgICBuYW1lID0gXCJmbG9hdFwiO1xyXG4gICAgICAgICAgICBwb3MgKz0gMSArIGZyYWNMZW47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJlXCIgfHwgc3RyW3Bvc10gPT09IFwiRVwiKSB7XHJcbiAgICAgICAgICBuYW1lID0gXCJzY2lcIjtcclxuICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIitcIiB8fCBzdHJbcG9zXSA9PT0gXCItXCIpIHtcclxuICAgICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcclxuICAgICAgICAgIGlmICghZXhwTGVuKVxyXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgICAgIHBvcyArPSBleHBMZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcmtzID0gW1xyXG4gICAgICAgICAgeyBuYW1lLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcclxuICAgICAgICAgIHsgbmFtZTogbmFtZSArIFwiX2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cclxuICAgICAgICBdO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcclxuICAgICAgaWYgKGlkZW50TGVuKSB7XHJcbiAgICAgICAgcG9zICs9IGlkZW50TGVuO1xyXG4gICAgICAgIHN3aXRjaCAoc3RyW3Bvc10pIHtcclxuICAgICAgICAgIGNhc2UgXCI6XCI6XHJcbiAgICAgICAgICBjYXNlIFwiKFwiOiB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcyk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzO1xyXG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICBtYXJrcyA9IFtcclxuICAgICAgICAgICAgICB7IG5hbWU6IFwidGhpc19hdHRyXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxyXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcclxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoIW1hcmtzKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICB9XHJcbiAgbGV0IGxoc0xldmVsID0gMTI7XHJcbiAgbGV0IHRyYXY7XHJcbiAgbG9vcDpcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIGxldCBpbm5lclBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XHJcbiAgICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xyXG4gICAgICAgIHBvcyA9IGlubmVyUG9zO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIGlubmVyUG9zKTtcclxuICAgICAgaWYgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcclxuICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJ0cmF2ZXJzZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHRyYXYubWFya3MpO1xyXG4gICAgICAgICAgcG9zID0gdHJhdi5wb3NpdGlvbjtcclxuICAgICAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0cmF2ZXJzYWxfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHRva2VuMiA9IHN0cltpbm5lclBvc107XHJcbiAgICAgIHN3aXRjaCAodG9rZW4yKSB7XHJcbiAgICAgICAgY2FzZSBcIj1cIjoge1xyXG4gICAgICAgICAgbGV0IG5leHRUb2tlbiA9IHN0cltpbm5lclBvcyArIDFdO1xyXG4gICAgICAgICAgc3dpdGNoIChuZXh0VG9rZW4pIHtcclxuICAgICAgICAgICAgY2FzZSBcIj5cIjoge1xyXG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUEFJUiB8fCBsaHNMZXZlbCA8PSBQUkVDX1BBSVIpXHJcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BBSVIpO1xyXG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInBhaXJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUEFJUjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwiPVwiOiB7XHJcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcclxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIDUpO1xyXG4gICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xyXG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiK1wiOiB7XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FERCB8fCBsaHNMZXZlbCA8IFBSRUNfQUREKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfQUREICsgMSk7XHJcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhZGRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FERDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiLVwiOiB7XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1NVQiB8fCBsaHNMZXZlbCA8IFBSRUNfU1VCKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfU1VCICsgMSk7XHJcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJzdWJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1NVQjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiKlwiOiB7XHJcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUE9XIHx8IGxoc0xldmVsIDw9IFBSRUNfUE9XKVxyXG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QT1cpO1xyXG4gICAgICAgICAgICBpZiAocmhzMi50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHJoczI7XHJcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJoczIubWFya3MpO1xyXG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwb3dcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgICBwb3MgPSByaHMyLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfUE9XO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTVVMIHx8IGxoc0xldmVsIDwgUFJFQ19NVUwpXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19NVUwgKyAxKTtcclxuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm11bFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfTVVMO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCIvXCI6IHtcclxuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfRElWIHx8IGxoc0xldmVsIDwgUFJFQ19ESVYpXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19ESVYgKyAxKTtcclxuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRpdlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfRElWO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCIlXCI6IHtcclxuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfTU9EIHx8IGxoc0xldmVsIDwgUFJFQ19NT0QpXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAxKSwgUFJFQ19NT0QgKyAxKTtcclxuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm1vZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfTU9EO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCI8XCI6XHJcbiAgICAgICAgY2FzZSBcIj5cIjoge1xyXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIGxldCBuZXh0UG9zID0gaW5uZXJQb3MgKyAxO1xyXG4gICAgICAgICAgaWYgKHN0cltuZXh0UG9zXSA9PT0gXCI9XCIpIHtcclxuICAgICAgICAgICAgbmV4dFBvcysrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MpLCBQUkVDX0NPTVAgKyAxKTtcclxuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogbmV4dFBvcyB9KTtcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwifFwiOiB7XHJcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwifFwiKSB7XHJcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1IgfHwgbGhzTGV2ZWwgPCBQUkVDX09SKVxyXG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX09SICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm9yXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1I7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobGV2ZWwgPiAxMSB8fCBsaHNMZXZlbCA8IDExKVxyXG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSk7XHJcbiAgICAgICAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xyXG4gICAgICAgICAgICBpZiAoIWlkZW50TGVuKVxyXG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IGlkZW50UG9zIH07XHJcbiAgICAgICAgICAgIHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW47XHJcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XHJcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcclxuICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcclxuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwaXBlY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiJlwiOiB7XHJcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gXCImXCIpXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FORCB8fCBsaHNMZXZlbCA8IFBSRUNfQU5EKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQU5EICsgMSk7XHJcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhbmRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FORDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiIVwiOiB7XHJcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT09IFwiPVwiKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDwgUFJFQ19DT01QKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQ09NUCArIDEpO1xyXG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSk7XHJcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcImRcIjoge1xyXG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyA0KSAhPT0gXCJkZXNjXCIpXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUilcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRlc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgcG9zID0gaW5uZXJQb3MgKyA0O1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJhXCI6IHtcclxuICAgICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgMykgIT09IFwiYXNjXCIpXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUilcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFzY1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDM7XHJcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgbGV0IGlkZW50ID0gcGFyc2VSZWdleFN0cihzdHIsIGlubmVyUG9zLCBJREVOVCk7XHJcbiAgICAgICAgICBzd2l0Y2ggKGlkZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJpblwiOiB7XHJcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcclxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKTtcclxuICAgICAgICAgICAgICBsZXQgaXNHcm91cCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIpIHtcclxuICAgICAgICAgICAgICAgIGlzR3JvdXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcclxuICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCBQUkVDX0NPTVAgKyAxKTtcclxuICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcclxuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwiLlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImV4Y19yYW5nZVwiO1xyXG4gICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImluX3JhbmdlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH0sIHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKTtcclxuICAgICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xyXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKVxyXG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hcIjoge1xyXG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXHJcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDUpLCBQUkVDX0NPTVAgKyAxKTtcclxuICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgNSB9KTtcclxuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICBsaHNMZXZlbCA9IDQ7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBsZXQgZmFpbFBvc2l0aW9uID0gKHRyYXYgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYXYudHlwZSkgPT09IFwiZXJyb3JcIiAmJiB0cmF2LnBvc2l0aW9uO1xyXG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcywgZmFpbFBvc2l0aW9uIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcclxuICBsZXQgc3RhcnRQb3MgPSBwb3M7XHJcbiAgc3dpdGNoIChzdHJbcG9zXSkge1xyXG4gICAgY2FzZSBcIi5cIjoge1xyXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcclxuICAgICAgbGV0IGlkZW50U3RhcnQgPSBwb3M7XHJcbiAgICAgIGxldCBpZGVudExlbjIgPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XHJcbiAgICAgIGlmICghaWRlbnRMZW4yKVxyXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xyXG4gICAgICBwb3MgKz0gaWRlbnRMZW4yO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxyXG4gICAgICAgIG1hcmtzOiBbXHJcbiAgICAgICAgICB7IG5hbWU6IFwiYXR0cl9hY2Nlc3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXHJcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IGlkZW50U3RhcnQgfSxcclxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBwb3NpdGlvbjogcG9zXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXNlIFwiLVwiOlxyXG4gICAgICBpZiAoc3RyW3BvcyArIDFdICE9PSBcIj5cIilcclxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgbGV0IG1hcmtzID0gW3sgbmFtZTogXCJkZXJlZlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XHJcbiAgICAgIHBvcyArPSAyO1xyXG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xyXG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcclxuICAgICAgaWYgKGlkZW50TGVuKSB7XHJcbiAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcclxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJkZXJlZl9hdHRyXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IGlkZW50UG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxyXG4gICAgICAgIG1hcmtzLFxyXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcclxuICAgICAgfTtcclxuICAgIGNhc2UgXCJbXCI6IHtcclxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXHJcbiAgICAgICAgICBtYXJrczogW3sgbmFtZTogXCJhcnJheV9wb3N0Zml4XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XSxcclxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XHJcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xyXG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xyXG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcclxuICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XHJcbiAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcclxuICAgICAgICAgIHR5cGUgPSBcImV4Y19yYW5nZVwiO1xyXG4gICAgICAgICAgcG9zICs9IDM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBvcyArPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xyXG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xyXG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xyXG4gICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpXHJcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXHJcbiAgICAgICAgICBtYXJrczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6IFwic2xpY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogdHlwZSwgcG9zaXRpb246IHJhbmdlUG9zIH1cclxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcclxuICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKVxyXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxyXG4gICAgICAgIG1hcmtzOiBbeyBuYW1lOiBcInNxdWFyZV9icmFja2V0XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmVzdWx0Lm1hcmtzKSxcclxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2FzZSBcInxcIjoge1xyXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcclxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIntcIikge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgY2FzZSBcIntcIjoge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xyXG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XHJcbiAgbGV0IG1hcmtzID0gW107XHJcbiAgbWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19jYWxsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICBpZiAoc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcclxuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm5hbWVzcGFjZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xyXG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XHJcbiAgICBsZXQgbmFtZUxlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcclxuICAgIGlmICghbmFtZUxlbilcclxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogcG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyArIG5hbWVMZW4gfSk7XHJcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyBuYW1lTGVuKTtcclxuICAgIGlmIChzdHJbcG9zXSAhPT0gXCIoXCIpXHJcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xyXG4gICAgcG9zKys7XHJcbiAgfSBlbHNlIHtcclxuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcclxuICB9XHJcbiAgbGV0IGxhc3RQb3MgPSBwb3M7XHJcbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIikge1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XHJcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XHJcbiAgICAgIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb247XHJcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XHJcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xyXG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiKVwiKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICB9XHJcbiAgbWFya3MucHVzaCh7IG5hbWU6IFwiZnVuY19hcmdzX2VuZFwiLCBwb3NpdGlvbjogbGFzdFBvcyB9KTtcclxuICByZXR1cm4ge1xyXG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXHJcbiAgICBtYXJrcyxcclxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXHJcbiAgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xyXG4gIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwib2JqZWN0XCIsIHBvc2l0aW9uOiBwb3MgfV07XHJcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgd2hpbGUgKHN0cltwb3NdICE9PSBcIn1cIikge1xyXG4gICAgbGV0IHBhaXJQb3MgPSBwb3M7XHJcbiAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpIHtcclxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XHJcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJ9XCIgJiYgc3RyW3Bvc10gIT09IFwiLFwiKSB7XHJcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xyXG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgIHJldHVybiBleHByO1xyXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdFwiLCBwb3NpdGlvbjogcGFpclBvcyB9KTtcclxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcclxuICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdF90aGlzXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XHJcbiAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gZXhwcjtcclxuICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcclxuICAgICAgaWYgKGV4cHIubWFya3NbMF0ubmFtZSA9PT0gXCJzdHJcIiAmJiBzdHJbbmV4dFBvc10gPT09IFwiOlwiKSB7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyArIDEpLCAwKTtcclxuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9wYWlyXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xyXG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKTtcclxuICAgICAgICBwb3MgPSB2YWx1ZS5wb3NpdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IFwib2JqZWN0X2V4cHJcIiwgcG9zaXRpb246IHBvcyB9LCBleHByLm1hcmtzKTtcclxuICAgICAgICBwb3MgPSBleHByLnBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xyXG4gICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcclxuICAgICAgYnJlYWs7XHJcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcclxuICB9XHJcbiAgaWYgKHN0cltwb3NdICE9PSBcIn1cIikge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgfVxyXG4gIHBvcysrO1xyXG4gIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcclxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIsIHBvcykge1xyXG4gIGxldCB0b2tlbiA9IHN0cltwb3NdO1xyXG4gIHBvcyA9IHBvcyArIDE7XHJcbiAgY29uc3QgbWFya3MgPSBbeyBuYW1lOiBcInN0clwiLCBwb3NpdGlvbjogcG9zIH1dO1xyXG4gIHN0cjpcclxuICAgIGZvciAoOyA7IHBvcysrKSB7XHJcbiAgICAgIGlmIChwb3MgPiBzdHIubGVuZ3RoKVxyXG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xyXG4gICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XHJcbiAgICAgICAgY2FzZSB0b2tlbjoge1xyXG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xyXG4gICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgICBicmVhayBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcclxuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9wYXVzZVwiLCBwb3NpdGlvbjogcG9zIH0pO1xyXG4gICAgICAgICAgaWYgKHN0cltwb3MgKyAxXSA9PT0gXCJ1XCIpIHtcclxuICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIpIHtcclxuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ1bmljb2RlX2hleFwiLCBwb3NpdGlvbjogcG9zICsgMyB9KTtcclxuICAgICAgICAgICAgICBwb3MgPSBzdHIuaW5kZXhPZihcIn1cIiwgcG9zICsgMyk7XHJcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgICAgICAgICAgICAgcG9zKys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDIgfSk7XHJcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyA2IH0pO1xyXG4gICAgICAgICAgICAgIHBvcyArPSA1O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzaW5nbGVfZXNjYXBlXCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pO1xyXG4gICAgICAgICAgICBwb3MgKz0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9zdGFydFwiLCBwb3NpdGlvbjogcG9zICsgMSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcclxufVxyXG5mdW5jdGlvbiBza2lwV1Moc3RyLCBwb3MpIHtcclxuICByZXR1cm4gcG9zICsgcGFyc2VSZWdleChzdHIsIHBvcywgV1MpO1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlUmVnZXgoc3RyLCBwb3MsIHJlKSB7XHJcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcclxuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMDtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCByZSkge1xyXG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XHJcbiAgcmV0dXJuIG0gPyBtWzBdIDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiBqb2luKGEsIGIpIHtcclxuICByZXR1cm4gKGJhc2UpID0+IGIoYShiYXNlKSk7XHJcbn1cclxuZnVuY3Rpb24gbWFwKGlubmVyKSB7XHJcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIk1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGZsYXRNYXAoaW5uZXIpIHtcclxuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiRmxhdE1hcFwiLCBiYXNlLCBleHByOiBpbm5lcih7IHR5cGU6IFwiVGhpc1wiIH0pIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlQXJyYXkoYnVpbGQsIHJpZ2h0KSB7XHJcbiAgaWYgKCFyaWdodCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJhLWFcIixcclxuICAgICAgYnVpbGRcclxuICAgIH07XHJcbiAgfVxyXG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xyXG4gICAgY2FzZSBcImEtYVwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXHJcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBcImEtYlwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXHJcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBcImItYlwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXHJcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiYi1hXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJhLWFcIixcclxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgZmxhdE1hcChyaWdodC5idWlsZCkpXHJcbiAgICAgIH07XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcclxuICBpZiAoIXJpZ2h0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcImItYlwiLFxyXG4gICAgICBidWlsZDogbWFwcGVyXHJcbiAgICB9O1xyXG4gIH1cclxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcclxuICAgIGNhc2UgXCJhLWFcIjpcclxuICAgIGNhc2UgXCJiLWFcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImItYVwiLFxyXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiYS1iXCI6XHJcbiAgICBjYXNlIFwiYi1iXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJiLWJcIixcclxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxyXG4gICAgICB9O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcclxuICBpZiAoIXJpZ2h0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcImEtYlwiLFxyXG4gICAgICBidWlsZDogbWFwcGVyXHJcbiAgICB9O1xyXG4gIH1cclxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcclxuICAgIGNhc2UgXCJhLWFcIjpcclxuICAgIGNhc2UgXCJiLWFcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImEtYVwiLFxyXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiYS1iXCI6XHJcbiAgICBjYXNlIFwiYi1iXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJhLWJcIixcclxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxyXG4gICAgICB9O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VQcm9qZWN0aW9uKG1hcHBlciwgcmlnaHQpIHtcclxuICBpZiAoIXJpZ2h0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcImItYlwiLFxyXG4gICAgICBidWlsZDogbWFwcGVyXHJcbiAgICB9O1xyXG4gIH1cclxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcclxuICAgIGNhc2UgXCJhLWFcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImEtYVwiLFxyXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcclxuICAgICAgfTtcclxuICAgIGNhc2UgXCJhLWJcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImEtYlwiLFxyXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcclxuICAgICAgfTtcclxuICAgIGNhc2UgXCJiLWFcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImItYVwiLFxyXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiYi1iXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJiLWJcIixcclxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxyXG4gICAgICB9O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcclxuICB9XHJcbn1cclxuY29uc3QgaXNFcXVhbCA9IGVxdWFsaXR5O1xyXG5mdW5jdGlvbiBlcXVhbGl0eShhLCBiKSB7XHJcbiAgaWYgKGEudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBiLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgYS50eXBlID09PSBcImJvb2xlYW5cIiAmJiBiLnR5cGUgPT09IFwiYm9vbGVhblwiIHx8IGEudHlwZSA9PT0gXCJudWxsXCIgJiYgYi50eXBlID09PSBcIm51bGxcIiB8fCBhLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgYi50eXBlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICByZXR1cm4gYS5kYXRhID09PSBiLmRhdGE7XHJcbiAgfVxyXG4gIGlmIChhLnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiBiLnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xyXG4gICAgcmV0dXJuIGEuZGF0YS5lcXVhbHMoYi5kYXRhKTtcclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmNvbnN0IG9wZXJhdG9ycyA9IHtcclxuICBcIj09XCI6IGZ1bmN0aW9uIGVxKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XHJcbiAgfSxcclxuICBcIiE9XCI6IGZ1bmN0aW9uIG5lcShsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xyXG4gIH0sXHJcbiAgXCI+XCI6IGZ1bmN0aW9uIGd0KGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcclxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0ID4gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcclxuICB9LFxyXG4gIFwiPj1cIjogZnVuY3Rpb24gZ3RlKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcclxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0ID49IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XHJcbiAgfSxcclxuICBcIjxcIjogZnVuY3Rpb24gbHQobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xyXG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xyXG4gIH0sXHJcbiAgXCI8PVwiOiBmdW5jdGlvbiBsdGUobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICBjb25zdCByZXN1bHQgPSBwYXJ0aWFsQ29tcGFyZShsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xyXG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcclxuICB9LFxyXG4gIGluOiBhc3luYyBmdW5jdGlvbiBpbm9wKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAocmlnaHQudHlwZSA9PT0gXCJwYXRoXCIpIHtcclxuICAgICAgaWYgKGxlZnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByaWdodC5kYXRhLm1hdGNoZXMobGVmdC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmIChyaWdodC5pc0FycmF5KCkpIHtcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHJpZ2h0KSB7XHJcbiAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpIHtcclxuICAgICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9LFxyXG4gIG1hdGNoOiBhc3luYyBmdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xyXG4gICAgbGV0IHRva2VucyA9IFtdO1xyXG4gICAgbGV0IHBhdHRlcm5zID0gW107XHJcbiAgICBhd2FpdCBnYXRoZXJUZXh0KGxlZnQsIChwYXJ0KSA9PiB7XHJcbiAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQobWF0Y2hUb2tlbml6ZShwYXJ0KSk7XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHJpZ2h0LCAocGFydCkgPT4ge1xyXG4gICAgICBwYXR0ZXJucyA9IHBhdHRlcm5zLmNvbmNhdChtYXRjaEFuYWx5emVQYXR0ZXJuKHBhcnQpKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKCFkaWRTdWNjZWVkKSB7XHJcbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcclxuICAgIH1cclxuICAgIGNvbnN0IG1hdGNoZWQgPSBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XHJcbiAgICByZXR1cm4gbWF0Y2hlZCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcclxuICB9LFxyXG4gIFwiK1wiOiBmdW5jdGlvbiBwbHVzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJpbmdcIiAmJiByaWdodC50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJvYmplY3RcIiAmJiByaWdodC50eXBlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIHJldHVybiBmcm9tSlMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGxlZnQuZGF0YSksIHJpZ2h0LmRhdGEpKTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiYXJyYXlcIiAmJiByaWdodC50eXBlID09PSBcImFycmF5XCIpIHtcclxuICAgICAgcmV0dXJuIGZyb21KUyhsZWZ0LmRhdGEuY29uY2F0KHJpZ2h0LmRhdGEpKTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LmlzQXJyYXkoKSAmJiByaWdodC5pc0FycmF5KCkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpIHtcclxuICAgICAgICAgIHlpZWxkIHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpIHtcclxuICAgICAgICAgIHlpZWxkIHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfSxcclxuICBcIi1cIjogZnVuY3Rpb24gbWludXMobGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIikge1xyXG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhIC0gcmlnaHQuZGF0YSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9LFxyXG4gIFwiKlwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgKiBiKSxcclxuICBcIi9cIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhIC8gYiksXHJcbiAgXCIlXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAlIGIpLFxyXG4gIFwiKipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBNYXRoLnBvdyhhLCBiKSlcclxufTtcclxuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcclxuICByZXR1cm4gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBpbXBsKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XHJcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9O1xyXG59XHJcbmNsYXNzIFNjb3BlIHtcclxuICBjb25zdHJ1Y3RvcihwYXJhbXMsIHNvdXJjZSwgdmFsdWUsIGNvbnRleHQsIHBhcmVudCkge1xyXG4gICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xyXG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICB9XHJcbiAgY3JlYXRlTmVzdGVkKHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5pc0hpZGRlbikge1xyXG4gICAgICByZXR1cm4gbmV3IFNjb3BlKHRoaXMucGFyYW1zLCB0aGlzLnNvdXJjZSwgdmFsdWUsIHRoaXMuY29udGV4dCwgdGhpcy5wYXJlbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMpO1xyXG4gIH1cclxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcclxuICAgIHJlc3VsdC5pc0hpZGRlbiA9IHRydWU7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBldmFsdWF0ZShub2RlLCBzY29wZSwgZXhlY3V0ZSA9IGV2YWx1YXRlKSB7XHJcbiAgY29uc3QgZnVuYyA9IEVYRUNVVE9SU1tub2RlLnR5cGVdO1xyXG4gIHJldHVybiBmdW5jKG5vZGUsIHNjb3BlLCBleGVjdXRlKTtcclxufVxyXG5mdW5jdGlvbiBwcm9taXNlbGVzc0FwcGx5KHZhbHVlLCBjYikge1xyXG4gIGlmIChcInRoZW5cIiBpbiB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlLnRoZW4oY2IpO1xyXG4gIH1cclxuICByZXR1cm4gY2IodmFsdWUpO1xyXG59XHJcbmNvbnN0IEVYRUNVVE9SUyA9IHtcclxuICBUaGlzKF8sIHNjb3BlKSB7XHJcbiAgICByZXR1cm4gc2NvcGUudmFsdWU7XHJcbiAgfSxcclxuICBFdmVyeXRoaW5nKF8sIHNjb3BlKSB7XHJcbiAgICByZXR1cm4gc2NvcGUuc291cmNlO1xyXG4gIH0sXHJcbiAgUGFyYW1ldGVyKHsgbmFtZSB9LCBzY29wZSkge1xyXG4gICAgcmV0dXJuIGZyb21KUyhzY29wZS5wYXJhbXNbbmFtZV0pO1xyXG4gIH0sXHJcbiAgQ29udGV4dCh7IGtleSB9LCBzY29wZSkge1xyXG4gICAgaWYgKGtleSA9PT0gXCJiZWZvcmVcIiB8fCBrZXkgPT09IFwiYWZ0ZXJcIikge1xyXG4gICAgICBjb25zdCB2YWx1ZSA9IHNjb3BlLmNvbnRleHRba2V5XTtcclxuICAgICAgcmV0dXJuIHZhbHVlIHx8IE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gY29udGV4dCBrZXk6ICR7a2V5fWApO1xyXG4gIH0sXHJcbiAgUGFyZW50KHsgbiB9LCBzY29wZSkge1xyXG4gICAgbGV0IGN1cnJlbnQgPSBzY29wZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHtcclxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgICAgfVxyXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcclxuICB9LFxyXG4gIE9wQ2FsbCh7IG9wLCBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgZnVuYyA9IG9wZXJhdG9yc1tvcF07XHJcbiAgICBpZiAoIWZ1bmMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke29wfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSk7XHJcbiAgICBjb25zdCByaWdodFZhbHVlID0gZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xyXG4gICAgaWYgKFwidGhlblwiIGluIGxlZnRWYWx1ZSB8fCBcInRoZW5cIiBpbiByaWdodFZhbHVlKSB7XHJcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4gZnVuYyhhd2FpdCBsZWZ0VmFsdWUsIGF3YWl0IHJpZ2h0VmFsdWUpKSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmMobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcclxuICB9LFxyXG4gIGFzeW5jIFNlbGVjdCh7IGFsdGVybmF0aXZlcywgZmFsbGJhY2sgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGZvciAoY29uc3QgYWx0IG9mIGFsdGVybmF0aXZlcykge1xyXG4gICAgICBjb25zdCBhbHRDb25kID0gYXdhaXQgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSk7XHJcbiAgICAgIGlmIChhbHRDb25kLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGFsdENvbmQuZGF0YSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBleGVjdXRlKGFsdC52YWx1ZSwgc2NvcGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZmFsbGJhY2spIHtcclxuICAgICAgcmV0dXJuIGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH0sXHJcbiAgYXN5bmMgSW5SYW5nZSh7IGJhc2UsIGxlZnQsIHJpZ2h0LCBpc0luY2x1c2l2ZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xyXG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcclxuICAgIGNvbnN0IGxlZnRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgbGVmdFZhbHVlLmdldCgpKTtcclxuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XHJcbiAgICBpZiAocmlnaHRDbXAgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbmNsdXNpdmUpIHtcclxuICAgICAgcmV0dXJuIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnRDbXAgPj0gMCAmJiByaWdodENtcCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XHJcbiAgfSxcclxuICBhc3luYyBGaWx0ZXIoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGJhc2VWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGVsZW0pO1xyXG4gICAgICAgIGNvbnN0IGV4cHJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xyXG4gICAgICAgIGlmIChleHByVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgZXhwclZhbHVlLmRhdGEgPT09IHRydWUpIHtcclxuICAgICAgICAgIHlpZWxkIGVsZW07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIGFzeW5jIFByb2plY3Rpb24oeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIGlmIChiYXNlVmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKGJhc2VWYWx1ZSk7XHJcbiAgICByZXR1cm4gZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XHJcbiAgfSxcclxuICBGdW5jQ2FsbCh7IGZ1bmMsIGFyZ3MgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcclxuICB9LFxyXG4gIGFzeW5jIFBpcGVGdW5jQ2FsbCh7IGZ1bmMsIGJhc2UsIGFyZ3MgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xyXG4gICAgcmV0dXJuIGZ1bmMoYmFzZVZhbHVlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSk7XHJcbiAgfSxcclxuICBhc3luYyBBY2Nlc3NBdHRyaWJ1dGUoeyBiYXNlLCBuYW1lIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBsZXQgdmFsdWUgPSBzY29wZS52YWx1ZTtcclxuICAgIGlmIChiYXNlKSB7XHJcbiAgICAgIHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICBpZiAodmFsdWUuZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tSlModmFsdWUuZGF0YVtuYW1lXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH0sXHJcbiAgYXN5bmMgQWNjZXNzRWxlbWVudCh7IGJhc2UsIGluZGV4IH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XHJcbiAgICBjb25zdCBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xyXG4gICAgcmV0dXJuIGZyb21KUyhkYXRhW2ZpbmFsSW5kZXhdKTtcclxuICB9LFxyXG4gIGFzeW5jIFNsaWNlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFycmF5ID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpO1xyXG4gICAgbGV0IGxlZnRJZHggPSBsZWZ0O1xyXG4gICAgbGV0IHJpZ2h0SWR4ID0gcmlnaHQ7XHJcbiAgICBpZiAobGVmdElkeCA8IDApIHtcclxuICAgICAgbGVmdElkeCA9IGFycmF5Lmxlbmd0aCArIGxlZnRJZHg7XHJcbiAgICB9XHJcbiAgICBpZiAocmlnaHRJZHggPCAwKSB7XHJcbiAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbmNsdXNpdmUpIHtcclxuICAgICAgcmlnaHRJZHgrKztcclxuICAgIH1cclxuICAgIGlmIChsZWZ0SWR4IDwgMCkge1xyXG4gICAgICBsZWZ0SWR4ID0gMDtcclxuICAgIH1cclxuICAgIGlmIChyaWdodElkeCA8IDApIHtcclxuICAgICAgcmlnaHRJZHggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZyb21KUyhhcnJheS5zbGljZShsZWZ0SWR4LCByaWdodElkeCkpO1xyXG4gIH0sXHJcbiAgYXN5bmMgRGVyZWYoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xyXG4gICAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcclxuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBzY29wZS5zb3VyY2UpIHtcclxuICAgICAgaWYgKGRvYy50eXBlID09PSBcIm9iamVjdFwiICYmIGlkID09PSBkb2MuZGF0YS5faWQpIHtcclxuICAgICAgICByZXR1cm4gZG9jO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9LFxyXG4gIFZhbHVlKHsgdmFsdWUgfSkge1xyXG4gICAgcmV0dXJuIGZyb21KUyh2YWx1ZSk7XHJcbiAgfSxcclxuICBHcm91cCh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIHJldHVybiBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICB9LFxyXG4gIGFzeW5jIE9iamVjdCh7IGF0dHJpYnV0ZXMgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgY29uc3QgYXR0clR5cGUgPSBhdHRyLnR5cGU7XHJcbiAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCI6IHtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XHJcbiAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6IHtcclxuICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XHJcbiAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSBcImJvb2xlYW5cIiB8fCBjb25kLmRhdGEgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcclxuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiT2JqZWN0U3BsYXRcIjoge1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcclxuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZTogJHthdHRyVHlwZX1gKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZyb21KUyhyZXN1bHQpO1xyXG4gIH0sXHJcbiAgQXJyYXkoeyBlbGVtZW50cyB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZWxlbWVudC52YWx1ZSwgc2NvcGUpO1xyXG4gICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcclxuICAgICAgICAgIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcclxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2IG9mIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgeWllbGQgdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5aWVsZCB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgVHVwbGUoKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXBsZXMgY2FuIG5vdCBiZSBldmFsdWF0ZWRcIik7XHJcbiAgfSxcclxuICBhc3luYyBPcih7IGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcclxuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XHJcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcclxuICB9LFxyXG4gIGFzeW5jIEFuZCh7IGxlZnQsIHJpZ2h0IH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcclxuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XHJcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIGlmIChsZWZ0VmFsdWUuZGF0YSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVFJVRV9WQUxVRTtcclxuICB9LFxyXG4gIGFzeW5jIE5vdCh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcclxuICB9LFxyXG4gIE5lZyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHtcclxuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUuZGF0YSk7XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIFBvcyh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHtcclxuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZnJvbU51bWJlcih2YWx1ZS5kYXRhKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgQXNjKCkge1xyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfSxcclxuICBEZXNjKCkge1xyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfSxcclxuICBhc3luYyBBcnJheUNvZXJjZSh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICByZXR1cm4gdmFsdWUuaXNBcnJheSgpID8gdmFsdWUgOiBOVUxMX1ZBTFVFO1xyXG4gIH0sXHJcbiAgYXN5bmMgTWFwKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xyXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKTtcclxuICAgICAgICB5aWVsZCBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBhc3luYyBGbGF0TWFwKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xyXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZUhpZGRlbihlbGVtKTtcclxuICAgICAgICBjb25zdCBpbm5lclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XHJcbiAgICAgICAgaWYgKGlubmVyVmFsdWUuaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGlubmVyIG9mIGlubmVyVmFsdWUpIHtcclxuICAgICAgICAgICAgeWllbGQgaW5uZXI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHlpZWxkIGlubmVyVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgY29uc3Qgcm9vdCA9IGZyb21KUyhvcHRpb25zLnJvb3QpO1xyXG4gIGNvbnN0IGRhdGFzZXQgPSBmcm9tSlMob3B0aW9ucy5kYXRhc2V0KTtcclxuICBjb25zdCBwYXJhbXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy5wYXJhbXMpO1xyXG4gIGNvbnN0IHNjb3BlID0gbmV3IFNjb3BlKHBhcmFtcywgZGF0YXNldCwgcm9vdCwge1xyXG4gICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCBuZXcgRGF0ZSgpLFxyXG4gICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXHJcbiAgICBzYW5pdHk6IG9wdGlvbnMuc2FuaXR5LFxyXG4gICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxyXG4gICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsXHJcbiAgfSwgbnVsbCk7XHJcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcclxufVxyXG5mdW5jdGlvbiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpIHtcclxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgY2FzZSBcIkdyb3VwXCI6XHJcbiAgICBjYXNlIFwiVmFsdWVcIjpcclxuICAgIGNhc2UgXCJQYXJhbWV0ZXJcIjpcclxuICAgIGNhc2UgXCJQb3NcIjpcclxuICAgIGNhc2UgXCJOZWdcIjpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBjYXNlIFwiT3BDYWxsXCI6XHJcbiAgICAgIHN3aXRjaCAobm9kZS5vcCkge1xyXG4gICAgICAgIGNhc2UgXCIrXCI6XHJcbiAgICAgICAgY2FzZSBcIi1cIjpcclxuICAgICAgICBjYXNlIFwiKlwiOlxyXG4gICAgICAgIGNhc2UgXCIvXCI6XHJcbiAgICAgICAgY2FzZSBcIiVcIjpcclxuICAgICAgICBjYXNlIFwiKipcIjpcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuY29uc3QgRFVNTVlfU0NPUEUgPSBuZXcgU2NvcGUoe30sIE5VTExfVkFMVUUsIE5VTExfVkFMVUUsIHsgdGltZXN0YW1wOiBuZXcgRGF0ZSgwKSwgaWRlbnRpdHk6IFwibWVcIiwgYmVmb3JlOiBudWxsLCBhZnRlcjogbnVsbCB9LCBudWxsKTtcclxuY2xhc3MgQ29uc3RhbnRFdmFsdWF0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgIHRoaXMubmFtZSA9IFwiQ29uc3RhbnRFdmFsdWF0ZUVycm9yXCI7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gY29uc3RhbnRFdmFsdWF0ZShub2RlKTtcclxuICB9IGNhdGNoIChlcnIpIHtcclxuICAgIGlmIChlcnIubmFtZSA9PT0gXCJDb25zdGFudEV2YWx1YXRlRXJyb3JcIikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHRocm93IGVycjtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XHJcbiAgaWYgKCFjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUpKSB7XHJcbiAgICB0aHJvdyBuZXcgQ29uc3RhbnRFdmFsdWF0ZUVycm9yKFwiY2Fubm90IGNvbnN0YW50IGV2YWx1YXRlXCIpO1xyXG4gIH1cclxuICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRlKG5vZGUsIERVTU1ZX1NDT1BFLCBjb25zdGFudEV2YWx1YXRlKTtcclxuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogY29uc3RhbnQgZXZhbHVhdGUgc2hvdWxkIG5ldmVyIHJldHVybiBhIHByb21pc2VcIik7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5jb25zdCBFU0NBUEVfU0VRVUVOQ0UgPSB7XHJcbiAgXCInXCI6IFwiJ1wiLFxyXG4gICdcIic6ICdcIicsXHJcbiAgXCJcXFxcXCI6IFwiXFxcXFwiLFxyXG4gIFwiL1wiOiBcIi9cIixcclxuICBiOiBcIlxcYlwiLFxyXG4gIGY6IFwiXFxmXCIsXHJcbiAgbjogXCJcXG5cIixcclxuICByOiBcIlxcclwiLFxyXG4gIHQ6IFwiXHRcIlxyXG59O1xyXG5mdW5jdGlvbiBleHBhbmRIZXgoc3RyKSB7XHJcbiAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChzdHIsIDE2KTtcclxuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XHJcbn1cclxuY2xhc3MgR3JvcVF1ZXJ5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJHcm9xUXVlcnlFcnJvclwiO1xyXG4gIH1cclxufVxyXG5jb25zdCBFWFBSX0JVSUxERVIgPSB7XHJcbiAgZ3JvdXAocCkge1xyXG4gICAgY29uc3QgaW5uZXIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiR3JvdXBcIixcclxuICAgICAgYmFzZTogaW5uZXJcclxuICAgIH07XHJcbiAgfSxcclxuICBldmVyeXRoaW5nKCkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJFdmVyeXRoaW5nXCIgfTtcclxuICB9LFxyXG4gIHRoaXMoKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcIlRoaXNcIiB9O1xyXG4gIH0sXHJcbiAgcGFyZW50KCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJQYXJlbnRcIixcclxuICAgICAgbjogMVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGRibHBhcmVudChwKSB7XHJcbiAgICBjb25zdCBuZXh0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxyXG4gICAgICBuOiBuZXh0Lm4gKyAxXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgdHJhdmVyc2UocCkge1xyXG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgY29uc3QgdHJhdmVyc2FsTGlzdCA9IFtdO1xyXG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiKSB7XHJcbiAgICAgIHRyYXZlcnNhbExpc3QucHVzaChwLnByb2Nlc3MoVFJBVkVSU0VfQlVJTERFUikpO1xyXG4gICAgfVxyXG4gICAgcC5zaGlmdCgpO1xyXG4gICAgbGV0IHRyYXZlcnNhbCA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gdHJhdmVyc2FsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzYWxMaXN0W2ldKHRyYXZlcnNhbCk7XHJcbiAgICB9XHJcbiAgICBpZiAoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpIHtcclxuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2VBcnJheSgodmFsKSA9PiB2YWwsIHRyYXZlcnNhbCk7XHJcbiAgICB9XHJcbiAgICBpZiAodHJhdmVyc2FsID09PSBudWxsKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IHVuZXhwZWN0ZWQgZW1wdHkgdHJhdmVyc2FsXCIpO1xyXG4gICAgcmV0dXJuIHRyYXZlcnNhbC5idWlsZChiYXNlKTtcclxuICB9LFxyXG4gIHRoaXNfYXR0cihwKSB7XHJcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XHJcbiAgICBpZiAobmFtZSA9PT0gXCJudWxsXCIpIHtcclxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogbnVsbCB9O1xyXG4gICAgfVxyXG4gICAgaWYgKG5hbWUgPT09IFwidHJ1ZVwiKSB7XHJcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IHRydWUgfTtcclxuICAgIH1cclxuICAgIGlmIChuYW1lID09PSBcImZhbHNlXCIpIHtcclxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZTogZmFsc2UgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXHJcbiAgICAgIG5hbWVcclxuICAgIH07XHJcbiAgfSxcclxuICBuZWcocCkge1xyXG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJOZWdcIixcclxuICAgICAgYmFzZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHBvcyhwKSB7XHJcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIlBvc1wiLFxyXG4gICAgICBiYXNlXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgYWRkKHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxyXG4gICAgICBvcDogXCIrXCIsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgc3ViKHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxyXG4gICAgICBvcDogXCItXCIsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgbXVsKHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxyXG4gICAgICBvcDogXCIqXCIsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZGl2KHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxyXG4gICAgICBvcDogXCIvXCIsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgbW9kKHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxyXG4gICAgICBvcDogXCIlXCIsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgcG93KHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxyXG4gICAgICBvcDogXCIqKlwiLFxyXG4gICAgICBsZWZ0LFxyXG4gICAgICByaWdodFxyXG4gICAgfTtcclxuICB9LFxyXG4gIGNvbXAocCkge1xyXG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgY29uc3Qgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxyXG4gICAgICBvcCxcclxuICAgICAgbGVmdCxcclxuICAgICAgcmlnaHRcclxuICAgIH07XHJcbiAgfSxcclxuICBpbl9yYW5nZShwKSB7XHJcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XHJcbiAgICBwLnNoaWZ0KCk7XHJcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJJblJhbmdlXCIsXHJcbiAgICAgIGJhc2UsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0LFxyXG4gICAgICBpc0luY2x1c2l2ZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHN0cihwKSB7XHJcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xyXG4gICAgbG9vcDpcclxuICAgICAgd2hpbGUgKHAuaGFzTWFyaygpKSB7XHJcbiAgICAgICAgY29uc3QgbWFyayA9IHAuZ2V0TWFyaygpO1xyXG4gICAgICAgIHN3aXRjaCAobWFyay5uYW1lKSB7XHJcbiAgICAgICAgICBjYXNlIFwic3RyX2VuZFwiOlxyXG4gICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIGNhc2UgXCJzdHJfcGF1c2VcIjpcclxuICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcInN0cl9zdGFydFwiOlxyXG4gICAgICAgICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBcInNpbmdsZV9lc2NhcGVcIjoge1xyXG4gICAgICAgICAgICBjb25zdCBjaGFyID0gcC5zbGljZSgxKTtcclxuICAgICAgICAgICAgcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICB2YWx1ZSArPSBFU0NBUEVfU0VRVUVOQ0VbY2hhcl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XHJcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgdmFsdWUgKz0gZXhwYW5kSGV4KHAucHJvY2Vzc1N0cmluZ0VuZCgpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgbWFyazogJHttYXJrLm5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlIH07XHJcbiAgfSxcclxuICBpbnRlZ2VyKHApIHtcclxuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXHJcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZmxvYXQocCkge1xyXG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcclxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcclxuICAgIH07XHJcbiAgfSxcclxuICBzY2kocCkge1xyXG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcclxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcclxuICAgIH07XHJcbiAgfSxcclxuICBvYmplY3QocCkge1xyXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xyXG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwib2JqZWN0X2VuZFwiKSB7XHJcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcclxuICAgIH1cclxuICAgIHAuc2hpZnQoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiT2JqZWN0XCIsXHJcbiAgICAgIGF0dHJpYnV0ZXNcclxuICAgIH07XHJcbiAgfSxcclxuICBhcnJheShwKSB7XHJcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xyXG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiYXJyYXlfZW5kXCIpIHtcclxuICAgICAgbGV0IGlzU3BsYXQgPSBmYWxzZTtcclxuICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiYXJyYXlfc3BsYXRcIikge1xyXG4gICAgICAgIGlzU3BsYXQgPSB0cnVlO1xyXG4gICAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgICBlbGVtZW50cy5wdXNoKHtcclxuICAgICAgICB0eXBlOiBcIkFycmF5RWxlbWVudFwiLFxyXG4gICAgICAgIHZhbHVlLFxyXG4gICAgICAgIGlzU3BsYXRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBwLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIkFycmF5XCIsXHJcbiAgICAgIGVsZW1lbnRzXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgdHVwbGUocCkge1xyXG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xyXG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCIpIHtcclxuICAgICAgbWVtYmVycy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcclxuICAgIH1cclxuICAgIHAuc2hpZnQoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiVHVwbGVcIixcclxuICAgICAgbWVtYmVyc1xyXG4gICAgfTtcclxuICB9LFxyXG4gIGZ1bmNfY2FsbChwKSB7XHJcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcclxuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XHJcbiAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XHJcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwic2VsZWN0XCIpIHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHR5cGU6IFwiU2VsZWN0XCIsXHJcbiAgICAgICAgYWx0ZXJuYXRpdmVzOiBbXVxyXG4gICAgICB9O1xyXG4gICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcclxuICAgICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcclxuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgdW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKWApO1xyXG4gICAgICAgICAgcC5zaGlmdCgpO1xyXG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgICAgICAgcmVzdWx0LmFsdGVybmF0aXZlcy5wdXNoKHtcclxuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxyXG4gICAgICAgICAgICBjb25kaXRpb24sXHJcbiAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGB1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpYCk7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcclxuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xyXG4gICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xyXG4gICAgfVxyXG4gICAgcC5zaGlmdCgpO1xyXG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiAobmFtZSA9PT0gXCJiZWZvcmVcIiB8fCBuYW1lID09PSBcImFmdGVyXCIpKSB7XHJcbiAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5tb2RlID09PSBcImRlbHRhXCIpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgdHlwZTogXCJDb250ZXh0XCIsXHJcbiAgICAgICAgICBrZXk6IG5hbWVcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KVxyXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0XCIpO1xyXG4gICAgY29uc3QgZnVuY3MgPSBuYW1lc3BhY2VzW25hbWVzcGFjZV07XHJcbiAgICBpZiAoIWZ1bmNzKSB7XHJcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmdW5jID0gZnVuY3NbbmFtZV07XHJcbiAgICBpZiAoIWZ1bmMpIHtcclxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIGlmIChmdW5jLmFyaXR5ICE9PSB2b2lkIDApIHtcclxuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZnVuYy5tb2RlICE9PSB2b2lkIDAgJiYgZnVuYy5tb2RlICE9PSBwLnBhcnNlT3B0aW9ucy5tb2RlKSB7XHJcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIkZ1bmNDYWxsXCIsXHJcbiAgICAgIGZ1bmMsXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGFyZ3NcclxuICAgIH07XHJcbiAgfSxcclxuICBwaXBlY2FsbChwKSB7XHJcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBwLnNoaWZ0KCk7XHJcbiAgICBsZXQgbmFtZXNwYWNlID0gXCJnbG9iYWxcIjtcclxuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XHJcbiAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgbmFtZXNwYWNlID0gcC5wcm9jZXNzU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZXNwYWNlICE9PSBcImdsb2JhbFwiKSB7XHJcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIG5hbWVzcGFjZTogJHtuYW1lc3BhY2V9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XHJcbiAgICBjb25zdCBhcmdzID0gW107XHJcbiAgICBjb25zdCBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xyXG4gICAgaWYgKG5hbWUgPT09IFwic2NvcmVcIikge1xyXG4gICAgICBwLmFsbG93Qm9vc3QgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZm9yICg7IDsgKSB7XHJcbiAgICAgIGNvbnN0IG1hcmtOYW1lID0gcC5nZXRNYXJrKCkubmFtZTtcclxuICAgICAgaWYgKG1hcmtOYW1lID09PSBcImZ1bmNfYXJnc19lbmRcIikge1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuYW1lID09PSBcIm9yZGVyXCIpIHtcclxuICAgICAgICBpZiAobWFya05hbWUgPT09IFwiYXNjXCIpIHtcclxuICAgICAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6IFwiQXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtYXJrTmFtZSA9PT0gXCJkZXNjXCIpIHtcclxuICAgICAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6IFwiRGVzY1wiLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBhcmdzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xyXG4gICAgfVxyXG4gICAgcC5zaGlmdCgpO1xyXG4gICAgcC5hbGxvd0Jvb3N0ID0gb2xkQWxsb3dCb29zdDtcclxuICAgIGNvbnN0IGZ1bmMgPSBwaXBlRnVuY3Rpb25zW25hbWVdO1xyXG4gICAgaWYgKCFmdW5jKSB7XHJcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIHBpcGUgZnVuY3Rpb246ICR7bmFtZX1gKTtcclxuICAgIH1cclxuICAgIGlmIChmdW5jLmFyaXR5KSB7XHJcbiAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJQaXBlRnVuY0NhbGxcIixcclxuICAgICAgZnVuYyxcclxuICAgICAgYmFzZSxcclxuICAgICAgbmFtZSxcclxuICAgICAgYXJnc1xyXG4gICAgfTtcclxuICB9LFxyXG4gIHBhaXIocCkge1xyXG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGB1bmV4cGVjdGVkID0+YCk7XHJcbiAgfSxcclxuICBhbmQocCkge1xyXG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiQW5kXCIsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgb3IocCkge1xyXG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiT3JcIixcclxuICAgICAgbGVmdCxcclxuICAgICAgcmlnaHRcclxuICAgIH07XHJcbiAgfSxcclxuICBub3QocCkge1xyXG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJOb3RcIixcclxuICAgICAgYmFzZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGFzYyhwKSB7XHJcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFzY1wiKTtcclxuICB9LFxyXG4gIGRlc2MocCkge1xyXG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBkZXNjXCIpO1xyXG4gIH0sXHJcbiAgcGFyYW0ocCkge1xyXG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xyXG4gICAgaWYgKHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXHJcbiAgICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJQYXJhbWV0ZXJcIixcclxuICAgICAgbmFtZVxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcbmNvbnN0IE9CSkVDVF9CVUlMREVSID0ge1xyXG4gIG9iamVjdF9leHByKHApIHtcclxuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xyXG4gICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgICBjb25zdCB2YWx1ZTIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcIk9iamVjdENvbmRpdGlvbmFsU3BsYXRcIixcclxuICAgICAgICBjb25kaXRpb24sXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlMlxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcclxuICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcclxuICAgICAgdmFsdWVcclxuICAgIH07XHJcbiAgfSxcclxuICBvYmplY3RfcGFpcihwKSB7XHJcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBpZiAobmFtZS50eXBlICE9PSBcIlZhbHVlXCIpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBzdHJpbmdcIik7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxyXG4gICAgICBuYW1lOiBuYW1lLnZhbHVlLFxyXG4gICAgICB2YWx1ZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIG9iamVjdF9zcGxhdChwKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxyXG4gICAgICB2YWx1ZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIG9iamVjdF9zcGxhdF90aGlzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxyXG4gICAgICB2YWx1ZTogeyB0eXBlOiBcIlRoaXNcIiB9XHJcbiAgICB9O1xyXG4gIH1cclxufTtcclxuY29uc3QgVFJBVkVSU0VfQlVJTERFUiA9IHtcclxuICBzcXVhcmVfYnJhY2tldChwKSB7XHJcbiAgICBjb25zdCBleHByID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCB2YWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUoZXhwcik7XHJcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZUVsZW1lbnQoKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzRWxlbWVudFwiLCBiYXNlLCBpbmRleDogdmFsdWUuZGF0YSB9KSwgcmlnaHQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogdmFsdWUuZGF0YSB9KSwgcmlnaHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHtcclxuICAgICAgdHlwZTogXCJGaWx0ZXJcIixcclxuICAgICAgYmFzZSxcclxuICAgICAgZXhwclxyXG4gICAgfSksIHJpZ2h0KTtcclxuICB9LFxyXG4gIHNsaWNlKHApIHtcclxuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcclxuICAgIHAuc2hpZnQoKTtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGxlZnQpO1xyXG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xyXG4gICAgaWYgKCFsZWZ0VmFsdWUgfHwgIXJpZ2h0VmFsdWUgfHwgbGVmdFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInNsaWNpbmcgbXVzdCB1c2UgY29uc3RhbnQgbnVtYmVyc1wiKTtcclxuICAgIH1cclxuICAgIHJldHVybiAocmhzKSA9PiB0cmF2ZXJzZUFycmF5KChiYXNlKSA9PiAoe1xyXG4gICAgICB0eXBlOiBcIlNsaWNlXCIsXHJcbiAgICAgIGJhc2UsXHJcbiAgICAgIGxlZnQ6IGxlZnRWYWx1ZS5kYXRhLFxyXG4gICAgICByaWdodDogcmlnaHRWYWx1ZS5kYXRhLFxyXG4gICAgICBpc0luY2x1c2l2ZVxyXG4gICAgfSksIHJocyk7XHJcbiAgfSxcclxuICBwcm9qZWN0aW9uKHApIHtcclxuICAgIGNvbnN0IG9iaiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQcm9qZWN0aW9uKChiYXNlKSA9PiAoeyB0eXBlOiBcIlByb2plY3Rpb25cIiwgYmFzZSwgZXhwcjogb2JqIH0pLCByaWdodCk7XHJcbiAgfSxcclxuICBhdHRyX2FjY2VzcyhwKSB7XHJcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XHJcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lIH0pLCByaWdodCk7XHJcbiAgfSxcclxuICBkZXJlZihwKSB7XHJcbiAgICBsZXQgYXR0ciA9IG51bGw7XHJcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJkZXJlZl9hdHRyXCIpIHtcclxuICAgICAgcC5zaGlmdCgpO1xyXG4gICAgICBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3cmFwID0gKGJhc2UpID0+IGF0dHIgPyB7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IGF0dHIgfSA6IGJhc2U7XHJcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiB3cmFwKHtcclxuICAgICAgdHlwZTogXCJEZXJlZlwiLFxyXG4gICAgICBiYXNlXHJcbiAgICB9KSwgcmlnaHQpO1xyXG4gIH0sXHJcbiAgYXJyYXlfcG9zdGZpeChwKSB7XHJcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFycmF5Q29lcmNlXCIsIGJhc2UgfSksIHJpZ2h0KTtcclxuICB9XHJcbn07XHJcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlKSB7XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NBdHRyaWJ1dGVcIiAmJiAhbm9kZS5iYXNlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xyXG4gIH1cclxuICBpZiAobm9kZS50eXBlID09PSBcIkRlcmVmXCIgfHwgbm9kZS50eXBlID09PSBcIk1hcFwiIHx8IG5vZGUudHlwZSA9PT0gXCJQcm9qZWN0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlNsaWNlXCIgfHwgbm9kZS50eXBlID09PSBcIkZpbHRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NFbGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkFycmF5Q29lcmNlXCIpIHtcclxuICAgIHJldHVybiBleHRyYWN0UHJvcGVydHlLZXkobm9kZS5iYXNlKTtcclxuICB9XHJcbiAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBDYW5ub3QgZGV0ZXJtaW5lIHByb3BlcnR5IGtleSBmb3IgdHlwZTogJHtub2RlLnR5cGV9YCk7XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQyKSB7XHJcbiAgaWYgKHR5cGVvZiBhcml0eSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgaWYgKGNvdW50MiAhPT0gYXJpdHkpIHtcclxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuIEV4cGVjdGVkICR7YXJpdHl9LCBnb3QgJHtjb3VudDJ9LmApO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoYXJpdHkpIHtcclxuICAgIGlmICghYXJpdHkoY291bnQyKSkge1xyXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYEluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGZ1bmN0aW9uICR7bmFtZX0oKS5gKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuY2xhc3MgR3JvcVN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uKSB7XHJcbiAgICBzdXBlcihgU3ludGF4IGVycm9yIGluIEdST1EgcXVlcnkgYXQgcG9zaXRpb24gJHtwb3NpdGlvbn1gKTtcclxuICAgIHRoaXMubmFtZSA9IFwiR3JvcVN5bnRheEVycm9yXCI7XHJcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcclxuICBjb25zdCByZXN1bHQgPSBwYXJzZSQxKGlucHV0KTtcclxuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikge1xyXG4gICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24pO1xyXG4gIH1cclxuICBjb25zdCBwcm9jZXNzb3IgPSBuZXcgTWFya1Byb2Nlc3NvcihpbnB1dCwgcmVzdWx0Lm1hcmtzLCBvcHRpb25zKTtcclxuICByZXR1cm4gcHJvY2Vzc29yLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxufVxyXG5leHBvcnQgeyBldmFsdWF0ZVF1ZXJ5IGFzIGV2YWx1YXRlLCBwYXJzZSB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm9xLWpzLmVzbS5qcy5tYXBcclxuIiwiaW1wb3J0IHsgUGF0Y2hlciB9IGZyb20gJy4vaW50ZXJuYWwtcGF0Y2hlcic7XHJcbmltcG9ydCB7IHV0ZjhjaGFyU2l6ZSwgdXRmOHN0cmluZ1NpemUsIGNvbW1vblByZWZpeCwgY29tbW9uU3VmZml4IH0gZnJvbSAnLi91dGY4JztcclxudmFyIE1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTW9kZWwobWV0YSkge1xyXG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XHJcbiAgICB9XHJcbiAgICBNb2RlbC5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcFdpdGhNZXRhKGRhdGEsIHRoaXMubWV0YSwgdGhpcy5tZXRhKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUud3JhcFdpdGhNZXRhID0gZnVuY3Rpb24gKGRhdGEsIHN0YXJ0TWV0YSwgZW5kTWV0YSkge1xyXG4gICAgICAgIGlmIChlbmRNZXRhID09PSB2b2lkIDApIHsgZW5kTWV0YSA9IHRoaXMubWV0YTsgfVxyXG4gICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN0YXJ0TWV0YTogc3RhcnRNZXRhLCBlbmRNZXRhOiBlbmRNZXRhIH07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlLmRhdGEpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IHRoaXMud3JhcFdpdGhNZXRhKHZhbCwgdmFsdWUuc3RhcnRNZXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0geyB0eXBlOiAnb2JqZWN0JywgZmllbGRzOiBmaWVsZHMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB2YWx1ZS5kYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gX3RoaXMud3JhcFdpdGhNZXRhKGl0ZW0sIHZhbHVlLnN0YXJ0TWV0YSk7IH0pO1xyXG4gICAgICAgICAgICB2YXIgbWV0YXMgPSBlbGVtZW50cy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWV0YTsgfSk7XHJcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB7IHR5cGU6ICdhcnJheScsIGVsZW1lbnRzOiBlbGVtZW50cywgbWV0YXM6IG1ldGFzIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5hc1N0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICB2YXIgc3RyID0gdmFsdWUuZGF0YTtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RyLFxyXG4gICAgICAgICAgICAgICAgdXRmOHNpemU6IHV0ZjhzdHJpbmdTaXplKHN0ciksXHJcbiAgICAgICAgICAgICAgICB1c2VzOiBbXSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0TWV0YTogdmFsdWUuc3RhcnRNZXRhLFxyXG4gICAgICAgICAgICAgICAgZW5kTWV0YTogdmFsdWUuZW5kTWV0YVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0gdGhpcy5zdHJpbmdGcm9tUGFydHMoW3BhcnRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0Zyb21QYXJ0cyA9IGZ1bmN0aW9uIChwYXJ0cykge1xyXG4gICAgICAgIHZhciBzdHIgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgICAgICAgICBwYXJ0czogcGFydHNcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcGFydHNfMSA9IHBhcnRzOyBfaSA8IHBhcnRzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XHJcbiAgICAgICAgICAgIHBhcnQudXNlcy5wdXNoKHN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdEdldEtleXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUuY29udGVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuY29udGVudC5maWVsZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0R2V0RmllbGQgPSBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gb2JqLmZpZWxkc1trZXldO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUdldEVsZW1lbnQgPSBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xyXG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmFzQXJyYXkodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBhcnIuZWxlbWVudHNbaWR4XTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY29udGVudCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlRW5kTWV0YShjb250ZW50KTtcclxuICAgICAgICByZXR1cm4geyBjb250ZW50OiBjb250ZW50LCBzdGFydE1ldGE6IHRoaXMubWV0YSwgZW5kTWV0YTogdGhpcy5tZXRhIH07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLm1hcmtDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh1bndyYXAodmFsdWUpKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUudXBkYXRlRW5kTWV0YSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGVudC5wYXJ0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgcGFydC5lbmRNZXRhID0gdGhpcy5tZXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSAnYXJyYXknKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gY29udGVudC5lbGVtZW50czsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX2NbX2JdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kTWV0YSh2YWwuY29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IE9iamVjdC52YWx1ZXMoY29udGVudC5maWVsZHMpOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfZVtfZF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmNvcHlTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy5hc1N0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhvdGhlci5wYXJ0cy5zbGljZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcclxuICAgICAgICAgICAgICAgIHBhcnRzOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBvYmogPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxyXG4gICAgICAgICAgICBmaWVsZHM6IHt9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2JqLmZpZWxkcywgb3RoZXIuZmllbGRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weUFycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IHZhbHVlID8gdGhpcy5hc0FycmF5KHZhbHVlKSA6IG51bGw7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gYXJyID8gYXJyLmVsZW1lbnRzIDogW107XHJcbiAgICAgICAgdmFyIG1ldGFzID0gYXJyID8gYXJyLm1ldGFzIDogW107XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcclxuICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxyXG4gICAgICAgICAgICBtZXRhczogbWV0YXNcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RTZXRGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0YXJnZXQuZmllbGRzW2tleV0gPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICBkZWxldGUgdGFyZ2V0LmZpZWxkc1trZXldO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUFwcGVuZFZhbHVlID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcclxuICAgICAgICB0YXJnZXQuZWxlbWVudHMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgdGFyZ2V0Lm1ldGFzLnB1c2godGhpcy5tZXRhKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuYXJyYXlBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmFzQXJyYXkoc291cmNlKTtcclxuICAgICAgICB2YXIgc2FtZVBvc2l0aW9uID0gYXJyLmVsZW1lbnRzLmxlbmd0aCA9PT0gbGVmdDtcclxuICAgICAgICAoX2EgPSB0YXJnZXQuZWxlbWVudHMpLnB1c2guYXBwbHkoX2EsIGFyci5lbGVtZW50cy5zbGljZShsZWZ0LCByaWdodCkpO1xyXG4gICAgICAgIGlmIChzYW1lUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgKF9iID0gdGFyZ2V0Lm1ldGFzKS5wdXNoLmFwcGx5KF9iLCBhcnIubWV0YXMuc2xpY2UobGVmdCwgcmlnaHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZWZ0OyBpIDwgcmlnaHQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm1ldGFzLnB1c2godGhpcy5tZXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nQXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc3RyLnBhcnRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IF9hW19pXTtcclxuICAgICAgICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRQYXJ0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFydCkge1xyXG4gICAgICAgIHRhcmdldC5wYXJ0cy5wdXNoKHBhcnQpO1xyXG4gICAgICAgIHBhcnQudXNlcy5wdXNoKHRhcmdldCk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnJlc29sdmVTdHJpbmdQYXJ0ID0gZnVuY3Rpb24gKHN0ciwgZnJvbSwgbGVuKSB7XHJcbiAgICAgICAgaWYgKGxlbiA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGZyb207XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCBzdHIucGFydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBzdHIucGFydHNbaV07XHJcbiAgICAgICAgICAgIGlmIChsZW4gPT09IHBhcnQudXRmOHNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1hdGNoZXMgcGVyZmVjdCFcclxuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGVuIDwgcGFydC51dGY4c2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIHBhcnQgb2YgdGhpcyBjaHVuay4gV2Ugbm93IG5lZWQgdG8gc3BsaXQgaXQgdXAuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0U3RyaW5nKHBhcnQsIGxlbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuIC09IHBhcnQudXRmOHNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXR0aW5nIHN0cmluZyBvdXQgb2YgYm91bmRzJyk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnNwbGl0U3RyaW5nID0gZnVuY3Rpb24gKHBhcnQsIGlkeCkge1xyXG4gICAgICAgIHZhciBsZWZ0VmFsdWU7XHJcbiAgICAgICAgdmFyIHJpZ2h0VmFsdWU7XHJcbiAgICAgICAgdmFyIGxlZnRTaXplID0gaWR4O1xyXG4gICAgICAgIHZhciByaWdodFNpemUgPSBwYXJ0LnV0ZjhzaXplIC0gbGVmdFNpemU7XHJcbiAgICAgICAgLy8gaWR4IGlzIGhlcmUgaW4gVVRGLTggaW5kZXgsIG5vdCBjb2RlcG9pbnQgaW5kZXguXHJcbiAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBtaWdodCB0byBhZGp1c3QgZm9yIG11bHRpLWJ5dGUgY2hhcmFjdGVycy5cclxuICAgICAgICBpZiAocGFydC51dGY4c2l6ZSAhPT0gcGFydC52YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGJ5dGVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgYnl0ZUNvdW50IDwgbGVmdFNpemU7IGlkeCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHBhcnQudmFsdWUuY29kZVBvaW50QXQoaWR4KTtcclxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPT09IDQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWR4Kys7IC8vIFN1cnJvZ2F0ZSBwYWlyLlxyXG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGVmdFZhbHVlID0gcGFydC52YWx1ZS5zbGljZSgwLCBpZHgpO1xyXG4gICAgICAgIHJpZ2h0VmFsdWUgPSBwYXJ0LnZhbHVlLnNsaWNlKGlkeCk7XHJcbiAgICAgICAgdmFyIG5ld1BhcnQgPSB7XHJcbiAgICAgICAgICAgIHZhbHVlOiByaWdodFZhbHVlLFxyXG4gICAgICAgICAgICB1dGY4c2l6ZTogcmlnaHRTaXplLFxyXG4gICAgICAgICAgICB1c2VzOiBwYXJ0LnVzZXMuc2xpY2UoKSxcclxuICAgICAgICAgICAgc3RhcnRNZXRhOiBwYXJ0LnN0YXJ0TWV0YSxcclxuICAgICAgICAgICAgZW5kTWV0YTogcGFydC5lbmRNZXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICBwYXJ0LnZhbHVlID0gbGVmdFZhbHVlO1xyXG4gICAgICAgIHBhcnQudXRmOHNpemUgPSBsZWZ0U2l6ZTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcGFydC51c2VzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgdXNlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBwYXJ0LlxyXG4gICAgICAgICAgICB2YXIgaWR4XzEgPSB1c2UucGFydHMuaW5kZXhPZihwYXJ0KTtcclxuICAgICAgICAgICAgaWYgKGlkeF8xID09PSAtMSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYnVnOiBtaXNtYXRjaCBiZXR3ZWVuIHN0cmluZyBwYXJ0cyBhbmQgdXNlLicpO1xyXG4gICAgICAgICAgICB1c2UucGFydHMuc3BsaWNlKGlkeF8xICsgMSwgMCwgbmV3UGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5hc1N0cmluZyhzb3VyY2UpO1xyXG4gICAgICAgIHZhciBmaXJzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgMCwgbGVmdCk7XHJcbiAgICAgICAgdmFyIGxhc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIGZpcnN0UGFydCwgcmlnaHQgLSBsZWZ0KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQYXJ0OyBpIDwgbGFzdFBhcnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IHN0ci5wYXJ0c1tpXTtcclxuICAgICAgICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBNb2RlbDtcclxufSgpKTtcclxuLy8gVHVybnMgYSBuYXRpdmUgSmF2YVNjcmlwdCBvYmplY3QgaW50byBhIFZhbHVlIHdpdGggYSBnaXZlbiBvcmlnaW4uXHJcbmV4cG9ydCBmdW5jdGlvbiB3cmFwKGRhdGEsIG1ldGEpIHtcclxuICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN0YXJ0TWV0YTogbWV0YSwgZW5kTWV0YTogbWV0YSB9O1xyXG59XHJcbi8vIENvbnZlcnRzIGEgVmFsdWUgaW50byBhIG5hdGl2ZSBKYXZhU2NyaXB0IHR5cGUuXHJcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUuZGF0YSAhPT0gJ3VuZGVmaW5lZCcpXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmRhdGE7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgdmFyIGNvbnRlbnQgPSB2YWx1ZS5jb250ZW50O1xyXG4gICAgc3dpdGNoIChjb250ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICByZXN1bHQgPSBjb250ZW50LnBhcnRzLm1hcChmdW5jdGlvbiAocGFydCkgeyByZXR1cm4gcGFydC52YWx1ZTsgfSkuam9pbignJyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2FycmF5JzpcclxuICAgICAgICAgICAgcmVzdWx0ID0gY29udGVudC5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdW53cmFwKHZhbCk7IH0pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdvYmplY3QnOiB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXMoY29udGVudC5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHVud3JhcCh2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsdWUuZGF0YSA9IHJlc3VsdDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLy8gUmV0dXJucyB0aGUgdHlwZSBvZiBhIFZhbHVlLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlLmNvbnRlbnQpXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQudHlwZTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKVxyXG4gICAgICAgIHJldHVybiAnYXJyYXknO1xyXG4gICAgaWYgKHZhbHVlLmRhdGEgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUuZGF0YTtcclxufVxyXG4vLyBVcGRhdGVzIHRoZSBgcmlnaHRgIHZhbHVlIHN1Y2ggdGhhdCBpdCByZXVzZXMgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBgbGVmdGAgdmFsdWUuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWJhc2VWYWx1ZShsZWZ0LCByaWdodCkge1xyXG4gICAgdmFyIGxlZnRUeXBlID0gZ2V0VHlwZShsZWZ0KTtcclxuICAgIHZhciByaWdodFR5cGUgPSBnZXRUeXBlKHJpZ2h0KTtcclxuICAgIGlmIChsZWZ0VHlwZSAhPT0gcmlnaHRUeXBlKVxyXG4gICAgICAgIHJldHVybiByaWdodDtcclxuICAgIHZhciBsZWZ0TW9kZWwgPSBuZXcgTW9kZWwobGVmdC5lbmRNZXRhKTtcclxuICAgIHZhciByaWdodE1vZGVsID0gbmV3IE1vZGVsKHJpZ2h0LmVuZE1ldGEpO1xyXG4gICAgc3dpdGNoIChsZWZ0VHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcclxuICAgICAgICAgICAgdmFyIGxlZnRPYmogPSBsZWZ0TW9kZWwuYXNPYmplY3QobGVmdCk7XHJcbiAgICAgICAgICAgIHZhciByaWdodE9iaiA9IHJpZ2h0TW9kZWwuYXNPYmplY3QocmlnaHQpO1xyXG4gICAgICAgICAgICAvLyBOdW1iZXIgb2YgZmllbGRzIHdoaWNoIGFyZSBpZGVudGljYWwgaW4gbGVmdCBhbmQgcmlnaHQuXHJcbiAgICAgICAgICAgIHZhciBpZGVudGljYWxGaWVsZENvdW50ID0gMDtcclxuICAgICAgICAgICAgdmFyIGxlZnRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMobGVmdE9iai5maWVsZHMpLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0RmllbGRDb3VudCA9IE9iamVjdC5rZXlzKHJpZ2h0T2JqLmZpZWxkcykubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXMocmlnaHRPYmouZmllbGRzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHJpZ2h0VmFsID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFZhbCA9IGxlZnRPYmouZmllbGRzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAobGVmdFZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0T2JqLmZpZWxkc1trZXldID0gcmViYXNlVmFsdWUobGVmdFZhbCwgcmlnaHRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodE9iai5maWVsZHNba2V5XSA9PT0gbGVmdFZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGljYWxGaWVsZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc0lkZW50aWNhbCA9IGxlZnRGaWVsZENvdW50ID09PSByaWdodEZpZWxkQ291bnQgJiYgbGVmdEZpZWxkQ291bnQgPT09IGlkZW50aWNhbEZpZWxkQ291bnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0lkZW50aWNhbCA/IGxlZnQgOiByaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnYXJyYXknOiB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0QXJyID0gbGVmdE1vZGVsLmFzQXJyYXkobGVmdCk7XHJcbiAgICAgICAgICAgIHZhciByaWdodEFyciA9IHJpZ2h0TW9kZWwuYXNBcnJheShyaWdodCk7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0QXJyLmVsZW1lbnRzLmxlbmd0aCAhPT0gcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbnVtUmViYXNlZCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0QXJyLmVsZW1lbnRzW2ldID0gcmViYXNlVmFsdWUobGVmdEFyci5lbGVtZW50c1tpXSwgcmlnaHRBcnIuZWxlbWVudHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0QXJyLmVsZW1lbnRzW2ldICE9PSBsZWZ0QXJyLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtUmViYXNlZCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudW1SZWJhc2VkID09PSAwID8gbGVmdCA6IHJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdudWxsJzpcclxuICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICBjYXNlICdudW1iZXInOiB7XHJcbiAgICAgICAgICAgIGlmICh1bndyYXAobGVmdCkgPT09IHVud3JhcChyaWdodCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcclxuICAgICAgICAgICAgdmFyIGxlZnRSYXcgPSB1bndyYXAobGVmdCk7XHJcbiAgICAgICAgICAgIHZhciByaWdodFJhdyA9IHVud3JhcChyaWdodCk7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0UmF3ID09PSByaWdodFJhdylcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmlnaHRNb2RlbC5jb3B5U3RyaW5nKG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29tbW9uUHJlZml4KGxlZnRSYXcsIHJpZ2h0UmF3KTtcclxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IGNvbW1vblN1ZmZpeChsZWZ0UmF3LCByaWdodFJhdywgcHJlZml4KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0TGVuID0gdXRmOHN0cmluZ1NpemUocmlnaHRSYXcpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdExlbiA9IHV0ZjhzdHJpbmdTaXplKGxlZnRSYXcpO1xyXG4gICAgICAgICAgICBpZiAoMCA8IHByZWZpeCkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIDAsIHByZWZpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByZWZpeCA8IHJpZ2h0TGVuIC0gc3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgcmlnaHQsIHByZWZpeCwgcmlnaHRMZW4gLSBzdWZmaXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZWZ0TGVuIC0gc3VmZml4IDwgbGVmdExlbikge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIGxlZnRMZW4gLSBzdWZmaXgsIGxlZnRMZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJpZ2h0TW9kZWwuZmluYWxpemUocmVzdWx0KTtcclxuICAgICAgICAgICAgaWYgKHVud3JhcCh2YWx1ZSkgIT09IHJpZ2h0UmF3KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3Qgc3RyaW5nIHJlYmFzZScpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJpZ2h0O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoLCBzdGFydE1ldGEpIHtcclxuICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbChzdGFydE1ldGEpO1xyXG4gICAgdmFyIHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihtb2RlbCwgbGVmdCwgcGF0Y2gpO1xyXG4gICAgcmV0dXJuIHBhdGNoZXIucHJvY2VzcygpO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluY3JlbWVudGFsLXBhdGNoZXIuanMubWFwIiwiaW1wb3J0ICogYXMgaW5jcmVtZW50YWxfMSBmcm9tICcuL2luY3JlbWVudGFsLXBhdGNoZXInO1xyXG5leHBvcnQgeyBpbmNyZW1lbnRhbF8xIGFzIGluY3JlbWVudGFsIH07XHJcbmV4cG9ydCB7IGFwcGx5UGF0Y2ggfSBmcm9tICcuL3NpbXBsZS1wYXRjaGVyJztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIE9QUyA9IFtcclxuICAgICdWYWx1ZScsXHJcbiAgICAnQ29weScsXHJcbiAgICAnQmxhbmsnLFxyXG4gICAgJ1JldHVybkludG9BcnJheScsXHJcbiAgICAnUmV0dXJuSW50b09iamVjdCcsXHJcbiAgICAnUmV0dXJuSW50b09iamVjdFNhbWVLZXknLFxyXG4gICAgJ1B1c2hGaWVsZCcsXHJcbiAgICAnUHVzaEVsZW1lbnQnLFxyXG4gICAgJ1B1c2hQYXJlbnQnLFxyXG4gICAgJ1BvcCcsXHJcbiAgICAnUHVzaEZpZWxkQ29weScsXHJcbiAgICAnUHVzaEZpZWxkQmxhbmsnLFxyXG4gICAgJ1B1c2hFbGVtZW50Q29weScsXHJcbiAgICAnUHVzaEVsZW1lbnRCbGFuaycsXHJcbiAgICAnUmV0dXJuSW50b09iamVjdFBvcCcsXHJcbiAgICAnUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AnLFxyXG4gICAgJ1JldHVybkludG9BcnJheVBvcCcsXHJcbiAgICAnT2JqZWN0U2V0RmllbGRWYWx1ZScsXHJcbiAgICAnT2JqZWN0Q29weUZpZWxkJyxcclxuICAgICdPYmplY3REZWxldGVGaWVsZCcsXHJcbiAgICAnQXJyYXlBcHBlbmRWYWx1ZScsXHJcbiAgICAnQXJyYXlBcHBlbmRTbGljZScsXHJcbiAgICAnU3RyaW5nQXBwZW5kU3RyaW5nJyxcclxuICAgICdTdHJpbmdBcHBlbmRTbGljZSdcclxuXTtcclxudmFyIFBhdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQYXRjaGVyKG1vZGVsLCByb290LCBwYXRjaCkge1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xyXG4gICAgICAgIHRoaXMucGF0Y2ggPSBwYXRjaDtcclxuICAgIH1cclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0Y2hbdGhpcy5pKytdO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdGhpcy5yb290IH0pO1xyXG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XHJcbiAgICAgICAgZm9yICg7IHRoaXMuaSA8IHRoaXMucGF0Y2gubGVuZ3RoOykge1xyXG4gICAgICAgICAgICB2YXIgb3Bjb2RlID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHZhciBvcCA9IE9QU1tvcGNvZGVdO1xyXG4gICAgICAgICAgICBpZiAoIW9wKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcGNvZGU6IFwiICsgb3Bjb2RlKTtcclxuICAgICAgICAgICAgdmFyIHByb2Nlc3NvciA9IFwicHJvY2Vzc1wiICsgb3A7XHJcbiAgICAgICAgICAgIHRoaXNbcHJvY2Vzc29yXS5hcHBseSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUuaW5wdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFN0YWNrW3RoaXMuaW5wdXRTdGFjay5sZW5ndGggLSAxXTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEtleSA9IGZ1bmN0aW9uIChlbnRyeSwgaWR4KSB7XHJcbiAgICAgICAgaWYgKCFlbnRyeS5rZXlzKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LmtleXMgPSB0aGlzLm1vZGVsLm9iamVjdEdldEtleXMoZW50cnkudmFsdWUpLnNvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LmtleXNbaWR4XTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRTdGFja1t0aGlzLm91dHB1dFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEFycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcclxuICAgICAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcclxuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weUFycmF5KGVudHJ5LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0T2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcclxuICAgICAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcclxuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weU9iamVjdChlbnRyeS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XHJcbiAgICAgICAgaWYgKCFlbnRyeS53cml0ZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlTdHJpbmcoZW50cnkudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5maW5hbGl6ZU91dHB1dCA9IGZ1bmN0aW9uIChlbnRyeSkge1xyXG4gICAgICAgIGlmIChlbnRyeS53cml0ZVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZpbmFsaXplKGVudHJ5LndyaXRlVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBQcm9jZXNzb3JzOlxyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlIH0pO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NDb3B5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiBpbnB1dC52YWx1ZSB9KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQmxhbmsgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IG51bGwgfSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1JldHVybkludG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcclxuICAgICAgICB2YXIgYXJyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRWYWx1ZShhcnIsIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1JldHVybkludG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucmVhZCgpO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xyXG4gICAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwubWFya0NoYW5nZWQocmVzdWx0KTtcclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcclxuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwga2V5LCByZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0RW50cnkoKTtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcclxuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwgaW5wdXQua2V5LCByZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRmllbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwub2JqZWN0R2V0RmllbGQoZW50cnkudmFsdWUsIGtleSk7XHJcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGtleToga2V5IH0pO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5hcnJheUdldEVsZW1lbnQoZW50cnkudmFsdWUsIGlkeCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1BvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sucG9wKCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZENvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29weSgpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRmllbGRCbGFuayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRWxlbWVudENvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0UG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9PYmplY3QoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9BcnJheSgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NPYmplY3RTZXRGaWVsZFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1ZhbHVlKCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NPYmplY3RDb3B5RmllbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29weSgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdERlbGV0ZUZpZWxkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcclxuICAgICAgICB2YXIga2V5ID0gdGhpcy5pbnB1dEtleShlbnRyeSwgaWR4KTtcclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcclxuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdERlbGV0ZUZpZWxkKG9iaiwga2V5KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xyXG4gICAgICAgIHZhciBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NBcnJheUFwcGVuZFNsaWNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLm91dHB1dFN0cmluZygpO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kVmFsdWUoc3RyLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZ0FwcGVuZFNsaWNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xyXG4gICAgICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGF0Y2hlcjtcclxufSgpKTtcclxuZXhwb3J0IHsgUGF0Y2hlciB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC1wYXRjaGVyLmpzLm1hcCIsImltcG9ydCB7IFBhdGNoZXIgfSBmcm9tICcuL2ludGVybmFsLXBhdGNoZXInO1xyXG5pbXBvcnQgeyB1dGY4cmVzb2x2ZUluZGV4IH0gZnJvbSAnLi91dGY4JztcclxudmFyIE1vZGVsID0ge1xyXG4gICAgd3JhcDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH0sXHJcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKGIpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1hcmtDaGFuZ2VkOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgb2JqZWN0R2V0S2V5czogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKTtcclxuICAgIH0sXHJcbiAgICBvYmplY3RHZXRGaWVsZDogZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcclxuICAgIH0sXHJcbiAgICBhcnJheUdldEVsZW1lbnQ6IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlW2lkeF07XHJcbiAgICB9LFxyXG4gICAgY29weU9iamVjdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xyXG4gICAgICAgICAgICAgICAgcmVzLmRhdGFba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSxcclxuICAgIGNvcHlBcnJheTogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XHJcbiAgICB9LFxyXG4gICAgY29weVN0cmluZzogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgb2JqZWN0U2V0RmllbGQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICB0YXJnZXQuZGF0YVtrZXldID0gdmFsdWU7XHJcbiAgICB9LFxyXG4gICAgb2JqZWN0RGVsZXRlRmllbGQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGRlbGV0ZSB0YXJnZXQuZGF0YVtrZXldO1xyXG4gICAgfSxcclxuICAgIGFycmF5QXBwZW5kVmFsdWU6IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGFyZ2V0LnB1c2godmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGFycmF5QXBwZW5kU2xpY2U6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0YXJnZXQucHVzaC5hcHBseSh0YXJnZXQsIHNvdXJjZS5zbGljZShsZWZ0LCByaWdodCkpO1xyXG4gICAgfSxcclxuICAgIHN0cmluZ0FwcGVuZFNsaWNlOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZVN0cmluZyA9IHNvdXJjZTtcclxuICAgICAgICB2YXIgbGVmdFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCBsZWZ0KTtcclxuICAgICAgICB2YXIgcmlnaHRQb3MgPSB1dGY4cmVzb2x2ZUluZGV4KHNvdXJjZVN0cmluZywgcmlnaHQsIGxlZnRQb3MpO1xyXG4gICAgICAgIHRhcmdldC5kYXRhICs9IHNvdXJjZVN0cmluZy5zbGljZShsZWZ0UG9zLCByaWdodFBvcyk7XHJcbiAgICB9LFxyXG4gICAgc3RyaW5nQXBwZW5kVmFsdWU6IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGFyZ2V0LmRhdGEgKz0gdmFsdWU7XHJcbiAgICB9XHJcbn07XHJcbi8vIEFwcGxpZXMgYSBwYXRjaCBvbiBhIEphdmFTY3JpcHQgb2JqZWN0LlxyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCkge1xyXG4gICAgdmFyIHJvb3QgPSBsZWZ0OyAvLyBObyBuZWVkIHRvIHdyYXAgYmVjYXVzZSB0aGUgcmVwcmVzZW50YXRpb24gaXMgdGhlIHNhbWUuXHJcbiAgICB2YXIgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKE1vZGVsLCByb290LCBwYXRjaCk7XHJcbiAgICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxlLXBhdGNoZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHV0ZjhjaGFyU2l6ZShjb2RlKSB7XHJcbiAgICBpZiAoY29kZSA+PiAxNikge1xyXG4gICAgICAgIHJldHVybiA0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29kZSA+PiAxMSkge1xyXG4gICAgICAgIHJldHVybiAzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29kZSA+PiA3KSB7XHJcbiAgICAgICAgcmV0dXJuIDI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdXRmOHN0cmluZ1NpemUoc3RyKSB7XHJcbiAgICB2YXIgYiA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNvZGVQb2ludEF0KGkpO1xyXG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xyXG4gICAgICAgIGlmIChzaXplID09IDQpXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICBiICs9IHNpemU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYjtcclxufVxyXG4vKiogQ29udmVydHMgYW4gVVRGLTggYnl0ZSBpbmRleCBpbnRvIGEgVUNTLTIgaW5kZXguICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1dGY4cmVzb2x2ZUluZGV4KHN0ciwgaWR4LCBzdGFydCkge1xyXG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XHJcbiAgICB2YXIgYnl0ZUNvdW50ID0gc3RhcnQ7XHJcbiAgICB2YXIgdWNzSWR4ID0gMDtcclxuICAgIGZvciAodWNzSWR4ID0gc3RhcnQ7IGJ5dGVDb3VudCA8IGlkeDsgdWNzSWR4KyspIHtcclxuICAgICAgICB2YXIgY29kZSA9IHN0ci5jb2RlUG9pbnRBdCh1Y3NJZHgpO1xyXG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xyXG4gICAgICAgIGlmIChzaXplID09PSA0KVxyXG4gICAgICAgICAgICB1Y3NJZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXHJcbiAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdWNzSWR4O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb21tb25QcmVmaXgoc3RyLCBzdHIyKSB7XHJcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpO1xyXG4gICAgdmFyIGIgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgdmFyIGFQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChpKTtcclxuICAgICAgICB2YXIgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChpKTtcclxuICAgICAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XHJcbiAgICAgICAgYiArPSBzaXplO1xyXG4gICAgICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGI7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblN1ZmZpeChzdHIsIHN0cjIsIHByZWZpeCkge1xyXG4gICAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7IHByZWZpeCA9IDA7IH1cclxuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCkgLSBwcmVmaXg7XHJcbiAgICB2YXIgYiA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcclxuICAgICAgICB2YXIgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KHN0ci5sZW5ndGggLSAxIC0gaSk7XHJcbiAgICAgICAgdmFyIGJQb2ludCA9IHN0cjIuY29kZVBvaW50QXQoc3RyMi5sZW5ndGggLSAxIC0gaSk7XHJcbiAgICAgICAgaWYgKGFQb2ludCAhPT0gYlBvaW50KVxyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB2YXIgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShhUG9pbnQpO1xyXG4gICAgICAgIGIgKz0gc2l6ZTtcclxuICAgICAgICBpICs9IHNpemUgPT09IDQgPyAyIDogMTtcclxuICAgIH1cclxuICAgIHJldHVybiBiO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCxuby1wYXJhbS1yZWFzc2lnbixuby1zaGFkb3cgKi9cclxuXHJcbi8qKlxyXG4gKiBUaHJvdHRsZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi4gRXNwZWNpYWxseSB1c2VmdWwgZm9yIHJhdGUgbGltaXRpbmdcclxuICogZXhlY3V0aW9uIG9mIGhhbmRsZXJzIG9uIGV2ZW50cyBsaWtlIHJlc2l6ZSBhbmQgc2Nyb2xsLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgIGRlbGF5IC0gICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXHJcbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgW25vVHJhaWxpbmddIC0gICBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIG5vVHJhaWxpbmcgaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBvbmx5IGV4ZWN1dGUgZXZlcnkgYGRlbGF5YCBtaWxsaXNlY29uZHMgd2hpbGUgdGhlXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVkLWZ1bmN0aW9uIGlzIGJlaW5nIGNhbGxlZC4gSWYgbm9UcmFpbGluZyBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmUgZmluYWwgdGltZVxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIHRoZSBsYXN0IHRocm90dGxlZC1mdW5jdGlvbiBjYWxsLiAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBgZGVsYXlgIG1pbGxpc2Vjb25kcyxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgaW50ZXJuYWwgY291bnRlciBpcyByZXNldCkuXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgY2FsbGJhY2sgLSAgICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXHJcbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgW2RlYm91bmNlTW9kZV0gLSBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cclxuICpcclxuICogQHJldHVybnMge0Z1bmN0aW9ufSAgQSBuZXcsIHRocm90dGxlZCwgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiB0aHJvdHRsZSAoZGVsYXksIG5vVHJhaWxpbmcsIGNhbGxiYWNrLCBkZWJvdW5jZU1vZGUpIHtcclxuICAvKlxyXG4gICAqIEFmdGVyIHdyYXBwZXIgaGFzIHN0b3BwZWQgYmVpbmcgY2FsbGVkLCB0aGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0XHJcbiAgICogYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXHJcbiAgICogZGVib3VuY2UgbW9kZXMuXHJcbiAgICovXHJcbiAgdmFyIHRpbWVvdXRJRDtcclxuICB2YXIgY2FuY2VsbGVkID0gZmFsc2U7IC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdGltZSBgY2FsbGJhY2tgIHdhcyBleGVjdXRlZC5cclxuXHJcbiAgdmFyIGxhc3RFeGVjID0gMDsgLy8gRnVuY3Rpb24gdG8gY2xlYXIgZXhpc3RpbmcgdGltZW91dFxyXG5cclxuICBmdW5jdGlvbiBjbGVhckV4aXN0aW5nVGltZW91dCgpIHtcclxuICAgIGlmICh0aW1lb3V0SUQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJRCk7XHJcbiAgICB9XHJcbiAgfSAvLyBGdW5jdGlvbiB0byBjYW5jZWwgbmV4dCBleGVjXHJcblxyXG5cclxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XHJcbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xyXG4gICAgY2FuY2VsbGVkID0gdHJ1ZTtcclxuICB9IC8vIGBub1RyYWlsaW5nYCBkZWZhdWx0cyB0byBmYWxzeS5cclxuXHJcblxyXG4gIGlmICh0eXBlb2Ygbm9UcmFpbGluZyAhPT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICBkZWJvdW5jZU1vZGUgPSBjYWxsYmFjaztcclxuICAgIGNhbGxiYWNrID0gbm9UcmFpbGluZztcclxuICAgIG5vVHJhaWxpbmcgPSB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIC8qXHJcbiAgICogVGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSB0aHJvdHRsaW5nIC8gZGVib3VuY2luZ1xyXG4gICAqIGZ1bmN0aW9uYWxpdHkgYW5kIHdoZW4gZXhlY3V0ZWQgd2lsbCBsaW1pdCB0aGUgcmF0ZSBhdCB3aGljaCBgY2FsbGJhY2tgXHJcbiAgICogaXMgZXhlY3V0ZWQuXHJcbiAgICovXHJcblxyXG5cclxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xyXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c18gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICAgIGFyZ3VtZW50c19bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEV4ZWM7XHJcblxyXG4gICAgaWYgKGNhbmNlbGxlZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IC8vIEV4ZWN1dGUgYGNhbGxiYWNrYCBhbmQgdXBkYXRlIHRoZSBgbGFzdEV4ZWNgIHRpbWVzdGFtcC5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZXhlYygpIHtcclxuICAgICAgbGFzdEV4ZWMgPSBEYXRlLm5vdygpO1xyXG4gICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHNfKTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbikgdGhpcyBpcyB1c2VkIHRvIGNsZWFyIHRoZSBmbGFnXHJcbiAgICAgKiB0byBhbGxvdyBmdXR1cmUgYGNhbGxiYWNrYCBleGVjdXRpb25zLlxyXG4gICAgICovXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xyXG4gICAgICB0aW1lb3V0SUQgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRlYm91bmNlTW9kZSAmJiAhdGltZW91dElEKSB7XHJcbiAgICAgIC8qXHJcbiAgICAgICAqIFNpbmNlIGB3cmFwcGVyYCBpcyBiZWluZyBjYWxsZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxyXG4gICAgICAgKiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIGV4ZWN1dGUgYGNhbGxiYWNrYC5cclxuICAgICAgICovXHJcbiAgICAgIGV4ZWMoKTtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhckV4aXN0aW5nVGltZW91dCgpO1xyXG5cclxuICAgIGlmIChkZWJvdW5jZU1vZGUgPT09IHVuZGVmaW5lZCAmJiBlbGFwc2VkID4gZGVsYXkpIHtcclxuICAgICAgLypcclxuICAgICAgICogSW4gdGhyb3R0bGUgbW9kZSwgaWYgYGRlbGF5YCB0aW1lIGhhcyBiZWVuIGV4Y2VlZGVkLCBleGVjdXRlXHJcbiAgICAgICAqIGBjYWxsYmFja2AuXHJcbiAgICAgICAqL1xyXG4gICAgICBleGVjKCk7XHJcbiAgICB9IGVsc2UgaWYgKG5vVHJhaWxpbmcgIT09IHRydWUpIHtcclxuICAgICAgLypcclxuICAgICAgICogSW4gdHJhaWxpbmcgdGhyb3R0bGUgbW9kZSwgc2luY2UgYGRlbGF5YCB0aW1lIGhhcyBub3QgYmVlblxyXG4gICAgICAgKiBleGNlZWRlZCwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0byBleGVjdXRlIGBkZWxheWAgbXMgYWZ0ZXIgbW9zdFxyXG4gICAgICAgKiByZWNlbnQgZXhlY3V0aW9uLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIHNjaGVkdWxlIGBjbGVhcmAgdG8gZXhlY3V0ZVxyXG4gICAgICAgKiBhZnRlciBgZGVsYXlgIG1zLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xyXG4gICAgICAgKiBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuXHJcbiAgICAgICAqL1xyXG4gICAgICB0aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGRlYm91bmNlTW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgPyBkZWxheSAtIGVsYXBzZWQgOiBkZWxheSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB3cmFwcGVyLmNhbmNlbCA9IGNhbmNlbDsgLy8gUmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxyXG5cclxuICByZXR1cm4gd3JhcHBlcjtcclxufVxyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXHJcbi8qKlxyXG4gKiBEZWJvdW5jZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi4gRGVib3VuY2luZywgdW5saWtlIHRocm90dGxpbmcsXHJcbiAqIGd1YXJhbnRlZXMgdGhhdCBhIGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgYSBzaW5nbGUgdGltZSwgZWl0aGVyIGF0IHRoZVxyXG4gKiB2ZXJ5IGJlZ2lubmluZyBvZiBhIHNlcmllcyBvZiBjYWxscywgb3IgYXQgdGhlIHZlcnkgZW5kLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgZGVsYXkgLSAgICAgICAgIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50IGNhbGxiYWNrcywgdmFsdWVzIGFyb3VuZCAxMDAgb3IgMjUwIChvciBldmVuIGhpZ2hlcikgYXJlIG1vc3QgdXNlZnVsLlxyXG4gKiBAcGFyYW0gIHtib29sZWFufSAgW2F0QmVnaW5dIC0gICAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgYXRCZWdpbiBpcyBmYWxzZSBvciB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGBkZWxheWAgbWlsbGlzZWNvbmRzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIHRoZSBsYXN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLiBJZiBhdEJlZ2luIGlzIHRydWUsIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb25seSBhdCB0aGUgZmlyc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLCB0aGUgaW50ZXJuYWwgY291bnRlciBpcyByZXNldCkuXHJcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtICAgICAgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBkZWxheSBtaWxsaXNlY29uZHMuIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIGRlYm91bmNlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cclxuICpcclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldywgZGVib3VuY2VkIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGRlYm91bmNlIChkZWxheSwgYXRCZWdpbiwgY2FsbGJhY2spIHtcclxuICByZXR1cm4gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IHRocm90dGxlKGRlbGF5LCBhdEJlZ2luLCBmYWxzZSkgOiB0aHJvdHRsZShkZWxheSwgY2FsbGJhY2ssIGF0QmVnaW4gIT09IGZhbHNlKTtcclxufVxyXG5cclxuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xyXG5leHBvcnRzLnRocm90dGxlID0gdGhyb3R0bGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxyXG4iXSwic291cmNlUm9vdCI6IiJ9