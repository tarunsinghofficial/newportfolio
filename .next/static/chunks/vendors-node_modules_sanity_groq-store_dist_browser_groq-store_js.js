(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_sanity_groq-store_dist_browser_groq-store_js"],{

/***/ "./node_modules/@sanity/groq-store/dist/browser/groq-store.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/groq-store/dist/browser/groq-store.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var r=e(__webpack_require__(/*! groq */ "./node_modules/groq/lib/groq.js")),t=e(__webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js")),n=__webpack_require__(/*! throttle-debounce */ "./node_modules/throttle-debounce/cjs/index.js"),o=__webpack_require__(/*! groq-js */ "./node_modules/groq-js/dist/groq-js.esm.js"),i=__webpack_require__(/*! mendoza */ "./node_modules/mendoza/lib/esm/index.js");function u(){return(u=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function s(e,r,t){var n,o=r.token,i=new e("https://"+r.projectId+".api.sanity.io/v1/data/listen/"+r.dataset+"?query=*&effectFormat=mendoza",{withCredentials:!0,headers:o?{Authorization:"Bearer "+o}:void 0});return i.addEventListener("welcome",t.open,!1),i.addEventListener("mutation",(n=t.next,function(e){var r;try{r=JSON.parse(e.data)}catch(e){return}n(r)}),!1),i.addEventListener("channelError",function(e){var r;i.close();try{r=JSON.parse(e.data)}catch(e){return void t.error(new Error("Unknown error parsing listener message"))}t.error(new Error(r.message||r.error||"Listener returned HTTP "+r.statusCode))},!1),i.addEventListener("error",function(e){var r="undefined"!=typeof window&&window.location.origin,n=r?", and that the CORS-origin ("+r+") is allowed":"",o=function(e){return"object"==typeof e&&null!==e&&"message"in e}(e)?" ("+e.message+")":"";t.error(new Error("Error establishing listener - check that the project ID and dataset are correct"+n+o))},!1),{unsubscribe:function(){return Promise.resolve(i.close())}}}function c(e){return e._id.startsWith("drafts.")?e._id.slice(7):e._id}function a(e,r){var t=u({},e);return delete t._rev,i.applyPatch(t,r)}function f(){return Promise.resolve()}function d(){var e,r,t=(e=["*[_id == $id][0]"],r||(r=e.slice(0)),e.raw=r,e);return d=function(){return t},t}function v(e,r,t){if(!e.s){if(t instanceof l){if(!t.s)return void(t.o=v.bind(null,e,r));1&r&&(r=t.s),t=t.v}if(t&&t.then)return void t.then(v.bind(null,e,r),v.bind(null,e,2));e.s=r,e.v=t;var n=e.o;n&&n(e)}}var l=function(){function e(){}return e.prototype.then=function(r,t){var n=new e,o=this.s;if(o){var i=1&o?r:t;if(i){try{v(n,1,i(this.v))}catch(e){v(n,2,e)}return n}return this}return this.o=function(e){try{var o=e.v;1&e.s?v(n,1,r?r(o):o):t?v(n,1,t(o)):v(n,2,o)}catch(e){v(n,2,e)}},n},e}();function h(e){return e instanceof l&&1&e.s}var m=function(e){var r=e.projectId,t=e.dataset,n=e.token,o=e.documentLimit;try{return Promise.resolve(fetch("https://"+r+".api.sanity.io/v1/data/export/"+t,{credentials:"include",headers:n?{Authorization:"Bearer "+n}:void 0})).then(function(e){function r(r){var t,n,i=function(e){if(!e)throw new Error("Failed to read body from response");var r,t=!1;function n(){t=!0,r&&r.cancel()}return new ReadableStream({start:function(o){r=e.getReader();var i=new TextDecoder,u="";r.read().then(function e(s){try{if(s.done)return t?Promise.resolve():0===(u=u.trim()).length?(o.close(),Promise.resolve()):(o.enqueue(JSON.parse(u)),o.close(),Promise.resolve());for(var c=(u+=i.decode(s.value,{stream:!0})).split("\n"),a=0;a<c.length-1;++a){var f=c[a].trim();if(0===f.length)return Promise.resolve();try{o.enqueue(JSON.parse(f))}catch(e){return o.error(e),n(),Promise.resolve()}}if(u=c[c.length-1],!r)return Promise.resolve();var d=function(t,n){try{var o=Promise.resolve(r.read()).then(function(r){e(r)})}catch(e){return n(e)}return o&&o.then?o.then(void 0,n):o}(0,function(e){o.error(e)});return Promise.resolve(d&&d.then?d.then(function(){}):void 0)}catch(e){return Promise.reject(e)}}).catch(function(e){return o.error(e)})},cancel:n})}(e.body).getReader(),u=[],s=function(e,r){var t;do{var n=e();if(n&&n.then){if(!h(n)){t=!0;break}n=n.v}var o=r();if(h(o)&&(o=o.v),!o)return n}while(!o.then);var i=new l,u=v.bind(null,i,2);return(t?n.then(s):o.then(c)).then(void 0,u),i;function s(t){for(n=t;h(o=r())&&(o=o.v),o;){if(o.then)return void o.then(c).then(void 0,u);if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}}v(i,1,n)}function c(t){if(t){do{if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}if(h(t=r())&&(t=t.v),!t)return void v(i,1,n)}while(!t.then);t.then(c).then(void 0,u)}else v(i,1,n)}}(function(){return Promise.resolve(i.read()).then(function(e){if(function(e){return!!e&&"error"in e&&"object"==typeof e.error&&null!==e.error&&"description"in e.error&&"string"==typeof e.error.description&&!("_id"in e)}(n=(t=e).value))throw new Error("Error streaming dataset: "+n.error);if(n&&!n._id.startsWith("_.")&&u.push(n),o&&u.length>o)throw i.cancel("Reached document limit"),new Error("Error streaming dataset: Reached limit of "+o+" documents")})},function(){return!t.done});return s&&s.then?s.then(function(e){return u}):u}var t=function(){if(200!==e.status)return Promise.resolve(e.json()).then(function(e){throw new Error("Error streaming dataset: "+("object"==typeof(r=e)&&"error"in r&&"message"in r?r.message||r.error:"<unknown error>"));var r})}();return t&&t.then?t.then(r):r()})}catch(e){return Promise.reject(e)}};exports.groq=r,exports.groqStore=function(e){if(function(){var e=["EventSource","ReadableStream","fetch"].filter(function(e){return!(e in window)});if(e.length>0)throw new Error("Browser not supported. Missing browser APIs: "+e.join(", "))}(),e.token)throw new Error("`token` option not currently supported in browser");return function(e,i){var v,l=function(e,r){try{return Promise.resolve(h()).then(function(){var t=o.parse(e,{params:r});return Promise.resolve(o.evaluate(t,{dataset:m,params:r})).then(function(e){return e.get()})})}catch(e){return Promise.reject(e)}},h=function(){try{return v||(v=function(e,r,t){var n=t.getDocuments,o=t.EventSource,i=e.projectId,d=e.dataset,v=e.overlayDrafts,l=e.documentLimit;if(!e.listen)return{unsubscribe:f,loaded:n({projectId:i,dataset:d,documentLimit:l}).then(j).then(f)};var h,m,p,w,b,g,y=new Map,P=[],E=new Promise(function(e,r){m=e,p=r});return{unsubscribe:s(o,e,{next:function(e){h?(function(e){if(e.effects&&!e.documentId.startsWith("_.")){var r=y.get(e.documentId)||null;!function(e,r){var t=y.get(e),n=h||[],o=t?n.indexOf(t):-1;-1===o&&r?(n.push(r),y.set(e,r)):r?(n.splice(o,1,r),y.set(e,r)):(n.splice(o,1),y.delete(e))}(e.documentId,a(r,e.effects.apply))}}(e),function(e,r){clearTimeout(g),b!==r.transactionId&&w?(j(w),b=void 0):(b=r.transactionId,w=e.slice()),g=setTimeout(j,25,e.slice())}(h,e)):P.push(e)},open:function(){try{return Promise.resolve(n({projectId:i,dataset:d,documentLimit:l})).then(function(e){(h=function(e,r){var t=new Map;return r.forEach(function(e){var r=t.get(e.documentId)||[];r.push(e),t.set(e.documentId,r)}),t.forEach(function(r,t){var n=e.find(function(e){return e._id===t});if(n){var o=!1,i=n;r.forEach(function(e){(o=o||e.previousRev===n._rev)&&e.effects&&(i=a(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}else console.warn("Received mutation for missing document %s",t)}),e}(e,P)).forEach(function(e){return y.set(e._id,e)}),j(h),m()})}catch(e){return Promise.reject(e)}},error:function(e){return p(e)}}).unsubscribe,loaded:E};function j(e){w=void 0,g=void 0,b=void 0,r(v?function(e){var r=new Map;return e.forEach(function(e){var t=r.get(c(e));e._id.startsWith("drafts.")?r.set(c(e),function(e){return u({},e,{_id:c(e)})}(e)):t||r.set(e._id,e)}),Array.from(r.values())}(e):e)}}(e,function(e){m=e,p()},i)),Promise.resolve(v.loaded).then(function(){})}catch(e){return Promise.reject(e)}},m=[],p=n.throttle(e.subscriptionThrottleMs||50,function(){w.forEach(b)}),w=[];function b(e){return l(e.query,e.params).then(function(r){"previousResult"in e&&t(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(function(r){e.callback(r)})}return{query:l,getDocument:function(e){try{return Promise.resolve(h()).then(function(){return l(r(d()),{id:e})})}catch(e){return Promise.reject(e)}},getDocuments:function(e){try{return Promise.resolve(h()).then(function(){var r=e.map(function(e){return'*[_id == "'+e+'"][0]'}).join(",\n");return l("["+r+"]")})}catch(e){return Promise.reject(e)}},subscribe:function(r,t,n){if(!e.listen)throw new Error("Cannot use `subscribe()` without `listen: true`");var o={query:r,params:t,callback:n};w.push(o);var i=!1;return b(o),{unsubscribe:function(){return i||(i=!0,w.splice(w.indexOf(o),1)),Promise.resolve()}}},close:function(){return p.cancel(),v?v.unsubscribe():Promise.resolve()}}}(e,{EventSource:window.EventSource,getDocuments:m})};
//# sourceMappingURL=groq-store.js.map


/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "./node_modules/groq-js/dist/groq-js.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/groq-js/dist/groq-js.esm.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "evaluate": function() { return /* binding */ evaluateQuery; },
/* harmony export */   "parse": function() { return /* binding */ parse; }
/* harmony export */ });
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
class MarkProcessor {
  constructor(string3, marks, parseOptions) {
    this.allowBoost = false;
    this.string = string3;
    this.marks = marks;
    this.index = 0;
    this.parseOptions = parseOptions;
  }
  hasMark(pos = 0) {
    return this.index + pos < this.marks.length;
  }
  getMark(pos = 0) {
    return this.marks[this.index + pos];
  }
  shift() {
    this.index += 1;
  }
  process(visitor) {
    const mark = this.marks[this.index];
    this.shift();
    const func = visitor[mark.name];
    if (!func) {
      throw new Error(`Unknown handler: ${mark.name}`);
    }
    return func.call(visitor, this, mark);
  }
  processString() {
    this.shift();
    return this.processStringEnd();
  }
  processStringEnd() {
    const prev = this.marks[this.index - 1];
    const curr = this.marks[this.index];
    this.shift();
    return this.string.slice(prev.position, curr.position);
  }
  slice(len) {
    const pos = this.marks[this.index].position;
    return this.string.slice(pos, pos + len);
  }
}
const RFC3339_REGEX = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|([-+]\d{2}:\d{2}))$/;
function parseRFC3339(str) {
  if (RFC3339_REGEX.test(str)) {
    return new Date(str);
  }
  return null;
}
function formatRFC3339(d) {
  const year = addLeadingZero(d.getUTCFullYear(), 4);
  const month = addLeadingZero(d.getUTCMonth() + 1, 2);
  const day = addLeadingZero(d.getUTCDate(), 2);
  const hour = addLeadingZero(d.getUTCHours(), 2);
  const minute = addLeadingZero(d.getUTCMinutes(), 2);
  const second = addLeadingZero(d.getUTCSeconds(), 2);
  let fractionalSecond = "";
  const millis = d.getMilliseconds();
  if (millis != 0) {
    fractionalSecond = `.${addLeadingZero(millis, 3)}`;
  }
  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;
}
function addLeadingZero(num, targetLength) {
  let str = num.toString();
  while (str.length < targetLength) {
    str = `0${str}`;
  }
  return str;
}
function escapeRegExp(string3) {
  return string3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function pathRegExp(pattern) {
  const re = [];
  for (const part of pattern.split(".")) {
    if (part === "*") {
      re.push("[^.]+");
    } else if (part === "**") {
      re.push(".*");
    } else {
      re.push(escapeRegExp(part));
    }
  }
  return new RegExp(`^${re.join(".")}$`);
}
class Path {
  constructor(pattern) {
    this.pattern = pattern;
    this.patternRe = pathRegExp(pattern);
  }
  matches(str) {
    return this.patternRe.test(str);
  }
  toJSON() {
    return this.pattern;
  }
}
class StreamValue {
  constructor(generator) {
    this.type = "stream";
    this.generator = generator;
    this.ticker = null;
    this.isDone = false;
    this.data = [];
  }
  isArray() {
    return true;
  }
  async get() {
    const result = [];
    for await (const value of this) {
      result.push(await value.get());
    }
    return result;
  }
  async *[Symbol.asyncIterator]() {
    let i = 0;
    while (true) {
      for (; i < this.data.length; i++) {
        yield this.data[i];
      }
      if (this.isDone) {
        return;
      }
      await this._nextTick();
    }
  }
  _nextTick() {
    if (this.ticker) {
      return this.ticker;
    }
    let currentResolver;
    const setupTicker = () => {
      this.ticker = new Promise((resolve) => {
        currentResolver = resolve;
      });
    };
    const tick = () => {
      currentResolver();
      setupTicker();
    };
    const fetch = async () => {
      for await (const value of this.generator()) {
        this.data.push(value);
        tick();
      }
      this.isDone = true;
      tick();
    };
    setupTicker();
    fetch();
    return this.ticker;
  }
}
class StaticValue {
  constructor(data, type) {
    this.data = data;
    this.type = type;
  }
  isArray() {
    return this.type === "array";
  }
  async get() {
    return this.data;
  }
  [Symbol.asyncIterator]() {
    if (Array.isArray(this.data)) {
      return function* (data) {
        for (const element of data) {
          yield fromJS(element);
        }
      }(this.data);
    }
    throw new Error(`Cannot iterate over: ${this.type}`);
  }
}
const NULL_VALUE = new StaticValue(null, "null");
const TRUE_VALUE = new StaticValue(true, "boolean");
const FALSE_VALUE = new StaticValue(false, "boolean");
class DateTime {
  constructor(date) {
    this.date = date;
  }
  static parseToValue(str) {
    const date = parseRFC3339(str);
    if (date) {
      return new StaticValue(new DateTime(date), "datetime");
    }
    return NULL_VALUE;
  }
  equals(other) {
    return this.date.getTime() == other.date.getTime();
  }
  add(secs) {
    const copy = new Date(this.date.getTime());
    copy.setTime(copy.getTime() + secs * 1e3);
    return new DateTime(copy);
  }
  difference(other) {
    return (this.date.getTime() - other.date.getTime()) / 1e3;
  }
  compareTo(other) {
    return this.date.getTime() - other.date.getTime();
  }
  toString() {
    return formatRFC3339(this.date);
  }
  toJSON() {
    return this.toString();
  }
}
function fromNumber(num) {
  if (Number.isFinite(num)) {
    return new StaticValue(num, "number");
  }
  return NULL_VALUE;
}
function fromString(str) {
  return new StaticValue(str, "string");
}
function fromDateTime(dt) {
  return new StaticValue(dt, "datetime");
}
function fromPath(path2) {
  return new StaticValue(path2, "path");
}
function isIterator(obj) {
  return obj && typeof obj.next === "function";
}
function fromJS(val) {
  if (isIterator(val)) {
    return new StreamValue(async function* () {
      for await (const value of val) {
        yield fromJS(value);
      }
    });
  } else if (val === null || val === void 0) {
    return NULL_VALUE;
  }
  return new StaticValue(val, getType(val));
}
function getType(data) {
  if (data === null || typeof data === "undefined") {
    return "null";
  }
  if (Array.isArray(data)) {
    return "array";
  }
  if (data instanceof Path) {
    return "path";
  }
  if (data instanceof DateTime) {
    return "datetime";
  }
  return typeof data;
}
const TYPE_ORDER = {
  datetime: 1,
  number: 2,
  string: 3,
  boolean: 4
};
function partialCompare(a, b) {
  const aType = getType(a);
  const bType = getType(b);
  if (aType !== bType) {
    return null;
  }
  switch (aType) {
    case "number":
    case "boolean":
      return a - b;
    case "string":
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    case "datetime":
      return a.compareTo(b);
    default:
      return null;
  }
}
function totalCompare(a, b) {
  const aType = getType(a);
  const bType = getType(b);
  const aTypeOrder = TYPE_ORDER[aType] || 100;
  const bTypeOrder = TYPE_ORDER[bType] || 100;
  if (aTypeOrder !== bTypeOrder) {
    return aTypeOrder - bTypeOrder;
  }
  let result = partialCompare(a, b);
  if (result === null) {
    result = 0;
  }
  return result;
}
const CHARS = /([^!@#$%^&*(),\\/?";:{}|[\]+<>\s-])+/g;
const CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\/?";:{}|[\]+<>\s-])+/g;
const EDGE_CHARS = /(\b\.+|\.+\b)/g;
const MAX_TERM_LENGTH = 1024;
function matchText(tokens, patterns) {
  if (tokens.length === 0 || patterns.length === 0) {
    return false;
  }
  return patterns.every((pattern) => pattern(tokens));
}
function matchTokenize(text) {
  return text.replace(EDGE_CHARS, "").match(CHARS) || [];
}
function matchAnalyzePattern(text) {
  const termsRe = matchPatternRegex(text);
  return termsRe.map((re) => (tokens) => tokens.some((token) => re.test(token)));
}
function matchPatternRegex(text) {
  const terms = text.replace(EDGE_CHARS, "").match(CHARS_WITH_WILDCARD) || [];
  return terms.map((term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\*/g, ".*")}$`, "i"));
}
async function gatherText(value, cb) {
  if (value.type === "string") {
    cb(value.data);
    return true;
  }
  if (value.isArray()) {
    let success = true;
    for await (const part of value) {
      if (part.type === "string") {
        cb(part.data);
      } else {
        success = false;
      }
    }
    return success;
  }
  return false;
}
const BM25k = 1.2;
async function evaluateScore(node, scope, execute) {
  if (node.type === "OpCall" && node.op === "match") {
    return evaluateMatchScore(node.left, node.right, scope, execute);
  }
  if (node.type === "FuncCall" && node.name === "boost") {
    const innerScore = await evaluateScore(node.args[0], scope, execute);
    const boost2 = await execute(node.args[1], scope);
    if (boost2.type === "number" && innerScore > 0) {
      return innerScore + boost2.data;
    }
    return 0;
  }
  switch (node.type) {
    case "Or": {
      const leftScore = await evaluateScore(node.left, scope, execute);
      const rightScore = await evaluateScore(node.right, scope, execute);
      return leftScore + rightScore;
    }
    case "And": {
      const leftScore = await evaluateScore(node.left, scope, execute);
      const rightScore = await evaluateScore(node.right, scope, execute);
      if (leftScore === 0 || rightScore === 0)
        return 0;
      return leftScore + rightScore;
    }
    default: {
      const res = await execute(node, scope);
      return res.type === "boolean" && res.data === true ? 1 : 0;
    }
  }
}
async function evaluateMatchScore(left, right, scope, execute) {
  const text = await execute(left, scope);
  const pattern = await execute(right, scope);
  let tokens = [];
  let terms = [];
  await gatherText(text, (part) => {
    tokens = tokens.concat(matchTokenize(part));
  });
  const didSucceed = await gatherText(pattern, (part) => {
    terms = terms.concat(matchPatternRegex(part));
  });
  if (!didSucceed) {
    return 0;
  }
  if (tokens.length === 0 || terms.length === 0) {
    return 0;
  }
  let score2 = 0;
  for (const re of terms) {
    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);
    score2 += freq * (BM25k + 1) / (freq + BM25k);
  }
  return score2;
}
async function portableTextContent(value) {
  if (value.type === "object") {
    return blockText(value.data);
  } else if (value.isArray()) {
    const texts = await arrayText(value);
    if (texts.length > 0) {
      return texts.join("\n\n");
    }
  }
  return null;
}
async function arrayText(value, result = []) {
  for await (const block of value) {
    if (block.type === "object") {
      const text = blockText(block.data);
      if (text !== null)
        result.push(text);
    } else if (block.isArray()) {
      await arrayText(block, result);
    }
  }
  return result;
}
function blockText(obj) {
  if (typeof obj._type !== "string")
    return null;
  const children = obj.children;
  if (!Array.isArray(children))
    return null;
  let result = "";
  for (const child of children) {
    if (child && typeof child === "object" && typeof child._type === "string" && child._type === "span" && typeof child.text === "string") {
      result += child.text;
    }
  }
  return result;
}
function hasReference(value, pathSet) {
  switch (getType(value)) {
    case "array":
      for (const v of value) {
        if (hasReference(v, pathSet)) {
          return true;
        }
      }
      break;
    case "object":
      if (value._ref) {
        return pathSet.has(value._ref);
      }
      for (const v of Object.values(value)) {
        if (hasReference(v, pathSet)) {
          return true;
        }
      }
      break;
  }
  return false;
}
function countUTF8(str) {
  let count2 = 0;
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    if (code >= 55296 && code <= 56319) {
      continue;
    }
    count2++;
  }
  return count2;
}
const global = {};
global.coalesce = async function coalesce(args, scope, execute) {
  for (const arg of args) {
    const value = await execute(arg, scope);
    if (value.type !== "null") {
      return value;
    }
  }
  return NULL_VALUE;
};
global.count = async function count(args, scope, execute) {
  const inner = await execute(args[0], scope);
  if (!inner.isArray()) {
    return NULL_VALUE;
  }
  let num = 0;
  for await (const _ of inner) {
    num++;
  }
  return fromNumber(num);
};
global.count.arity = 1;
global.dateTime = async function dateTime(args, scope, execute) {
  const val = await execute(args[0], scope);
  if (val.type === "datetime") {
    return val;
  }
  if (val.type !== "string") {
    return NULL_VALUE;
  }
  return DateTime.parseToValue(val.data);
};
global.dateTime.arity = 1;
global.defined = async function defined(args, scope, execute) {
  const inner = await execute(args[0], scope);
  return inner.type === "null" ? FALSE_VALUE : TRUE_VALUE;
};
global.defined.arity = 1;
global.identity = async function identity(args, scope) {
  return fromString(scope.context.identity);
};
global.identity.arity = 0;
global.length = async function length(args, scope, execute) {
  const inner = await execute(args[0], scope);
  if (inner.type === "string") {
    return fromNumber(countUTF8(inner.data));
  }
  if (inner.isArray()) {
    let num = 0;
    for await (const _ of inner) {
      num++;
    }
    return fromNumber(num);
  }
  return NULL_VALUE;
};
global.length.arity = 1;
global.path = async function path(args, scope, execute) {
  const inner = await execute(args[0], scope);
  if (inner.type !== "string") {
    return NULL_VALUE;
  }
  return fromPath(new Path(inner.data));
};
global.path.arity = 1;
global.string = async function string(args, scope, execute) {
  const value = await execute(args[0], scope);
  switch (value.type) {
    case "number":
    case "string":
    case "boolean":
    case "datetime":
      return fromString(`${value.data}`);
    default:
      return NULL_VALUE;
  }
};
global.string.arity = 1;
global.references = async function references(args, scope, execute) {
  const pathSet = new Set();
  for (const arg of args) {
    const path2 = await execute(arg, scope);
    if (path2.type === "string") {
      pathSet.add(path2.data);
    } else if (path2.isArray()) {
      for await (const elem of path2) {
        if (elem.type === "string") {
          pathSet.add(elem.data);
        }
      }
    }
  }
  if (pathSet.size === 0) {
    return FALSE_VALUE;
  }
  const scopeValue = await scope.value.get();
  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;
};
global.references.arity = (c) => c >= 1;
global.round = async function round(args, scope, execute) {
  const value = await execute(args[0], scope);
  if (value.type !== "number") {
    return NULL_VALUE;
  }
  const num = value.data;
  let prec = 0;
  if (args.length === 2) {
    const precValue = await execute(args[1], scope);
    if (precValue.type !== "number" || precValue.data < 0 || !Number.isInteger(precValue.data)) {
      return NULL_VALUE;
    }
    prec = precValue.data;
  }
  if (prec === 0) {
    if (num < 0) {
      return fromNumber(-Math.round(-num));
    }
    return fromNumber(Math.round(num));
  }
  return fromNumber(Number(num.toFixed(prec)));
};
global.round.arity = (count2) => count2 >= 1 && count2 <= 2;
global.now = async function now(args, scope) {
  return fromString(scope.context.timestamp.toISOString());
};
global.now.arity = 0;
global.boost = async function boost() {
  throw new Error("unexpected boost call");
};
global.boost.arity = 2;
const string2 = {};
string2.lower = async function(args, scope, execute) {
  const value = await execute(args[0], scope);
  if (value.type !== "string") {
    return NULL_VALUE;
  }
  return fromString(value.data.toLowerCase());
};
string2.lower.arity = 1;
string2.upper = async function(args, scope, execute) {
  const value = await execute(args[0], scope);
  if (value.type !== "string") {
    return NULL_VALUE;
  }
  return fromString(value.data.toUpperCase());
};
string2.upper.arity = 1;
global.lower = string2.lower;
global.upper = string2.upper;
const pt = {};
pt.text = async function(args, scope, execute) {
  const value = await execute(args[0], scope);
  const text = await portableTextContent(value);
  if (text === null) {
    return NULL_VALUE;
  }
  return fromString(text);
};
pt.text.arity = 1;
const sanity = {};
sanity.projectId = async function(args, scope) {
  if (scope.context.sanity) {
    return fromString(scope.context.sanity.projectId);
  }
  return NULL_VALUE;
};
sanity.dataset = async function(args, scope) {
  if (scope.context.sanity) {
    return fromString(scope.context.sanity.dataset);
  }
  return NULL_VALUE;
};
const pipeFunctions = {};
pipeFunctions.order = async function order(base, args, scope, execute) {
  await true;
  if (!base.isArray()) {
    return NULL_VALUE;
  }
  const mappers = [];
  const directions = [];
  let n = 0;
  for (let mapper of args) {
    let direction = "asc";
    if (mapper.type === "Desc") {
      direction = "desc";
      mapper = mapper.base;
    } else if (mapper.type === "Asc") {
      mapper = mapper.base;
    }
    mappers.push(mapper);
    directions.push(direction);
    n++;
  }
  const aux = [];
  let idx = 0;
  for await (const value of base) {
    const newScope = scope.createNested(value);
    const tuple = [await value.get(), idx];
    for (let i = 0; i < n; i++) {
      const result = await execute(mappers[i], newScope);
      tuple.push(await result.get());
    }
    aux.push(tuple);
    idx++;
  }
  aux.sort((aTuple, bTuple) => {
    for (let i = 0; i < n; i++) {
      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);
      if (directions[i] === "desc") {
        c = -c;
      }
      if (c !== 0) {
        return c;
      }
    }
    return aTuple[1] - bTuple[1];
  });
  return fromJS(aux.map((v) => v[0]));
};
pipeFunctions.order.arity = (count2) => count2 >= 1;
pipeFunctions.score = async function score(base, args, scope, execute) {
  if (!base.isArray())
    return NULL_VALUE;
  const unknown = [];
  const scored = [];
  for await (const value of base) {
    if (value.type !== "object") {
      unknown.push(await value.get());
      continue;
    }
    const newScope = scope.createNested(value);
    let valueScore = typeof value.data._score === "number" ? value.data._score : 0;
    for (const arg of args) {
      valueScore += await evaluateScore(arg, newScope, execute);
    }
    const newObject = Object.assign({}, value.data, { _score: valueScore });
    scored.push(newObject);
  }
  scored.sort((a, b) => b._score - a._score);
  return fromJS(scored);
};
pipeFunctions.score.arity = (count2) => count2 >= 1;
const delta = {};
delta.operation = async function(args, scope) {
  const hasBefore = scope.context.before !== null;
  const hasAfter = scope.context.after !== null;
  if (hasBefore && hasAfter) {
    return fromString("update");
  }
  if (hasAfter) {
    return fromString("create");
  }
  if (hasBefore) {
    return fromString("delete");
  }
  return NULL_VALUE;
};
delta.changedAny = () => {
  throw new Error("not implemented");
};
delta.changedAny.arity = 1;
delta.changedAny.mode = "delta";
delta.changedOnly = () => {
  throw new Error("not implemented");
};
delta.changedOnly.arity = 1;
delta.changedOnly.mode = "delta";
const diff = {};
diff.changedAny = () => {
  throw new Error("not implemented");
};
diff.changedAny.arity = 3;
diff.changedOnly = () => {
  throw new Error("not implemented");
};
diff.changedOnly.arity = 3;
const namespaces = {
  global,
  string: string2,
  pt,
  delta,
  diff,
  sanity
};
const WS = /^([\t\n\v\f\r \u0085\u00A0]|(\/\/[^\n]*\n))+/;
const NUM = /^\d+/;
const IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;
const PREC_PAIR = 1;
const PREC_OR = 2;
const PREC_AND = 3;
const PREC_COMP = 4;
const PREC_ORDER = 4;
const PREC_ADD = 6;
const PREC_SUB = 6;
const PREC_MUL = 7;
const PREC_DIV = 7;
const PREC_MOD = 7;
const PREC_POW = 8;
const PREC_POS = 10;
const PREC_NOT = 10;
const PREC_NEG = 8;
function parse$1(str) {
  let pos = 0;
  pos = skipWS(str, pos);
  let result = parseExpr(str, pos, 0);
  if (result.type === "error")
    return result;
  pos = skipWS(str, result.position);
  if (pos !== str.length) {
    if (result.failPosition) {
      pos = result.failPosition - 1;
    }
    return { type: "error", position: pos };
  }
  delete result.position;
  delete result.failPosition;
  return result;
}
function parseExpr(str, pos, level) {
  let startPos = pos;
  let token = str[pos];
  let marks;
  switch (token) {
    case "+": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);
      if (rhs.type === "error")
        return rhs;
      marks = [{ name: "pos", position: startPos }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "-": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);
      if (rhs.type === "error")
        return rhs;
      marks = [{ name: "neg", position: startPos }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "(": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);
      if (rhs.type === "error")
        return rhs;
      pos = skipWS(str, rhs.position);
      switch (str[pos]) {
        case ",": {
          marks = [{ name: "tuple", position: startPos }].concat(rhs.marks);
          pos = skipWS(str, pos + 1);
          while (true) {
            rhs = parseExpr(str, pos, 0);
            if (rhs.type === "error")
              return rhs;
            pos = skipWS(str, rhs.position);
            if (str[pos] !== ",")
              break;
            pos = skipWS(str, pos + 1);
          }
          if (str[pos] !== ")")
            return { type: "error", position: pos };
          pos++;
          marks.push({ name: "tuple_end", position: pos });
          break;
        }
        case ")": {
          pos++;
          marks = [{ name: "group", position: startPos }].concat(rhs.marks);
          break;
        }
        default:
          return { type: "error", position: pos };
      }
      break;
    }
    case "!": {
      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);
      if (rhs.type === "error")
        return rhs;
      marks = [{ name: "not", position: startPos }].concat(rhs.marks);
      pos = rhs.position;
      break;
    }
    case "{": {
      let result = parseObject(str, pos);
      if (result.type === "error")
        return result;
      marks = result.marks;
      pos = result.position;
      break;
    }
    case "[":
      marks = [{ name: "array", position: pos }];
      pos = skipWS(str, pos + 1);
      if (str[pos] !== "]") {
        while (true) {
          if (str.slice(pos, pos + 3) === "...") {
            marks.push({ name: "array_splat", position: pos });
            pos = skipWS(str, pos + 3);
          }
          let res = parseExpr(str, pos, 0);
          if (res.type === "error")
            return res;
          marks = marks.concat(res.marks);
          pos = res.position;
          pos = skipWS(str, pos);
          if (str[pos] !== ",")
            break;
          pos = skipWS(str, pos + 1);
          if (str[pos] === "]")
            break;
        }
      }
      if (str[pos] === "]") {
        pos++;
        marks.push({ name: "array_end", position: pos });
      } else {
        return { type: "error", position: pos };
      }
      break;
    case "'":
    case '"': {
      let result = parseString(str, pos);
      if (result.type === "error")
        return result;
      marks = result.marks;
      pos = result.position;
      break;
    }
    case "^": {
      pos++;
      marks = [];
      while (str[pos] === "." && str[pos + 1] === "^") {
        marks.push({ name: "dblparent", position: startPos });
        pos += 2;
      }
      marks.push({ name: "parent", position: startPos });
      break;
    }
    case "@":
      marks = [{ name: "this", position: startPos }];
      pos++;
      break;
    case "*":
      marks = [{ name: "everything", position: startPos }];
      pos++;
      break;
    case "$": {
      let identLen = parseRegex(str, pos + 1, IDENT);
      if (identLen) {
        pos += 1 + identLen;
        marks = [
          { name: "param", position: startPos },
          { name: "ident", position: startPos + 1 },
          { name: "ident_end", position: pos }
        ];
      }
      break;
    }
    default: {
      let numLen = parseRegex(str, pos, NUM);
      if (numLen) {
        pos += numLen;
        let name = "integer";
        if (str[pos] === ".") {
          let fracLen = parseRegex(str, pos + 1, NUM);
          if (fracLen) {
            name = "float";
            pos += 1 + fracLen;
          }
        }
        if (str[pos] === "e" || str[pos] === "E") {
          name = "sci";
          pos++;
          if (str[pos] === "+" || str[pos] === "-") {
            pos++;
          }
          let expLen = parseRegex(str, pos, NUM);
          if (!expLen)
            return { type: "error", position: pos };
          pos += expLen;
        }
        marks = [
          { name, position: startPos },
          { name: name + "_end", position: pos }
        ];
        break;
      }
      let identLen = parseRegex(str, pos, IDENT);
      if (identLen) {
        pos += identLen;
        switch (str[pos]) {
          case ":":
          case "(": {
            let result = parseFuncCall(str, startPos, pos);
            if (result.type === "error")
              return result;
            marks = result.marks;
            pos = result.position;
            break;
          }
          default: {
            marks = [
              { name: "this_attr", position: startPos },
              { name: "ident", position: startPos },
              { name: "ident_end", position: pos }
            ];
          }
        }
        break;
      }
    }
  }
  if (!marks) {
    return { type: "error", position: pos };
  }
  let lhsLevel = 12;
  let trav;
  loop:
    while (true) {
      let innerPos = skipWS(str, pos);
      if (innerPos === str.length) {
        pos = innerPos;
        break;
      }
      trav = parseTraversal(str, innerPos);
      if (trav.type === "success") {
        marks.unshift({ name: "traverse", position: startPos });
        while (trav.type === "success") {
          marks = marks.concat(trav.marks);
          pos = trav.position;
          trav = parseTraversal(str, skipWS(str, pos));
        }
        marks.push({ name: "traversal_end", position: pos });
        continue;
      }
      let token2 = str[innerPos];
      switch (token2) {
        case "=": {
          let nextToken = str[innerPos + 1];
          switch (nextToken) {
            case ">": {
              if (level > PREC_PAIR || lhsLevel <= PREC_PAIR)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);
              if (rhs.type === "error")
                return rhs;
              marks = marks.concat(rhs.marks);
              marks.unshift({ name: "pair", position: startPos });
              pos = rhs.position;
              lhsLevel = PREC_PAIR;
              break;
            }
            case "=": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);
              if (rhs.type === "error")
                return rhs;
              marks.unshift({ name: "comp", position: startPos });
              marks.push({ name: "op", position: innerPos }, { name: "op_end", position: innerPos + 2 });
              marks = marks.concat(rhs.marks);
              pos = rhs.position;
              lhsLevel = PREC_COMP;
              break;
            }
            default:
              break loop;
          }
          break;
        }
        case "+": {
          if (level > PREC_ADD || lhsLevel < PREC_ADD)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "add", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_ADD;
          break;
        }
        case "-": {
          if (level > PREC_SUB || lhsLevel < PREC_SUB)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "sub", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_SUB;
          break;
        }
        case "*": {
          if (str[innerPos + 1] === "*") {
            if (level > PREC_POW || lhsLevel <= PREC_POW)
              break loop;
            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);
            if (rhs2.type === "error")
              return rhs2;
            marks = marks.concat(rhs2.marks);
            marks.unshift({ name: "pow", position: startPos });
            pos = rhs2.position;
            lhsLevel = PREC_POW;
            break;
          }
          if (level > PREC_MUL || lhsLevel < PREC_MUL)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "mul", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_MUL;
          break;
        }
        case "/": {
          if (level > PREC_DIV || lhsLevel < PREC_DIV)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "div", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_DIV;
          break;
        }
        case "%": {
          if (level > PREC_MOD || lhsLevel < PREC_MOD)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "mod", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_MOD;
          break;
        }
        case "<":
        case ">": {
          if (level > PREC_COMP || lhsLevel <= PREC_COMP)
            break loop;
          let nextPos = innerPos + 1;
          if (str[nextPos] === "=") {
            nextPos++;
          }
          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);
          if (rhs.type === "error")
            return rhs;
          marks.unshift({ name: "comp", position: startPos });
          marks.push({ name: "op", position: innerPos }, { name: "op_end", position: nextPos });
          marks = marks.concat(rhs.marks);
          pos = rhs.position;
          lhsLevel = PREC_COMP;
          break;
        }
        case "|": {
          if (str[innerPos + 1] === "|") {
            if (level > PREC_OR || lhsLevel < PREC_OR)
              break loop;
            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);
            if (rhs.type === "error")
              return rhs;
            marks = marks.concat(rhs.marks);
            marks.unshift({ name: "or", position: startPos });
            pos = rhs.position;
            lhsLevel = PREC_OR;
          } else {
            if (level > 11 || lhsLevel < 11)
              break loop;
            let identPos = skipWS(str, innerPos + 1);
            let identLen = parseRegex(str, identPos, IDENT);
            if (!identLen)
              return { type: "error", position: identPos };
            pos = identPos + identLen;
            if (str[pos] === "(" || str[pos] === ":") {
              let result = parseFuncCall(str, identPos, pos);
              if (result.type === "error")
                return result;
              marks = marks.concat(result.marks);
              marks.unshift({ name: "pipecall", position: startPos });
              pos = result.position;
              lhsLevel = 11;
            }
          }
          break;
        }
        case "&": {
          if (str[innerPos + 1] != "&")
            break loop;
          if (level > PREC_AND || lhsLevel < PREC_AND)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);
          if (rhs.type === "error")
            return rhs;
          marks = marks.concat(rhs.marks);
          marks.unshift({ name: "and", position: startPos });
          pos = rhs.position;
          lhsLevel = PREC_AND;
          break;
        }
        case "!": {
          if (str[innerPos + 1] !== "=")
            break loop;
          if (level > PREC_COMP || lhsLevel < PREC_COMP)
            break loop;
          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);
          if (rhs.type === "error")
            return rhs;
          marks.unshift({ name: "comp", position: startPos });
          marks.push({ name: "op", position: innerPos }, { name: "op_end", position: innerPos + 2 });
          marks = marks.concat(rhs.marks);
          pos = rhs.position;
          lhsLevel = PREC_COMP;
          break;
        }
        case "d": {
          if (str.slice(innerPos, innerPos + 4) !== "desc")
            break loop;
          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)
            break loop;
          marks.unshift({ name: "desc", position: startPos });
          pos = innerPos + 4;
          lhsLevel = PREC_ORDER;
          break;
        }
        case "a": {
          if (str.slice(innerPos, innerPos + 3) !== "asc")
            break loop;
          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)
            break loop;
          marks.unshift({ name: "asc", position: startPos });
          pos = innerPos + 3;
          lhsLevel = PREC_ORDER;
          break;
        }
        default: {
          let ident = parseRegexStr(str, innerPos, IDENT);
          switch (ident) {
            case "in": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              pos = skipWS(str, innerPos + 2);
              let isGroup = false;
              if (str[pos] === "(") {
                isGroup = true;
                pos = skipWS(str, pos + 1);
              }
              let rangePos = pos;
              let result = parseExpr(str, pos, PREC_COMP + 1);
              if (result.type === "error")
                return result;
              pos = skipWS(str, result.position);
              if (str[pos] === "." && str[pos + 1] === ".") {
                let type = "inc_range";
                if (str[pos + 2] === ".") {
                  type = "exc_range";
                  pos = skipWS(str, pos + 3);
                } else {
                  pos = skipWS(str, pos + 2);
                }
                let rhs = parseExpr(str, pos, PREC_COMP + 1);
                if (rhs.type === "error")
                  return rhs;
                marks.unshift({ name: "in_range", position: startPos });
                marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks);
                pos = rhs.position;
              } else {
                marks.unshift({ name: "comp", position: startPos });
                marks.push({ name: "op", position: innerPos }, { name: "op_end", position: innerPos + 2 });
                marks = marks.concat(result.marks);
              }
              if (isGroup) {
                pos = skipWS(str, pos);
                if (str[pos] !== ")")
                  return { type: "error", position: pos };
                pos++;
              }
              lhsLevel = PREC_COMP;
              break;
            }
            case "match": {
              if (level > PREC_COMP || lhsLevel <= PREC_COMP)
                break loop;
              let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);
              if (rhs.type === "error")
                return rhs;
              marks.unshift({ name: "comp", position: startPos });
              marks.push({ name: "op", position: innerPos }, { name: "op_end", position: innerPos + 5 });
              marks = marks.concat(rhs.marks);
              pos = rhs.position;
              lhsLevel = 4;
              break;
            }
            default: {
              break loop;
            }
          }
        }
      }
    }
  let failPosition = (trav == null ? void 0 : trav.type) === "error" && trav.position;
  return { type: "success", marks, position: pos, failPosition };
}
function parseTraversal(str, pos) {
  let startPos = pos;
  switch (str[pos]) {
    case ".": {
      pos = skipWS(str, pos + 1);
      let identStart = pos;
      let identLen2 = parseRegex(str, pos, IDENT);
      if (!identLen2)
        return { type: "error", position: pos };
      pos += identLen2;
      return {
        type: "success",
        marks: [
          { name: "attr_access", position: startPos },
          { name: "ident", position: identStart },
          { name: "ident_end", position: pos }
        ],
        position: pos
      };
    }
    case "-":
      if (str[pos + 1] !== ">")
        return { type: "error", position: pos };
      let marks = [{ name: "deref", position: startPos }];
      pos += 2;
      let identPos = skipWS(str, pos);
      let identLen = parseRegex(str, identPos, IDENT);
      if (identLen) {
        pos = identPos + identLen;
        marks.push({ name: "deref_attr", position: identPos }, { name: "ident", position: identPos }, { name: "ident_end", position: pos });
      }
      return {
        type: "success",
        marks,
        position: pos
      };
    case "[": {
      pos = skipWS(str, pos + 1);
      if (str[pos] === "]") {
        return {
          type: "success",
          marks: [{ name: "array_postfix", position: startPos }],
          position: pos + 1
        };
      }
      let rangePos = pos;
      let result = parseExpr(str, pos, 0);
      if (result.type === "error")
        return result;
      pos = skipWS(str, result.position);
      if (str[pos] === "." && str[pos + 1] === ".") {
        let type = "inc_range";
        if (str[pos + 2] === ".") {
          type = "exc_range";
          pos += 3;
        } else {
          pos += 2;
        }
        pos = skipWS(str, pos);
        let rhs = parseExpr(str, pos, 0);
        if (rhs.type === "error")
          return rhs;
        pos = skipWS(str, rhs.position);
        if (str[pos] !== "]")
          return { type: "error", position: pos };
        return {
          type: "success",
          marks: [
            { name: "slice", position: startPos },
            { name: type, position: rangePos }
          ].concat(result.marks, rhs.marks),
          position: pos + 1
        };
      }
      if (str[pos] !== "]")
        return { type: "error", position: pos };
      return {
        type: "success",
        marks: [{ name: "square_bracket", position: startPos }].concat(result.marks),
        position: pos + 1
      };
    }
    case "|": {
      pos = skipWS(str, pos + 1);
      if (str[pos] === "{") {
        let result = parseObject(str, pos);
        if (result.type === "error")
          return result;
        result.marks.unshift({ name: "projection", position: startPos });
        return result;
      }
      break;
    }
    case "{": {
      let result = parseObject(str, pos);
      if (result.type === "error")
        return result;
      result.marks.unshift({ name: "projection", position: startPos });
      return result;
    }
  }
  return { type: "error", position: pos };
}
function parseFuncCall(str, startPos, pos) {
  let marks = [];
  marks.push({ name: "func_call", position: startPos });
  if (str[pos] === ":" && str[pos + 1] === ":") {
    marks.push({ name: "namespace", position: startPos });
    marks.push({ name: "ident", position: startPos }, { name: "ident_end", position: pos });
    pos = skipWS(str, pos + 2);
    let nameLen = parseRegex(str, pos, IDENT);
    if (!nameLen)
      return { type: "error", position: pos };
    marks.push({ name: "ident", position: pos }, { name: "ident_end", position: pos + nameLen });
    pos = skipWS(str, pos + nameLen);
    if (str[pos] !== "(")
      return { type: "error", position: pos };
    pos++;
  } else {
    marks.push({ name: "ident", position: startPos }, { name: "ident_end", position: pos });
    pos = skipWS(str, pos + 1);
  }
  let lastPos = pos;
  if (str[pos] !== ")") {
    while (true) {
      let result = parseExpr(str, pos, 0);
      if (result.type === "error")
        return result;
      marks = marks.concat(result.marks);
      lastPos = result.position;
      pos = skipWS(str, result.position);
      if (str[pos] !== ",")
        break;
      pos = skipWS(str, pos + 1);
      if (str[pos] === ")")
        break;
    }
  }
  if (str[pos] !== ")") {
    return { type: "error", position: pos };
  }
  marks.push({ name: "func_args_end", position: lastPos });
  return {
    type: "success",
    marks,
    position: pos + 1
  };
}
function parseObject(str, pos) {
  let marks = [{ name: "object", position: pos }];
  pos = skipWS(str, pos + 1);
  while (str[pos] !== "}") {
    let pairPos = pos;
    if (str.slice(pos, pos + 3) === "...") {
      pos = skipWS(str, pos + 3);
      if (str[pos] !== "}" && str[pos] !== ",") {
        let expr = parseExpr(str, pos, 0);
        if (expr.type === "error")
          return expr;
        marks.push({ name: "object_splat", position: pairPos });
        marks = marks.concat(expr.marks);
        pos = expr.position;
      } else {
        marks.push({ name: "object_splat_this", position: pairPos });
      }
    } else {
      let expr = parseExpr(str, pos, 0);
      if (expr.type === "error")
        return expr;
      let nextPos = skipWS(str, expr.position);
      if (expr.marks[0].name === "str" && str[nextPos] === ":") {
        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);
        if (value.type === "error")
          return value;
        marks.push({ name: "object_pair", position: pairPos });
        marks = marks.concat(expr.marks, value.marks);
        pos = value.position;
      } else {
        marks = marks.concat({ name: "object_expr", position: pos }, expr.marks);
        pos = expr.position;
      }
    }
    pos = skipWS(str, pos);
    if (str[pos] !== ",")
      break;
    pos = skipWS(str, pos + 1);
  }
  if (str[pos] !== "}") {
    return { type: "error", position: pos };
  }
  pos++;
  marks.push({ name: "object_end", position: pos });
  return { type: "success", marks, position: pos };
}
function parseString(str, pos) {
  let token = str[pos];
  pos = pos + 1;
  const marks = [{ name: "str", position: pos }];
  str:
    for (; ; pos++) {
      if (pos > str.length)
        return { type: "error", position: pos };
      switch (str[pos]) {
        case token: {
          marks.push({ name: "str_end", position: pos });
          pos++;
          break str;
        }
        case "\\": {
          marks.push({ name: "str_pause", position: pos });
          if (str[pos + 1] === "u") {
            if (str[pos + 2] === "{") {
              marks.push({ name: "unicode_hex", position: pos + 3 });
              pos = str.indexOf("}", pos + 3);
              marks.push({ name: "unicode_hex_end", position: pos });
              pos++;
            } else {
              marks.push({ name: "unicode_hex", position: pos + 2 });
              marks.push({ name: "unicode_hex_end", position: pos + 6 });
              pos += 5;
            }
          } else {
            marks.push({ name: "single_escape", position: pos + 1 });
            pos += 1;
          }
          marks.push({ name: "str_start", position: pos + 1 });
        }
      }
    }
  return { type: "success", marks, position: pos };
}
function skipWS(str, pos) {
  return pos + parseRegex(str, pos, WS);
}
function parseRegex(str, pos, re) {
  let m = re.exec(str.slice(pos));
  return m ? m[0].length : 0;
}
function parseRegexStr(str, pos, re) {
  let m = re.exec(str.slice(pos));
  return m ? m[0] : null;
}
function join(a, b) {
  return (base) => b(a(base));
}
function map(inner) {
  return (base) => ({ type: "Map", base, expr: inner({ type: "This" }) });
}
function flatMap(inner) {
  return (base) => ({ type: "FlatMap", base, expr: inner({ type: "This" }) });
}
function traverseArray(build, right) {
  if (!right) {
    return {
      type: "a-a",
      build
    };
  }
  switch (right.type) {
    case "a-a":
      return {
        type: "a-a",
        build: join(build, right.build)
      };
    case "a-b":
      return {
        type: "a-b",
        build: join(build, right.build)
      };
    case "b-b":
      return {
        type: "a-a",
        build: join(build, map(right.build))
      };
    case "b-a":
      return {
        type: "a-a",
        build: join(build, flatMap(right.build))
      };
    default:
      throw new Error(`unknown type: ${right.type}`);
  }
}
function traversePlain(mapper, right) {
  if (!right) {
    return {
      type: "b-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
    case "b-a":
      return {
        type: "b-a",
        build: join(mapper, right.build)
      };
    case "a-b":
    case "b-b":
      return {
        type: "b-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error(`unknown type: ${right.type}`);
  }
}
function traverseElement(mapper, right) {
  if (!right) {
    return {
      type: "a-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
    case "b-a":
      return {
        type: "a-a",
        build: join(mapper, right.build)
      };
    case "a-b":
    case "b-b":
      return {
        type: "a-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error(`unknown type: ${right.type}`);
  }
}
function traverseProjection(mapper, right) {
  if (!right) {
    return {
      type: "b-b",
      build: mapper
    };
  }
  switch (right.type) {
    case "a-a":
      return {
        type: "a-a",
        build: join(map(mapper), right.build)
      };
    case "a-b":
      return {
        type: "a-b",
        build: join(map(mapper), right.build)
      };
    case "b-a":
      return {
        type: "b-a",
        build: join(mapper, right.build)
      };
    case "b-b":
      return {
        type: "b-b",
        build: join(mapper, right.build)
      };
    default:
      throw new Error(`unknown type: ${right.type}`);
  }
}
const isEqual = equality;
function equality(a, b) {
  if (a.type === "string" && b.type === "string" || a.type === "boolean" && b.type === "boolean" || a.type === "null" && b.type === "null" || a.type === "number" && b.type === "number") {
    return a.data === b.data;
  }
  if (a.type === "datetime" && b.type === "datetime") {
    return a.data.equals(b.data);
  }
  return false;
}
const operators = {
  "==": function eq(left, right) {
    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;
  },
  "!=": function neq(left, right) {
    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;
  },
  ">": function gt(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result > 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  ">=": function gte(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  "<": function lt(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result < 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  "<=": function lte(left, right) {
    if (left.type === "stream" || right.type === "stream")
      return NULL_VALUE;
    const result = partialCompare(left.data, right.data);
    if (result === null) {
      return NULL_VALUE;
    }
    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  in: async function inop(left, right) {
    if (right.type === "path") {
      if (left.type !== "string") {
        return NULL_VALUE;
      }
      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;
    }
    if (right.isArray()) {
      for await (const b of right) {
        if (isEqual(left, b)) {
          return TRUE_VALUE;
        }
      }
      return FALSE_VALUE;
    }
    return NULL_VALUE;
  },
  match: async function match(left, right) {
    let tokens = [];
    let patterns = [];
    await gatherText(left, (part) => {
      tokens = tokens.concat(matchTokenize(part));
    });
    const didSucceed = await gatherText(right, (part) => {
      patterns = patterns.concat(matchAnalyzePattern(part));
    });
    if (!didSucceed) {
      return FALSE_VALUE;
    }
    const matched = matchText(tokens, patterns);
    return matched ? TRUE_VALUE : FALSE_VALUE;
  },
  "+": function plus(left, right) {
    if (left.type === "datetime" && right.type === "number") {
      return fromDateTime(left.data.add(right.data));
    }
    if (left.type === "number" && right.type === "number") {
      return fromNumber(left.data + right.data);
    }
    if (left.type === "string" && right.type === "string") {
      return fromString(left.data + right.data);
    }
    if (left.type === "object" && right.type === "object") {
      return fromJS(__spreadValues(__spreadValues({}, left.data), right.data));
    }
    if (left.type === "array" && right.type === "array") {
      return fromJS(left.data.concat(right.data));
    }
    if (left.isArray() && right.isArray()) {
      return new StreamValue(async function* () {
        for await (const val of left) {
          yield val;
        }
        for await (const val of right) {
          yield val;
        }
      });
    }
    return NULL_VALUE;
  },
  "-": function minus(left, right) {
    if (left.type === "datetime" && right.type === "number") {
      return fromDateTime(left.data.add(-right.data));
    }
    if (left.type === "datetime" && right.type === "datetime") {
      return fromNumber(left.data.difference(right.data));
    }
    if (left.type === "number" && right.type === "number") {
      return fromNumber(left.data - right.data);
    }
    return NULL_VALUE;
  },
  "*": numericOperator((a, b) => a * b),
  "/": numericOperator((a, b) => a / b),
  "%": numericOperator((a, b) => a % b),
  "**": numericOperator((a, b) => Math.pow(a, b))
};
function numericOperator(impl) {
  return function(left, right) {
    if (left.type === "number" && right.type === "number") {
      const result = impl(left.data, right.data);
      return fromNumber(result);
    }
    return NULL_VALUE;
  };
}
class Scope {
  constructor(params, source, value, context, parent) {
    this.isHidden = false;
    this.params = params;
    this.source = source;
    this.value = value;
    this.context = context;
    this.parent = parent;
  }
  createNested(value) {
    if (this.isHidden) {
      return new Scope(this.params, this.source, value, this.context, this.parent);
    }
    return new Scope(this.params, this.source, value, this.context, this);
  }
  createHidden(value) {
    const result = this.createNested(value);
    result.isHidden = true;
    return result;
  }
}
function evaluate(node, scope, execute = evaluate) {
  const func = EXECUTORS[node.type];
  return func(node, scope, execute);
}
function promiselessApply(value, cb) {
  if ("then" in value) {
    return value.then(cb);
  }
  return cb(value);
}
const EXECUTORS = {
  This(_, scope) {
    return scope.value;
  },
  Everything(_, scope) {
    return scope.source;
  },
  Parameter({ name }, scope) {
    return fromJS(scope.params[name]);
  },
  Context({ key }, scope) {
    if (key === "before" || key === "after") {
      const value = scope.context[key];
      return value || NULL_VALUE;
    }
    throw new Error(`unknown context key: ${key}`);
  },
  Parent({ n }, scope) {
    let current = scope;
    for (let i = 0; i < n; i++) {
      if (!current.parent) {
        return NULL_VALUE;
      }
      current = current.parent;
    }
    return current.value;
  },
  OpCall({ op, left, right }, scope, execute) {
    const func = operators[op];
    if (!func) {
      throw new Error(`Unknown operator: ${op}`);
    }
    const leftValue = execute(left, scope);
    const rightValue = execute(right, scope);
    if ("then" in leftValue || "then" in rightValue) {
      return (async () => func(await leftValue, await rightValue))();
    }
    return func(leftValue, rightValue);
  },
  async Select({ alternatives, fallback }, scope, execute) {
    for (const alt of alternatives) {
      const altCond = await execute(alt.condition, scope);
      if (altCond.type === "boolean" && altCond.data === true) {
        return execute(alt.value, scope);
      }
    }
    if (fallback) {
      return execute(fallback, scope);
    }
    return NULL_VALUE;
  },
  async InRange({ base, left, right, isInclusive }, scope, execute) {
    const value = await execute(base, scope);
    const leftValue = await execute(left, scope);
    const rightValue = await execute(right, scope);
    const leftCmp = partialCompare(await value.get(), await leftValue.get());
    if (leftCmp === null) {
      return NULL_VALUE;
    }
    const rightCmp = partialCompare(await value.get(), await rightValue.get());
    if (rightCmp === null) {
      return NULL_VALUE;
    }
    if (isInclusive) {
      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;
    }
    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;
  },
  async Filter({ base, expr }, scope, execute) {
    const baseValue = await execute(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of baseValue) {
        const newScope = scope.createNested(elem);
        const exprValue = await execute(expr, newScope);
        if (exprValue.type === "boolean" && exprValue.data === true) {
          yield elem;
        }
      }
    });
  },
  async Projection({ base, expr }, scope, execute) {
    const baseValue = await execute(base, scope);
    if (baseValue.type !== "object") {
      return NULL_VALUE;
    }
    const newScope = scope.createNested(baseValue);
    return execute(expr, newScope);
  },
  FuncCall({ func, args }, scope, execute) {
    return func(args, scope, execute);
  },
  async PipeFuncCall({ func, base, args }, scope, execute) {
    const baseValue = await execute(base, scope);
    return func(baseValue, args, scope, execute);
  },
  async AccessAttribute({ base, name }, scope, execute) {
    let value = scope.value;
    if (base) {
      value = await execute(base, scope);
    }
    if (value.type === "object") {
      if (value.data.hasOwnProperty(name)) {
        return fromJS(value.data[name]);
      }
    }
    return NULL_VALUE;
  },
  async AccessElement({ base, index }, scope, execute) {
    const baseValue = await execute(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    const data = await baseValue.get();
    const finalIndex = index < 0 ? index + data.length : index;
    return fromJS(data[finalIndex]);
  },
  async Slice({ base, left, right, isInclusive }, scope, execute) {
    const baseValue = await execute(base, scope);
    if (!baseValue.isArray()) {
      return NULL_VALUE;
    }
    const array = await baseValue.get();
    let leftIdx = left;
    let rightIdx = right;
    if (leftIdx < 0) {
      leftIdx = array.length + leftIdx;
    }
    if (rightIdx < 0) {
      rightIdx = array.length + rightIdx;
    }
    if (isInclusive) {
      rightIdx++;
    }
    if (leftIdx < 0) {
      leftIdx = 0;
    }
    if (rightIdx < 0) {
      rightIdx = 0;
    }
    return fromJS(array.slice(leftIdx, rightIdx));
  },
  async Deref({ base }, scope, execute) {
    const value = await execute(base, scope);
    if (!scope.source.isArray()) {
      return NULL_VALUE;
    }
    if (value.type !== "object") {
      return NULL_VALUE;
    }
    const id = value.data._ref;
    if (typeof id !== "string") {
      return NULL_VALUE;
    }
    for await (const doc of scope.source) {
      if (doc.type === "object" && id === doc.data._id) {
        return doc;
      }
    }
    return NULL_VALUE;
  },
  Value({ value }) {
    return fromJS(value);
  },
  Group({ base }, scope, execute) {
    return execute(base, scope);
  },
  async Object({ attributes }, scope, execute) {
    const result = {};
    for (const attr of attributes) {
      const attrType = attr.type;
      switch (attr.type) {
        case "ObjectAttributeValue": {
          const value = await execute(attr.value, scope);
          result[attr.name] = await value.get();
          break;
        }
        case "ObjectConditionalSplat": {
          const cond = await execute(attr.condition, scope);
          if (cond.type !== "boolean" || cond.data === false) {
            continue;
          }
          const value = await execute(attr.value, scope);
          if (value.type === "object") {
            Object.assign(result, value.data);
          }
          break;
        }
        case "ObjectSplat": {
          const value = await execute(attr.value, scope);
          if (value.type === "object") {
            Object.assign(result, value.data);
          }
          break;
        }
        default:
          throw new Error(`Unknown node type: ${attrType}`);
      }
    }
    return fromJS(result);
  },
  Array({ elements }, scope, execute) {
    return new StreamValue(async function* () {
      for (const element of elements) {
        const value = await execute(element.value, scope);
        if (element.isSplat) {
          if (value.isArray()) {
            for await (const v of value) {
              yield v;
            }
          }
        } else {
          yield value;
        }
      }
    });
  },
  Tuple() {
    throw new Error("tuples can not be evaluated");
  },
  async Or({ left, right }, scope, execute) {
    const leftValue = await execute(left, scope);
    const rightValue = await execute(right, scope);
    if (leftValue.type === "boolean") {
      if (leftValue.data === true) {
        return TRUE_VALUE;
      }
    }
    if (rightValue.type === "boolean") {
      if (rightValue.data === true) {
        return TRUE_VALUE;
      }
    }
    if (leftValue.type !== "boolean" || rightValue.type !== "boolean") {
      return NULL_VALUE;
    }
    return FALSE_VALUE;
  },
  async And({ left, right }, scope, execute) {
    const leftValue = await execute(left, scope);
    const rightValue = await execute(right, scope);
    if (leftValue.type === "boolean") {
      if (leftValue.data === false) {
        return FALSE_VALUE;
      }
    }
    if (rightValue.type === "boolean") {
      if (rightValue.data === false) {
        return FALSE_VALUE;
      }
    }
    if (leftValue.type !== "boolean" || rightValue.type !== "boolean") {
      return NULL_VALUE;
    }
    return TRUE_VALUE;
  },
  async Not({ base }, scope, execute) {
    const value = await execute(base, scope);
    if (value.type !== "boolean") {
      return NULL_VALUE;
    }
    return value.data ? FALSE_VALUE : TRUE_VALUE;
  },
  Neg({ base }, scope, execute) {
    return promiselessApply(execute(base, scope), (value) => {
      if (value.type !== "number") {
        return NULL_VALUE;
      }
      return fromNumber(-value.data);
    });
  },
  Pos({ base }, scope, execute) {
    return promiselessApply(execute(base, scope), (value) => {
      if (value.type !== "number") {
        return NULL_VALUE;
      }
      return fromNumber(value.data);
    });
  },
  Asc() {
    return NULL_VALUE;
  },
  Desc() {
    return NULL_VALUE;
  },
  async ArrayCoerce({ base }, scope, execute) {
    const value = await execute(base, scope);
    return value.isArray() ? value : NULL_VALUE;
  },
  async Map({ base, expr }, scope, execute) {
    const value = await execute(base, scope);
    if (!value.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of value) {
        const newScope = scope.createHidden(elem);
        yield await execute(expr, newScope);
      }
    });
  },
  async FlatMap({ base, expr }, scope, execute) {
    const value = await execute(base, scope);
    if (!value.isArray()) {
      return NULL_VALUE;
    }
    return new StreamValue(async function* () {
      for await (const elem of value) {
        const newScope = scope.createHidden(elem);
        const innerValue = await execute(expr, newScope);
        if (innerValue.isArray()) {
          for await (const inner of innerValue) {
            yield inner;
          }
        } else {
          yield innerValue;
        }
      }
    });
  }
};
function evaluateQuery(tree, options = {}) {
  const root = fromJS(options.root);
  const dataset = fromJS(options.dataset);
  const params = __spreadValues({}, options.params);
  const scope = new Scope(params, dataset, root, {
    timestamp: options.timestamp || new Date(),
    identity: options.identity === void 0 ? "me" : options.identity,
    sanity: options.sanity,
    after: options.after ? fromJS(options.after) : null,
    before: options.before ? fromJS(options.before) : null
  }, null);
  return evaluate(tree, scope);
}
function canConstantEvaluate(node) {
  switch (node.type) {
    case "Group":
    case "Value":
    case "Parameter":
    case "Pos":
    case "Neg":
      return true;
    case "OpCall":
      switch (node.op) {
        case "+":
        case "-":
        case "*":
        case "/":
        case "%":
        case "**":
          return true;
        default:
          return false;
      }
    default:
      return false;
  }
}
const DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: "me", before: null, after: null }, null);
class ConstantEvaluateError extends Error {
  constructor() {
    super(...arguments);
    this.name = "ConstantEvaluateError";
  }
}
function tryConstantEvaluate(node) {
  try {
    return constantEvaluate(node);
  } catch (err) {
    if (err.name === "ConstantEvaluateError") {
      return null;
    }
    throw err;
  }
}
function constantEvaluate(node) {
  if (!canConstantEvaluate(node)) {
    throw new ConstantEvaluateError("cannot constant evaluate");
  }
  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);
  if ("then" in value) {
    throw new Error("BUG: constant evaluate should never return a promise");
  }
  return value;
}
const ESCAPE_SEQUENCE = {
  "'": "'",
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
};
function expandHex(str) {
  const charCode = parseInt(str, 16);
  return String.fromCharCode(charCode);
}
class GroqQueryError extends Error {
  constructor() {
    super(...arguments);
    this.name = "GroqQueryError";
  }
}
const EXPR_BUILDER = {
  group(p) {
    const inner = p.process(EXPR_BUILDER);
    return {
      type: "Group",
      base: inner
    };
  },
  everything() {
    return { type: "Everything" };
  },
  this() {
    return { type: "This" };
  },
  parent() {
    return {
      type: "Parent",
      n: 1
    };
  },
  dblparent(p) {
    const next = p.process(EXPR_BUILDER);
    return {
      type: "Parent",
      n: next.n + 1
    };
  },
  traverse(p) {
    const base = p.process(EXPR_BUILDER);
    const traversalList = [];
    while (p.getMark().name !== "traversal_end") {
      traversalList.push(p.process(TRAVERSE_BUILDER));
    }
    p.shift();
    let traversal = null;
    for (let i = traversalList.length - 1; i >= 0; i--) {
      traversal = traversalList[i](traversal);
    }
    if (base.type === "Everything" || base.type === "Array" || base.type === "PipeFuncCall") {
      traversal = traverseArray((val) => val, traversal);
    }
    if (traversal === null)
      throw new Error("BUG: unexpected empty traversal");
    return traversal.build(base);
  },
  this_attr(p) {
    const name = p.processString();
    if (name === "null") {
      return { type: "Value", value: null };
    }
    if (name === "true") {
      return { type: "Value", value: true };
    }
    if (name === "false") {
      return { type: "Value", value: false };
    }
    return {
      type: "AccessAttribute",
      name
    };
  },
  neg(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Neg",
      base
    };
  },
  pos(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Pos",
      base
    };
  },
  add(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "+",
      left,
      right
    };
  },
  sub(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "-",
      left,
      right
    };
  },
  mul(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "*",
      left,
      right
    };
  },
  div(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "/",
      left,
      right
    };
  },
  mod(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "%",
      left,
      right
    };
  },
  pow(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op: "**",
      left,
      right
    };
  },
  comp(p) {
    const left = p.process(EXPR_BUILDER);
    const op = p.processString();
    const right = p.process(EXPR_BUILDER);
    return {
      type: "OpCall",
      op,
      left,
      right
    };
  },
  in_range(p) {
    const base = p.process(EXPR_BUILDER);
    const isInclusive = p.getMark().name === "inc_range";
    p.shift();
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "InRange",
      base,
      left,
      right,
      isInclusive
    };
  },
  str(p) {
    let value = "";
    loop:
      while (p.hasMark()) {
        const mark = p.getMark();
        switch (mark.name) {
          case "str_end":
            value += p.processStringEnd();
            break loop;
          case "str_pause":
            value += p.processStringEnd();
            break;
          case "str_start":
            p.shift();
            break;
          case "single_escape": {
            const char = p.slice(1);
            p.shift();
            value += ESCAPE_SEQUENCE[char];
            break;
          }
          case "unicode_hex":
            p.shift();
            value += expandHex(p.processStringEnd());
            break;
          default:
            throw new Error(`unexpected mark: ${mark.name}`);
        }
      }
    return { type: "Value", value };
  },
  integer(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  float(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  sci(p) {
    const strValue = p.processStringEnd();
    return {
      type: "Value",
      value: Number(strValue)
    };
  },
  object(p) {
    const attributes = [];
    while (p.getMark().name !== "object_end") {
      attributes.push(p.process(OBJECT_BUILDER));
    }
    p.shift();
    return {
      type: "Object",
      attributes
    };
  },
  array(p) {
    const elements = [];
    while (p.getMark().name !== "array_end") {
      let isSplat = false;
      if (p.getMark().name === "array_splat") {
        isSplat = true;
        p.shift();
      }
      const value = p.process(EXPR_BUILDER);
      elements.push({
        type: "ArrayElement",
        value,
        isSplat
      });
    }
    p.shift();
    return {
      type: "Array",
      elements
    };
  },
  tuple(p) {
    const members = [];
    while (p.getMark().name !== "tuple_end") {
      members.push(p.process(EXPR_BUILDER));
    }
    p.shift();
    return {
      type: "Tuple",
      members
    };
  },
  func_call(p) {
    let namespace = "global";
    if (p.getMark().name === "namespace") {
      p.shift();
      namespace = p.processString();
    }
    const name = p.processString();
    if (namespace === "global" && name === "select") {
      const result = {
        type: "Select",
        alternatives: []
      };
      while (p.getMark().name !== "func_args_end") {
        if (p.getMark().name === "pair") {
          if (result.fallback)
            throw new GroqQueryError(`unexpected argument to select()`);
          p.shift();
          const condition = p.process(EXPR_BUILDER);
          const value = p.process(EXPR_BUILDER);
          result.alternatives.push({
            type: "SelectAlternative",
            condition,
            value
          });
        } else {
          if (result.fallback)
            throw new GroqQueryError(`unexpected argument to select()`);
          const value = p.process(EXPR_BUILDER);
          result.fallback = value;
        }
      }
      p.shift();
      return result;
    }
    const args = [];
    while (p.getMark().name !== "func_args_end") {
      args.push(p.process(EXPR_BUILDER));
    }
    p.shift();
    if (namespace === "global" && (name === "before" || name === "after")) {
      if (p.parseOptions.mode === "delta") {
        return {
          type: "Context",
          key: name
        };
      }
    }
    if (namespace === "global" && name === "boost" && !p.allowBoost)
      throw new GroqQueryError("unexpected boost");
    const funcs = namespaces[namespace];
    if (!funcs) {
      throw new GroqQueryError(`Undefined namespace: ${namespace}`);
    }
    const func = funcs[name];
    if (!func) {
      throw new GroqQueryError(`Undefined function: ${name}`);
    }
    if (func.arity !== void 0) {
      validateArity(name, func.arity, args.length);
    }
    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {
      throw new GroqQueryError(`Undefined function: ${name}`);
    }
    return {
      type: "FuncCall",
      func,
      name,
      args
    };
  },
  pipecall(p) {
    const base = p.process(EXPR_BUILDER);
    p.shift();
    let namespace = "global";
    if (p.getMark().name === "namespace") {
      p.shift();
      namespace = p.processString();
    }
    if (namespace !== "global") {
      throw new GroqQueryError(`Undefined namespace: ${namespace}`);
    }
    const name = p.processString();
    const args = [];
    const oldAllowBoost = p.allowBoost;
    if (name === "score") {
      p.allowBoost = true;
    }
    for (; ; ) {
      const markName = p.getMark().name;
      if (markName === "func_args_end") {
        break;
      }
      if (name === "order") {
        if (markName === "asc") {
          p.shift();
          args.push({ type: "Asc", base: p.process(EXPR_BUILDER) });
          continue;
        } else if (markName === "desc") {
          p.shift();
          args.push({ type: "Desc", base: p.process(EXPR_BUILDER) });
          continue;
        }
      }
      args.push(p.process(EXPR_BUILDER));
    }
    p.shift();
    p.allowBoost = oldAllowBoost;
    const func = pipeFunctions[name];
    if (!func) {
      throw new GroqQueryError(`Undefined pipe function: ${name}`);
    }
    if (func.arity) {
      validateArity(name, func.arity, args.length);
    }
    return {
      type: "PipeFuncCall",
      func,
      base,
      name,
      args
    };
  },
  pair(p) {
    throw new GroqQueryError(`unexpected =>`);
  },
  and(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "And",
      left,
      right
    };
  },
  or(p) {
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    return {
      type: "Or",
      left,
      right
    };
  },
  not(p) {
    const base = p.process(EXPR_BUILDER);
    return {
      type: "Not",
      base
    };
  },
  asc(p) {
    throw new GroqQueryError("unexpected asc");
  },
  desc(p) {
    throw new GroqQueryError("unexpected desc");
  },
  param(p) {
    const name = p.processString();
    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {
      return {
        type: "Value",
        value: p.parseOptions.params[name]
      };
    }
    return {
      type: "Parameter",
      name
    };
  }
};
const OBJECT_BUILDER = {
  object_expr(p) {
    if (p.getMark().name === "pair") {
      p.shift();
      const condition = p.process(EXPR_BUILDER);
      const value2 = p.process(EXPR_BUILDER);
      return {
        type: "ObjectConditionalSplat",
        condition,
        value: value2
      };
    }
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectAttributeValue",
      name: extractPropertyKey(value),
      value
    };
  },
  object_pair(p) {
    const name = p.process(EXPR_BUILDER);
    if (name.type !== "Value")
      throw new Error("name must be string");
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectAttributeValue",
      name: name.value,
      value
    };
  },
  object_splat(p) {
    const value = p.process(EXPR_BUILDER);
    return {
      type: "ObjectSplat",
      value
    };
  },
  object_splat_this() {
    return {
      type: "ObjectSplat",
      value: { type: "This" }
    };
  }
};
const TRAVERSE_BUILDER = {
  square_bracket(p) {
    const expr = p.process(EXPR_BUILDER);
    const value = tryConstantEvaluate(expr);
    if (value && value.type === "number") {
      return (right) => traverseElement((base) => ({ type: "AccessElement", base, index: value.data }), right);
    }
    if (value && value.type === "string") {
      return (right) => traversePlain((base) => ({ type: "AccessAttribute", base, name: value.data }), right);
    }
    return (right) => traverseArray((base) => ({
      type: "Filter",
      base,
      expr
    }), right);
  },
  slice(p) {
    const isInclusive = p.getMark().name === "inc_range";
    p.shift();
    const left = p.process(EXPR_BUILDER);
    const right = p.process(EXPR_BUILDER);
    const leftValue = tryConstantEvaluate(left);
    const rightValue = tryConstantEvaluate(right);
    if (!leftValue || !rightValue || leftValue.type !== "number" || rightValue.type !== "number") {
      throw new GroqQueryError("slicing must use constant numbers");
    }
    return (rhs) => traverseArray((base) => ({
      type: "Slice",
      base,
      left: leftValue.data,
      right: rightValue.data,
      isInclusive
    }), rhs);
  },
  projection(p) {
    const obj = p.process(EXPR_BUILDER);
    return (right) => traverseProjection((base) => ({ type: "Projection", base, expr: obj }), right);
  },
  attr_access(p) {
    const name = p.processString();
    return (right) => traversePlain((base) => ({ type: "AccessAttribute", base, name }), right);
  },
  deref(p) {
    let attr = null;
    if (p.getMark().name === "deref_attr") {
      p.shift();
      attr = p.processString();
    }
    const wrap = (base) => attr ? { type: "AccessAttribute", base, name: attr } : base;
    return (right) => traversePlain((base) => wrap({
      type: "Deref",
      base
    }), right);
  },
  array_postfix(p) {
    return (right) => traverseArray((base) => ({ type: "ArrayCoerce", base }), right);
  }
};
function extractPropertyKey(node) {
  if (node.type === "AccessAttribute" && !node.base) {
    return node.name;
  }
  if (node.type === "Deref" || node.type === "Map" || node.type === "Projection" || node.type === "Slice" || node.type === "Filter" || node.type === "AccessElement" || node.type === "ArrayCoerce") {
    return extractPropertyKey(node.base);
  }
  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);
}
function validateArity(name, arity, count2) {
  if (typeof arity === "number") {
    if (count2 !== arity) {
      throw new GroqQueryError(`Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count2}.`);
    }
  } else if (arity) {
    if (!arity(count2)) {
      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);
    }
  }
}
class GroqSyntaxError extends Error {
  constructor(position) {
    super(`Syntax error in GROQ query at position ${position}`);
    this.name = "GroqSyntaxError";
    this.position = position;
  }
}
function parse(input, options = {}) {
  const result = parse$1(input);
  if (result.type === "error") {
    throw new GroqSyntaxError(result.position);
  }
  const processor = new MarkProcessor(input, result.marks, options);
  return processor.process(EXPR_BUILDER);
}

//# sourceMappingURL=groq-js.esm.js.map


/***/ }),

/***/ "./node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!*************************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wrap": function() { return /* binding */ wrap; },
/* harmony export */   "unwrap": function() { return /* binding */ unwrap; },
/* harmony export */   "getType": function() { return /* binding */ getType; },
/* harmony export */   "rebaseValue": function() { return /* binding */ rebaseValue; },
/* harmony export */   "applyPatch": function() { return /* binding */ applyPatch; }
/* harmony export */ });
/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ "./node_modules/mendoza/lib/esm/internal-patcher.js");
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ "./node_modules/mendoza/lib/esm/utf8.js");


var Model = /** @class */ (function () {
    function Model(meta) {
        this.meta = meta;
    }
    Model.prototype.wrap = function (data) {
        return this.wrapWithMeta(data, this.meta, this.meta);
    };
    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {
        if (endMeta === void 0) { endMeta = this.meta; }
        return { data: data, startMeta: startMeta, endMeta: endMeta };
    };
    Model.prototype.asObject = function (value) {
        if (!value.content) {
            var fields = {};
            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], val = _b[1];
                fields[key] = this.wrapWithMeta(val, value.startMeta);
            }
            value.content = { type: 'object', fields: fields };
        }
        return value.content;
    };
    Model.prototype.asArray = function (value) {
        var _this = this;
        if (!value.content) {
            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });
            var metas = elements.map(function () { return _this.meta; });
            value.content = { type: 'array', elements: elements, metas: metas };
        }
        return value.content;
    };
    Model.prototype.asString = function (value) {
        if (!value.content) {
            var str = value.data;
            var part = {
                value: str,
                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),
                uses: [],
                startMeta: value.startMeta,
                endMeta: value.endMeta
            };
            value.content = this.stringFromParts([part]);
        }
        return value.content;
    };
    Model.prototype.stringFromParts = function (parts) {
        var str = {
            type: 'string',
            parts: parts
        };
        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var part = parts_1[_i];
            part.uses.push(str);
        }
        return str;
    };
    Model.prototype.objectGetKeys = function (value) {
        if (value.content) {
            return Object.keys(value.content.fields);
        }
        else {
            return Object.keys(value.data);
        }
    };
    Model.prototype.objectGetField = function (value, key) {
        var obj = this.asObject(value);
        return obj.fields[key];
    };
    Model.prototype.arrayGetElement = function (value, idx) {
        var arr = this.asArray(value);
        return arr.elements[idx];
    };
    Model.prototype.finalize = function (content) {
        this.updateEndMeta(content);
        return { content: content, startMeta: this.meta, endMeta: this.meta };
    };
    Model.prototype.markChanged = function (value) {
        return this.wrap(unwrap(value));
    };
    Model.prototype.updateEndMeta = function (content) {
        if (content.type == 'string') {
            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {
                var part = _a[_i];
                part.endMeta = this.meta;
            }
        }
        else {
            if (content.type === 'array') {
                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {
                    var val = _c[_b];
                    if (val.content && val.endMeta !== this.meta) {
                        this.updateEndMeta(val.content);
                    }
                    val.endMeta = this.meta;
                }
            }
            else {
                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {
                    var val = _e[_d];
                    if (val.content && val.endMeta !== this.meta) {
                        this.updateEndMeta(val.content);
                    }
                    val.endMeta = this.meta;
                }
            }
        }
    };
    Model.prototype.copyString = function (value) {
        if (value) {
            var other = this.asString(value);
            return this.stringFromParts(other.parts.slice());
        }
        else {
            return {
                type: 'string',
                parts: []
            };
        }
    };
    Model.prototype.copyObject = function (value) {
        var obj = {
            type: 'object',
            fields: {}
        };
        if (value) {
            var other = this.asObject(value);
            Object.assign(obj.fields, other.fields);
        }
        return obj;
    };
    Model.prototype.copyArray = function (value) {
        var arr = value ? this.asArray(value) : null;
        var elements = arr ? arr.elements : [];
        var metas = arr ? arr.metas : [];
        return {
            type: 'array',
            elements: elements,
            metas: metas
        };
    };
    Model.prototype.objectSetField = function (target, key, value) {
        target.fields[key] = value;
    };
    Model.prototype.objectDeleteField = function (target, key) {
        delete target.fields[key];
    };
    Model.prototype.arrayAppendValue = function (target, value) {
        target.elements.push(value);
        target.metas.push(this.meta);
    };
    Model.prototype.arrayAppendSlice = function (target, source, left, right) {
        var _a, _b;
        var arr = this.asArray(source);
        var samePosition = arr.elements.length === left;
        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));
        if (samePosition) {
            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));
        }
        else {
            for (var i = left; i < right; i++) {
                target.metas.push(this.meta);
            }
        }
    };
    Model.prototype.stringAppendValue = function (target, value) {
        var str = this.asString(value);
        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {
            var part = _a[_i];
            this.stringAppendPart(target, part);
        }
    };
    Model.prototype.stringAppendPart = function (target, part) {
        target.parts.push(part);
        part.uses.push(target);
    };
    Model.prototype.resolveStringPart = function (str, from, len) {
        if (len === 0)
            return from;
        for (var i = from; i < str.parts.length; i++) {
            var part = str.parts[i];
            if (len === part.utf8size) {
                // Matches perfect!
                return i + 1;
            }
            if (len < part.utf8size) {
                // It's a part of this chunk. We now need to split it up.
                this.splitString(part, len);
                return i + 1;
            }
            len -= part.utf8size;
        }
        throw new Error('splitting string out of bounds');
    };
    Model.prototype.splitString = function (part, idx) {
        var leftValue;
        var rightValue;
        var leftSize = idx;
        var rightSize = part.utf8size - leftSize;
        // idx is here in UTF-8 index, not codepoint index.
        // This means we might to adjust for multi-byte characters.
        if (part.utf8size !== part.value.length) {
            var byteCount = 0;
            for (idx = 0; byteCount < leftSize; idx++) {
                var code = part.value.codePointAt(idx);
                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);
                if (size === 4)
                    idx++; // Surrogate pair.
                byteCount += size;
            }
        }
        leftValue = part.value.slice(0, idx);
        rightValue = part.value.slice(idx);
        var newPart = {
            value: rightValue,
            utf8size: rightSize,
            uses: part.uses.slice(),
            startMeta: part.startMeta,
            endMeta: part.endMeta
        };
        part.value = leftValue;
        part.utf8size = leftSize;
        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {
            var use = _a[_i];
            // Insert the new part.
            var idx_1 = use.parts.indexOf(part);
            if (idx_1 === -1)
                throw new Error('bug: mismatch between string parts and use.');
            use.parts.splice(idx_1 + 1, 0, newPart);
        }
    };
    Model.prototype.stringAppendSlice = function (target, source, left, right) {
        var str = this.asString(source);
        var firstPart = this.resolveStringPart(str, 0, left);
        var lastPart = this.resolveStringPart(str, firstPart, right - left);
        for (var i = firstPart; i < lastPart; i++) {
            var part = str.parts[i];
            this.stringAppendPart(target, part);
        }
    };
    return Model;
}());
// Turns a native JavaScript object into a Value with a given origin.
function wrap(data, meta) {
    return { data: data, startMeta: meta, endMeta: meta };
}
// Converts a Value into a native JavaScript type.
function unwrap(value) {
    if (typeof value.data !== 'undefined')
        return value.data;
    var result;
    var content = value.content;
    switch (content.type) {
        case 'string':
            result = content.parts.map(function (part) { return part.value; }).join('');
            break;
        case 'array':
            result = content.elements.map(function (val) { return unwrap(val); });
            break;
        case 'object': {
            result = {};
            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], val = _b[1];
                result[key] = unwrap(val);
            }
        }
    }
    value.data = result;
    return result;
}
// Returns the type of a Value.
function getType(value) {
    if (value.content)
        return value.content.type;
    if (Array.isArray(value.data))
        return 'array';
    if (value.data === null)
        return 'null';
    return typeof value.data;
}
// Updates the `right` value such that it reuses as much as possible from the `left` value.
function rebaseValue(left, right) {
    var leftType = getType(left);
    var rightType = getType(right);
    if (leftType !== rightType)
        return right;
    var leftModel = new Model(left.endMeta);
    var rightModel = new Model(right.endMeta);
    switch (leftType) {
        case 'object': {
            var leftObj = leftModel.asObject(left);
            var rightObj = rightModel.asObject(right);
            // Number of fields which are identical in left and right.
            var identicalFieldCount = 0;
            var leftFieldCount = Object.keys(leftObj.fields).length;
            var rightFieldCount = Object.keys(rightObj.fields).length;
            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], rightVal = _b[1];
                var leftVal = leftObj.fields[key];
                if (leftVal) {
                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);
                    if (rightObj.fields[key] === leftVal) {
                        identicalFieldCount++;
                    }
                }
            }
            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;
            return isIdentical ? left : right;
        }
        case 'array': {
            var leftArr = leftModel.asArray(left);
            var rightArr = rightModel.asArray(right);
            if (leftArr.elements.length !== rightArr.elements.length) {
                break;
            }
            var numRebased = 0;
            for (var i = 0; i < rightArr.elements.length; i++) {
                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);
                if (rightArr.elements[i] !== leftArr.elements[i]) {
                    numRebased++;
                }
            }
            return numRebased === 0 ? left : right;
        }
        case 'null':
        case 'boolean':
        case 'number': {
            if (unwrap(left) === unwrap(right))
                return left;
            break;
        }
        case 'string': {
            var leftRaw = unwrap(left);
            var rightRaw = unwrap(right);
            if (leftRaw === rightRaw)
                return left;
            var result = rightModel.copyString(null);
            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);
            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);
            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);
            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);
            if (0 < prefix) {
                rightModel.stringAppendSlice(result, left, 0, prefix);
            }
            if (prefix < rightLen - suffix) {
                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);
            }
            if (leftLen - suffix < leftLen) {
                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);
            }
            var value = rightModel.finalize(result);
            if (unwrap(value) !== rightRaw)
                throw new Error('incorrect string rebase');
            return value;
        }
    }
    return right;
}
function applyPatch(left, patch, startMeta) {
    var model = new Model(startMeta);
    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);
    return patcher.process();
}
//# sourceMappingURL=incremental-patcher.js.map

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "incremental": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; },
/* harmony export */   "applyPatch": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; }
/* harmony export */ });
/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ "./node_modules/mendoza/lib/esm/incremental-patcher.js");
/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ "./node_modules/mendoza/lib/esm/simple-patcher.js");



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/internal-patcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Patcher": function() { return /* binding */ Patcher; }
/* harmony export */ });
var OPS = [
    'Value',
    'Copy',
    'Blank',
    'ReturnIntoArray',
    'ReturnIntoObject',
    'ReturnIntoObjectSameKey',
    'PushField',
    'PushElement',
    'PushParent',
    'Pop',
    'PushFieldCopy',
    'PushFieldBlank',
    'PushElementCopy',
    'PushElementBlank',
    'ReturnIntoObjectPop',
    'ReturnIntoObjectSameKeyPop',
    'ReturnIntoArrayPop',
    'ObjectSetFieldValue',
    'ObjectCopyField',
    'ObjectDeleteField',
    'ArrayAppendValue',
    'ArrayAppendSlice',
    'StringAppendString',
    'StringAppendSlice'
];
var Patcher = /** @class */ (function () {
    function Patcher(model, root, patch) {
        this.i = 0;
        this.inputStack = [];
        this.outputStack = [];
        this.model = model;
        this.root = root;
        this.patch = patch;
    }
    Patcher.prototype.read = function () {
        return this.patch[this.i++];
    };
    Patcher.prototype.process = function () {
        this.inputStack.push({ value: this.root });
        this.outputStack.push({ value: this.root });
        for (; this.i < this.patch.length;) {
            var opcode = this.read();
            var op = OPS[opcode];
            if (!op)
                throw new Error("Unknown opcode: " + opcode);
            var processor = "process" + op;
            this[processor].apply(this);
        }
        var entry = this.outputStack.pop();
        return this.finalizeOutput(entry);
    };
    Patcher.prototype.inputEntry = function () {
        return this.inputStack[this.inputStack.length - 1];
    };
    Patcher.prototype.inputKey = function (entry, idx) {
        if (!entry.keys) {
            entry.keys = this.model.objectGetKeys(entry.value).sort();
        }
        return entry.keys[idx];
    };
    Patcher.prototype.outputEntry = function () {
        return this.outputStack[this.outputStack.length - 1];
    };
    Patcher.prototype.outputArray = function () {
        var entry = this.outputEntry();
        if (!entry.writeValue) {
            entry.writeValue = this.model.copyArray(entry.value);
        }
        return entry.writeValue;
    };
    Patcher.prototype.outputObject = function () {
        var entry = this.outputEntry();
        if (!entry.writeValue) {
            entry.writeValue = this.model.copyObject(entry.value);
        }
        return entry.writeValue;
    };
    Patcher.prototype.outputString = function () {
        var entry = this.outputEntry();
        if (!entry.writeValue) {
            entry.writeValue = this.model.copyString(entry.value);
        }
        return entry.writeValue;
    };
    Patcher.prototype.finalizeOutput = function (entry) {
        if (entry.writeValue) {
            return this.model.finalize(entry.writeValue);
        }
        else {
            return entry.value;
        }
    };
    // Processors:
    Patcher.prototype.processValue = function () {
        var value = this.model.wrap(this.read());
        this.outputStack.push({ value: value });
    };
    Patcher.prototype.processCopy = function () {
        var input = this.inputEntry();
        this.outputStack.push({ value: input.value });
    };
    Patcher.prototype.processBlank = function () {
        this.outputStack.push({ value: null });
    };
    Patcher.prototype.processReturnIntoArray = function () {
        var entry = this.outputStack.pop();
        var result = this.finalizeOutput(entry);
        var arr = this.outputArray();
        this.model.arrayAppendValue(arr, result);
    };
    Patcher.prototype.processReturnIntoObject = function () {
        var key = this.read();
        var entry = this.outputStack.pop();
        var result = this.finalizeOutput(entry);
        result = this.model.markChanged(result);
        var obj = this.outputObject();
        this.model.objectSetField(obj, key, result);
    };
    Patcher.prototype.processReturnIntoObjectSameKey = function () {
        var input = this.inputEntry();
        var entry = this.outputStack.pop();
        var result = this.finalizeOutput(entry);
        var obj = this.outputObject();
        this.model.objectSetField(obj, input.key, result);
    };
    Patcher.prototype.processPushField = function () {
        var idx = this.read();
        var entry = this.inputEntry();
        var key = this.inputKey(entry, idx);
        var value = this.model.objectGetField(entry.value, key);
        this.inputStack.push({ value: value, key: key });
    };
    Patcher.prototype.processPushElement = function () {
        var idx = this.read();
        var entry = this.inputEntry();
        var value = this.model.arrayGetElement(entry.value, idx);
        this.inputStack.push({ value: value });
    };
    Patcher.prototype.processPop = function () {
        this.inputStack.pop();
    };
    Patcher.prototype.processPushFieldCopy = function () {
        this.processPushField();
        this.processCopy();
    };
    Patcher.prototype.processPushFieldBlank = function () {
        this.processPushField();
        this.processBlank();
    };
    Patcher.prototype.processPushElementCopy = function () {
        this.processPushElement();
        this.processCopy();
    };
    Patcher.prototype.processPushElementBlank = function () {
        this.processPushElement();
        this.processBlank();
    };
    Patcher.prototype.processReturnIntoObjectPop = function () {
        this.processReturnIntoObject();
        this.processPop();
    };
    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {
        this.processReturnIntoObjectSameKey();
        this.processPop();
    };
    Patcher.prototype.processReturnIntoArrayPop = function () {
        this.processReturnIntoArray();
        this.processPop();
    };
    Patcher.prototype.processObjectSetFieldValue = function () {
        this.processValue();
        this.processReturnIntoObject();
    };
    Patcher.prototype.processObjectCopyField = function () {
        this.processPushField();
        this.processCopy();
        this.processReturnIntoObjectSameKey();
        this.processPop();
    };
    Patcher.prototype.processObjectDeleteField = function () {
        var idx = this.read();
        var entry = this.inputEntry();
        var key = this.inputKey(entry, idx);
        var obj = this.outputObject();
        this.model.objectDeleteField(obj, key);
    };
    Patcher.prototype.processArrayAppendValue = function () {
        var value = this.model.wrap(this.read());
        var arr = this.outputArray();
        this.model.arrayAppendValue(arr, value);
    };
    Patcher.prototype.processArrayAppendSlice = function () {
        var left = this.read();
        var right = this.read();
        var str = this.outputArray();
        var val = this.inputEntry().value;
        this.model.arrayAppendSlice(str, val, left, right);
    };
    Patcher.prototype.processStringAppendString = function () {
        var value = this.model.wrap(this.read());
        var str = this.outputString();
        this.model.stringAppendValue(str, value);
    };
    Patcher.prototype.processStringAppendSlice = function () {
        var left = this.read();
        var right = this.read();
        var str = this.outputString();
        var val = this.inputEntry().value;
        this.model.stringAppendSlice(str, val, left, right);
    };
    return Patcher;
}());

//# sourceMappingURL=internal-patcher.js.map

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/simple-patcher.js":
/*!********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyPatch": function() { return /* binding */ applyPatch; }
/* harmony export */ });
/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ "./node_modules/mendoza/lib/esm/internal-patcher.js");
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ "./node_modules/mendoza/lib/esm/utf8.js");


var Model = {
    wrap: function (data) {
        return data;
    },
    finalize: function (b) {
        if (Array.isArray(b)) {
            return b;
        }
        else {
            return b.data;
        }
    },
    markChanged: function (value) {
        return value;
    },
    objectGetKeys: function (value) {
        return Object.keys(value);
    },
    objectGetField: function (value, key) {
        return value[key];
    },
    arrayGetElement: function (value, idx) {
        return value[idx];
    },
    copyObject: function (value) {
        var res = {
            type: 'object',
            data: {}
        };
        if (value !== null) {
            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], val = _b[1];
                res.data[key] = val;
            }
        }
        return res;
    },
    copyArray: function (value) {
        if (value === null)
            return [];
        return value.slice();
    },
    copyString: function (value) {
        return {
            type: 'string',
            data: value === null ? '' : value
        };
    },
    objectSetField: function (target, key, value) {
        target.data[key] = value;
    },
    objectDeleteField: function (target, key) {
        delete target.data[key];
    },
    arrayAppendValue: function (target, value) {
        target.push(value);
    },
    arrayAppendSlice: function (target, source, left, right) {
        target.push.apply(target, source.slice(left, right));
    },
    stringAppendSlice: function (target, source, left, right) {
        var sourceString = source;
        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);
        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);
        target.data += sourceString.slice(leftPos, rightPos);
    },
    stringAppendValue: function (target, value) {
        target.data += value;
    }
};
// Applies a patch on a JavaScript object.
function applyPatch(left, patch) {
    var root = left; // No need to wrap because the representation is the same.
    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);
    return patcher.process();
}
//# sourceMappingURL=simple-patcher.js.map

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/utf8.js":
/*!**********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/utf8.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utf8charSize": function() { return /* binding */ utf8charSize; },
/* harmony export */   "utf8stringSize": function() { return /* binding */ utf8stringSize; },
/* harmony export */   "utf8resolveIndex": function() { return /* binding */ utf8resolveIndex; },
/* harmony export */   "commonPrefix": function() { return /* binding */ commonPrefix; },
/* harmony export */   "commonSuffix": function() { return /* binding */ commonSuffix; }
/* harmony export */ });
function utf8charSize(code) {
    if (code >> 16) {
        return 4;
    }
    else if (code >> 11) {
        return 3;
    }
    else if (code >> 7) {
        return 2;
    }
    else {
        return 1;
    }
}
function utf8stringSize(str) {
    var b = 0;
    for (var i = 0; i < str.length; i++) {
        var code = str.codePointAt(i);
        var size = utf8charSize(code);
        if (size == 4)
            i++;
        b += size;
    }
    return b;
}
/** Converts an UTF-8 byte index into a UCS-2 index. */
function utf8resolveIndex(str, idx, start) {
    if (start === void 0) { start = 0; }
    var byteCount = start;
    var ucsIdx = 0;
    for (ucsIdx = start; byteCount < idx; ucsIdx++) {
        var code = str.codePointAt(ucsIdx);
        var size = utf8charSize(code);
        if (size === 4)
            ucsIdx++; // Surrogate pair.
        byteCount += size;
    }
    return ucsIdx;
}
function commonPrefix(str, str2) {
    var len = Math.min(str.length, str2.length);
    var b = 0;
    for (var i = 0; i < len;) {
        var aPoint = str.codePointAt(i);
        var bPoint = str2.codePointAt(i);
        if (aPoint !== bPoint)
            return b;
        var size = utf8charSize(aPoint);
        b += size;
        i += size === 4 ? 2 : 1;
    }
    return b;
}
function commonSuffix(str, str2, prefix) {
    if (prefix === void 0) { prefix = 0; }
    var len = Math.min(str.length, str2.length) - prefix;
    var b = 0;
    for (var i = 0; i < len;) {
        var aPoint = str.codePointAt(str.length - 1 - i);
        var bPoint = str2.codePointAt(str2.length - 1 - i);
        if (aPoint !== bPoint)
            return b;
        var size = utf8charSize(aPoint);
        b += size;
        i += size === 4 ? 2 : 1;
    }
    return b;
}
//# sourceMappingURL=utf8.js.map

/***/ }),

/***/ "./node_modules/throttle-debounce/cjs/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/throttle-debounce/cjs/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset).
 * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function}  A new, throttled, function.
 */
function throttle (delay, noTrailing, callback, debounceMode) {
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */
  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  } // `noTrailing` defaults to falsy.


  if (typeof noTrailing !== 'boolean') {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = undefined;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      /*
       * In throttle mode, if `delay` time has been exceeded, execute
       * `callback`.
       */
      exec();
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

/* eslint-disable no-undefined */
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @returns {Function} A new, debounced function.
 */

function debounce (delay, atBegin, callback) {
  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
}

exports.debounce = debounce;
exports.throttle = throttle;
//# sourceMappingURL=index.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZ3JvcS1zdG9yZS9kaXN0L2Jyb3dzZXIvZ3JvcS1zdG9yZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZGVlcC1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC9ncm9xLWpzLmVzbS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lbmRvemEvbGliL2VzbS9pbmNyZW1lbnRhbC1wYXRjaGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vc2ltcGxlLXBhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vdXRmOC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Rocm90dGxlLWRlYm91bmNlL2Nqcy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGNBQWMsd0RBQXdELFFBQVEsbUJBQU8sQ0FBQyw2Q0FBTSxPQUFPLG1CQUFPLENBQUMsZ0VBQWlCLEtBQUssbUJBQU8sQ0FBQyx3RUFBbUIsSUFBSSxtQkFBTyxDQUFDLDJEQUFTLElBQUksbUJBQU8sQ0FBQyx3REFBUyxFQUFFLGFBQWEsb0NBQW9DLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHdCQUF3QixrQkFBa0IsMkhBQTJILDhCQUE4QiwwQkFBMEIsUUFBUSxFQUFFLG1HQUFtRyxNQUFNLElBQUkscUJBQXFCLFNBQVMsT0FBTyxLQUFLLG9E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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRztBQUN0QyxnREFBZ0QsR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9EQUFvRDtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxlQUFlLHFCQUFxQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsVUFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsS0FBSztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFVBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEVBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2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QUNBOzs7QUFHQTtBQUNBLDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQiIsImZpbGUiOiJzdGF0aWMvY2h1bmtzL3ZlbmRvcnMtbm9kZV9tb2R1bGVzX3Nhbml0eV9ncm9xLXN0b3JlX2Rpc3RfYnJvd3Nlcl9ncm9xLXN0b3JlX2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZShlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZX12YXIgcj1lKHJlcXVpcmUoXCJncm9xXCIpKSx0PWUocmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKSksbj1yZXF1aXJlKFwidGhyb3R0bGUtZGVib3VuY2VcIiksbz1yZXF1aXJlKFwiZ3JvcS1qc1wiKSxpPXJlcXVpcmUoXCJtZW5kb3phXCIpO2Z1bmN0aW9uIHUoKXtyZXR1cm4odT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt2YXIgdD1hcmd1bWVudHNbcl07Zm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pfXJldHVybiBlfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIHMoZSxyLHQpe3ZhciBuLG89ci50b2tlbixpPW5ldyBlKFwiaHR0cHM6Ly9cIityLnByb2plY3RJZCtcIi5hcGkuc2FuaXR5LmlvL3YxL2RhdGEvbGlzdGVuL1wiK3IuZGF0YXNldCtcIj9xdWVyeT0qJmVmZmVjdEZvcm1hdD1tZW5kb3phXCIse3dpdGhDcmVkZW50aWFsczohMCxoZWFkZXJzOm8/e0F1dGhvcml6YXRpb246XCJCZWFyZXIgXCIrb306dm9pZCAwfSk7cmV0dXJuIGkuYWRkRXZlbnRMaXN0ZW5lcihcIndlbGNvbWVcIix0Lm9wZW4sITEpLGkuYWRkRXZlbnRMaXN0ZW5lcihcIm11dGF0aW9uXCIsKG49dC5uZXh0LGZ1bmN0aW9uKGUpe3ZhciByO3RyeXtyPUpTT04ucGFyc2UoZS5kYXRhKX1jYXRjaChlKXtyZXR1cm59bihyKX0pLCExKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFubmVsRXJyb3JcIixmdW5jdGlvbihlKXt2YXIgcjtpLmNsb3NlKCk7dHJ5e3I9SlNPTi5wYXJzZShlLmRhdGEpfWNhdGNoKGUpe3JldHVybiB2b2lkIHQuZXJyb3IobmV3IEVycm9yKFwiVW5rbm93biBlcnJvciBwYXJzaW5nIGxpc3RlbmVyIG1lc3NhZ2VcIikpfXQuZXJyb3IobmV3IEVycm9yKHIubWVzc2FnZXx8ci5lcnJvcnx8XCJMaXN0ZW5lciByZXR1cm5lZCBIVFRQIFwiK3Iuc3RhdHVzQ29kZSkpfSwhMSksaS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbihlKXt2YXIgcj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24ub3JpZ2luLG49cj9cIiwgYW5kIHRoYXQgdGhlIENPUlMtb3JpZ2luIChcIityK1wiKSBpcyBhbGxvd2VkXCI6XCJcIixvPWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJtZXNzYWdlXCJpbiBlfShlKT9cIiAoXCIrZS5tZXNzYWdlK1wiKVwiOlwiXCI7dC5lcnJvcihuZXcgRXJyb3IoXCJFcnJvciBlc3RhYmxpc2hpbmcgbGlzdGVuZXIgLSBjaGVjayB0aGF0IHRoZSBwcm9qZWN0IElEIGFuZCBkYXRhc2V0IGFyZSBjb3JyZWN0XCIrbitvKSl9LCExKSx7dW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGkuY2xvc2UoKSl9fX1mdW5jdGlvbiBjKGUpe3JldHVybiBlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9lLl9pZC5zbGljZSg3KTplLl9pZH1mdW5jdGlvbiBhKGUscil7dmFyIHQ9dSh7fSxlKTtyZXR1cm4gZGVsZXRlIHQuX3JldixpLmFwcGx5UGF0Y2godCxyKX1mdW5jdGlvbiBmKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIGQoKXt2YXIgZSxyLHQ9KGU9W1wiKltfaWQgPT0gJGlkXVswXVwiXSxyfHwocj1lLnNsaWNlKDApKSxlLnJhdz1yLGUpO3JldHVybiBkPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gdihlLHIsdCl7aWYoIWUucyl7aWYodCBpbnN0YW5jZW9mIGwpe2lmKCF0LnMpcmV0dXJuIHZvaWQodC5vPXYuYmluZChudWxsLGUscikpOzEmciYmKHI9dC5zKSx0PXQudn1pZih0JiZ0LnRoZW4pcmV0dXJuIHZvaWQgdC50aGVuKHYuYmluZChudWxsLGUsciksdi5iaW5kKG51bGwsZSwyKSk7ZS5zPXIsZS52PXQ7dmFyIG49ZS5vO24mJm4oZSl9fXZhciBsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihyLHQpe3ZhciBuPW5ldyBlLG89dGhpcy5zO2lmKG8pe3ZhciBpPTEmbz9yOnQ7aWYoaSl7dHJ5e3YobiwxLGkodGhpcy52KSl9Y2F0Y2goZSl7dihuLDIsZSl9cmV0dXJuIG59cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMubz1mdW5jdGlvbihlKXt0cnl7dmFyIG89ZS52OzEmZS5zP3YobiwxLHI/cihvKTpvKTp0P3YobiwxLHQobykpOnYobiwyLG8pfWNhdGNoKGUpe3YobiwyLGUpfX0sbn0sZX0oKTtmdW5jdGlvbiBoKGUpe3JldHVybiBlIGluc3RhbmNlb2YgbCYmMSZlLnN9dmFyIG09ZnVuY3Rpb24oZSl7dmFyIHI9ZS5wcm9qZWN0SWQsdD1lLmRhdGFzZXQsbj1lLnRva2VuLG89ZS5kb2N1bWVudExpbWl0O3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZldGNoKFwiaHR0cHM6Ly9cIityK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9leHBvcnQvXCIrdCx7Y3JlZGVudGlhbHM6XCJpbmNsdWRlXCIsaGVhZGVyczpuP3tBdXRob3JpemF0aW9uOlwiQmVhcmVyIFwiK259OnZvaWQgMH0pKS50aGVuKGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIocil7dmFyIHQsbixpPWZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZWFkIGJvZHkgZnJvbSByZXNwb25zZVwiKTt2YXIgcix0PSExO2Z1bmN0aW9uIG4oKXt0PSEwLHImJnIuY2FuY2VsKCl9cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7c3RhcnQ6ZnVuY3Rpb24obyl7cj1lLmdldFJlYWRlcigpO3ZhciBpPW5ldyBUZXh0RGVjb2Rlcix1PVwiXCI7ci5yZWFkKCkudGhlbihmdW5jdGlvbiBlKHMpe3RyeXtpZihzLmRvbmUpcmV0dXJuIHQ/UHJvbWlzZS5yZXNvbHZlKCk6MD09PSh1PXUudHJpbSgpKS5sZW5ndGg/KG8uY2xvc2UoKSxQcm9taXNlLnJlc29sdmUoKSk6KG8uZW5xdWV1ZShKU09OLnBhcnNlKHUpKSxvLmNsb3NlKCksUHJvbWlzZS5yZXNvbHZlKCkpO2Zvcih2YXIgYz0odSs9aS5kZWNvZGUocy52YWx1ZSx7c3RyZWFtOiEwfSkpLnNwbGl0KFwiXFxuXCIpLGE9MDthPGMubGVuZ3RoLTE7KythKXt2YXIgZj1jW2FdLnRyaW0oKTtpZigwPT09Zi5sZW5ndGgpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO3RyeXtvLmVucXVldWUoSlNPTi5wYXJzZShmKSl9Y2F0Y2goZSl7cmV0dXJuIG8uZXJyb3IoZSksbigpLFByb21pc2UucmVzb2x2ZSgpfX1pZih1PWNbYy5sZW5ndGgtMV0sIXIpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO3ZhciBkPWZ1bmN0aW9uKHQsbil7dHJ5e3ZhciBvPVByb21pc2UucmVzb2x2ZShyLnJlYWQoKSkudGhlbihmdW5jdGlvbihyKXtlKHIpfSl9Y2F0Y2goZSl7cmV0dXJuIG4oZSl9cmV0dXJuIG8mJm8udGhlbj9vLnRoZW4odm9pZCAwLG4pOm99KDAsZnVuY3Rpb24oZSl7by5lcnJvcihlKX0pO3JldHVybiBQcm9taXNlLnJlc29sdmUoZCYmZC50aGVuP2QudGhlbihmdW5jdGlvbigpe30pOnZvaWQgMCl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0pLmNhdGNoKGZ1bmN0aW9uKGUpe3JldHVybiBvLmVycm9yKGUpfSl9LGNhbmNlbDpufSl9KGUuYm9keSkuZ2V0UmVhZGVyKCksdT1bXSxzPWZ1bmN0aW9uKGUscil7dmFyIHQ7ZG97dmFyIG49ZSgpO2lmKG4mJm4udGhlbil7aWYoIWgobikpe3Q9ITA7YnJlYWt9bj1uLnZ9dmFyIG89cigpO2lmKGgobykmJihvPW8udiksIW8pcmV0dXJuIG59d2hpbGUoIW8udGhlbik7dmFyIGk9bmV3IGwsdT12LmJpbmQobnVsbCxpLDIpO3JldHVybih0P24udGhlbihzKTpvLnRoZW4oYykpLnRoZW4odm9pZCAwLHUpLGk7ZnVuY3Rpb24gcyh0KXtmb3Iobj10O2gobz1yKCkpJiYobz1vLnYpLG87KXtpZihvLnRoZW4pcmV0dXJuIHZvaWQgby50aGVuKGMpLnRoZW4odm9pZCAwLHUpO2lmKChuPWUoKSkmJm4udGhlbil7aWYoIWgobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fX12KGksMSxuKX1mdW5jdGlvbiBjKHQpe2lmKHQpe2Rve2lmKChuPWUoKSkmJm4udGhlbil7aWYoIWgobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fWlmKGgodD1yKCkpJiYodD10LnYpLCF0KXJldHVybiB2b2lkIHYoaSwxLG4pfXdoaWxlKCF0LnRoZW4pO3QudGhlbihjKS50aGVuKHZvaWQgMCx1KX1lbHNlIHYoaSwxLG4pfX0oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGkucmVhZCgpKS50aGVuKGZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKGUpe3JldHVybiEhZSYmXCJlcnJvclwiaW4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUuZXJyb3ImJm51bGwhPT1lLmVycm9yJiZcImRlc2NyaXB0aW9uXCJpbiBlLmVycm9yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5lcnJvci5kZXNjcmlwdGlvbiYmIShcIl9pZFwiaW4gZSl9KG49KHQ9ZSkudmFsdWUpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHN0cmVhbWluZyBkYXRhc2V0OiBcIituLmVycm9yKTtpZihuJiYhbi5faWQuc3RhcnRzV2l0aChcIl8uXCIpJiZ1LnB1c2gobiksbyYmdS5sZW5ndGg+byl0aHJvdyBpLmNhbmNlbChcIlJlYWNoZWQgZG9jdW1lbnQgbGltaXRcIiksbmV3IEVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6IFJlYWNoZWQgbGltaXQgb2YgXCIrbytcIiBkb2N1bWVudHNcIil9KX0sZnVuY3Rpb24oKXtyZXR1cm4hdC5kb25lfSk7cmV0dXJuIHMmJnMudGhlbj9zLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHV9KTp1fXZhciB0PWZ1bmN0aW9uKCl7aWYoMjAwIT09ZS5zdGF0dXMpcmV0dXJuIFByb21pc2UucmVzb2x2ZShlLmpzb24oKSkudGhlbihmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogXCIrKFwib2JqZWN0XCI9PXR5cGVvZihyPWUpJiZcImVycm9yXCJpbiByJiZcIm1lc3NhZ2VcImluIHI/ci5tZXNzYWdlfHxyLmVycm9yOlwiPHVua25vd24gZXJyb3I+XCIpKTt2YXIgcn0pfSgpO3JldHVybiB0JiZ0LnRoZW4/dC50aGVuKHIpOnIoKX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19O2V4cG9ydHMuZ3JvcT1yLGV4cG9ydHMuZ3JvcVN0b3JlPWZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKCl7dmFyIGU9W1wiRXZlbnRTb3VyY2VcIixcIlJlYWRhYmxlU3RyZWFtXCIsXCJmZXRjaFwiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIShlIGluIHdpbmRvdyl9KTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgbm90IHN1cHBvcnRlZC4gTWlzc2luZyBicm93c2VyIEFQSXM6IFwiK2Uuam9pbihcIiwgXCIpKX0oKSxlLnRva2VuKXRocm93IG5ldyBFcnJvcihcImB0b2tlbmAgb3B0aW9uIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIGJyb3dzZXJcIik7cmV0dXJuIGZ1bmN0aW9uKGUsaSl7dmFyIHYsbD1mdW5jdGlvbihlLHIpe3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGgoKSkudGhlbihmdW5jdGlvbigpe3ZhciB0PW8ucGFyc2UoZSx7cGFyYW1zOnJ9KTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG8uZXZhbHVhdGUodCx7ZGF0YXNldDptLHBhcmFtczpyfSkpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0KCl9KX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19LGg9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIHZ8fCh2PWZ1bmN0aW9uKGUscix0KXt2YXIgbj10LmdldERvY3VtZW50cyxvPXQuRXZlbnRTb3VyY2UsaT1lLnByb2plY3RJZCxkPWUuZGF0YXNldCx2PWUub3ZlcmxheURyYWZ0cyxsPWUuZG9jdW1lbnRMaW1pdDtpZighZS5saXN0ZW4pcmV0dXJue3Vuc3Vic2NyaWJlOmYsbG9hZGVkOm4oe3Byb2plY3RJZDppLGRhdGFzZXQ6ZCxkb2N1bWVudExpbWl0Omx9KS50aGVuKGopLnRoZW4oZil9O3ZhciBoLG0scCx3LGIsZyx5PW5ldyBNYXAsUD1bXSxFPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGUscil7bT1lLHA9cn0pO3JldHVybnt1bnN1YnNjcmliZTpzKG8sZSx7bmV4dDpmdW5jdGlvbihlKXtoPyhmdW5jdGlvbihlKXtpZihlLmVmZmVjdHMmJiFlLmRvY3VtZW50SWQuc3RhcnRzV2l0aChcIl8uXCIpKXt2YXIgcj15LmdldChlLmRvY3VtZW50SWQpfHxudWxsOyFmdW5jdGlvbihlLHIpe3ZhciB0PXkuZ2V0KGUpLG49aHx8W10sbz10P24uaW5kZXhPZih0KTotMTstMT09PW8mJnI/KG4ucHVzaChyKSx5LnNldChlLHIpKTpyPyhuLnNwbGljZShvLDEscikseS5zZXQoZSxyKSk6KG4uc3BsaWNlKG8sMSkseS5kZWxldGUoZSkpfShlLmRvY3VtZW50SWQsYShyLGUuZWZmZWN0cy5hcHBseSkpfX0oZSksZnVuY3Rpb24oZSxyKXtjbGVhclRpbWVvdXQoZyksYiE9PXIudHJhbnNhY3Rpb25JZCYmdz8oaih3KSxiPXZvaWQgMCk6KGI9ci50cmFuc2FjdGlvbklkLHc9ZS5zbGljZSgpKSxnPXNldFRpbWVvdXQoaiwyNSxlLnNsaWNlKCkpfShoLGUpKTpQLnB1c2goZSl9LG9wZW46ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShuKHtwcm9qZWN0SWQ6aSxkYXRhc2V0OmQsZG9jdW1lbnRMaW1pdDpsfSkpLnRoZW4oZnVuY3Rpb24oZSl7KGg9ZnVuY3Rpb24oZSxyKXt2YXIgdD1uZXcgTWFwO3JldHVybiByLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHI9dC5nZXQoZS5kb2N1bWVudElkKXx8W107ci5wdXNoKGUpLHQuc2V0KGUuZG9jdW1lbnRJZCxyKX0pLHQuZm9yRWFjaChmdW5jdGlvbihyLHQpe3ZhciBuPWUuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5faWQ9PT10fSk7aWYobil7dmFyIG89ITEsaT1uO3IuZm9yRWFjaChmdW5jdGlvbihlKXsobz1vfHxlLnByZXZpb3VzUmV2PT09bi5fcmV2KSYmZS5lZmZlY3RzJiYoaT1hKGksZS5lZmZlY3RzLmFwcGx5KSl9KSxlLnNwbGljZShlLmluZGV4T2YobiksMSxpKX1lbHNlIGNvbnNvbGUud2FybihcIlJlY2VpdmVkIG11dGF0aW9uIGZvciBtaXNzaW5nIGRvY3VtZW50ICVzXCIsdCl9KSxlfShlLFApKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB5LnNldChlLl9pZCxlKX0pLGooaCksbSgpfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sZXJyb3I6ZnVuY3Rpb24oZSl7cmV0dXJuIHAoZSl9fSkudW5zdWJzY3JpYmUsbG9hZGVkOkV9O2Z1bmN0aW9uIGooZSl7dz12b2lkIDAsZz12b2lkIDAsYj12b2lkIDAscih2P2Z1bmN0aW9uKGUpe3ZhciByPW5ldyBNYXA7cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1yLmdldChjKGUpKTtlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9yLnNldChjKGUpLGZ1bmN0aW9uKGUpe3JldHVybiB1KHt9LGUse19pZDpjKGUpfSl9KGUpKTp0fHxyLnNldChlLl9pZCxlKX0pLEFycmF5LmZyb20oci52YWx1ZXMoKSl9KGUpOmUpfX0oZSxmdW5jdGlvbihlKXttPWUscCgpfSxpKSksUHJvbWlzZS5yZXNvbHZlKHYubG9hZGVkKS50aGVuKGZ1bmN0aW9uKCl7fSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sbT1bXSxwPW4udGhyb3R0bGUoZS5zdWJzY3JpcHRpb25UaHJvdHRsZU1zfHw1MCxmdW5jdGlvbigpe3cuZm9yRWFjaChiKX0pLHc9W107ZnVuY3Rpb24gYihlKXtyZXR1cm4gbChlLnF1ZXJ5LGUucGFyYW1zKS50aGVuKGZ1bmN0aW9uKHIpe1wicHJldmlvdXNSZXN1bHRcImluIGUmJnQoZS5wcmV2aW91c1Jlc3VsdCxyKXx8KGUucHJldmlvdXNSZXN1bHQ9cixlLmNhbGxiYWNrKHZvaWQgMCxyKSl9KS5jYXRjaChmdW5jdGlvbihyKXtlLmNhbGxiYWNrKHIpfSl9cmV0dXJue3F1ZXJ5OmwsZ2V0RG9jdW1lbnQ6ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoaCgpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGwocihkKCkpLHtpZDplfSl9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxnZXREb2N1bWVudHM6ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoaCgpKS50aGVuKGZ1bmN0aW9uKCl7dmFyIHI9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuJypbX2lkID09IFwiJytlKydcIl1bMF0nfSkuam9pbihcIixcXG5cIik7cmV0dXJuIGwoXCJbXCIrcitcIl1cIil9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxzdWJzY3JpYmU6ZnVuY3Rpb24ocix0LG4pe2lmKCFlLmxpc3Rlbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGBzdWJzY3JpYmUoKWAgd2l0aG91dCBgbGlzdGVuOiB0cnVlYFwiKTt2YXIgbz17cXVlcnk6cixwYXJhbXM6dCxjYWxsYmFjazpufTt3LnB1c2gobyk7dmFyIGk9ITE7cmV0dXJuIGIobykse3Vuc3Vic2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJuIGl8fChpPSEwLHcuc3BsaWNlKHcuaW5kZXhPZihvKSwxKSksUHJvbWlzZS5yZXNvbHZlKCl9fX0sY2xvc2U6ZnVuY3Rpb24oKXtyZXR1cm4gcC5jYW5jZWwoKSx2P3YudW5zdWJzY3JpYmUoKTpQcm9taXNlLnJlc29sdmUoKX19fShlLHtFdmVudFNvdXJjZTp3aW5kb3cuRXZlbnRTb3VyY2UsZ2V0RG9jdW1lbnRzOm19KX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm9xLXN0b3JlLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nMywgbWFya3MsIHBhcnNlT3B0aW9ucykge1xuICAgIHRoaXMuYWxsb3dCb29zdCA9IGZhbHNlO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nMztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG4gIH1cbiAgaGFzTWFyayhwb3MgPSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXggKyBwb3MgPCB0aGlzLm1hcmtzLmxlbmd0aDtcbiAgfVxuICBnZXRNYXJrKHBvcyA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrc1t0aGlzLmluZGV4ICsgcG9zXTtcbiAgfVxuICBzaGlmdCgpIHtcbiAgICB0aGlzLmluZGV4ICs9IDE7XG4gIH1cbiAgcHJvY2Vzcyh2aXNpdG9yKSB7XG4gICAgY29uc3QgbWFyayA9IHRoaXMubWFya3NbdGhpcy5pbmRleF07XG4gICAgdGhpcy5zaGlmdCgpO1xuICAgIGNvbnN0IGZ1bmMgPSB2aXNpdG9yW21hcmsubmFtZV07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gaGFuZGxlcjogJHttYXJrLm5hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmNhbGwodmlzaXRvciwgdGhpcywgbWFyayk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZygpIHtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICB9XG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XG4gICAgY29uc3QgcHJldiA9IHRoaXMubWFya3NbdGhpcy5pbmRleCAtIDFdO1xuICAgIGNvbnN0IGN1cnIgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdO1xuICAgIHRoaXMuc2hpZnQoKTtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocHJldi5wb3NpdGlvbiwgY3Vyci5wb3NpdGlvbik7XG4gIH1cbiAgc2xpY2UobGVuKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XS5wb3NpdGlvbjtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UocG9zLCBwb3MgKyBsZW4pO1xuICB9XG59XG5jb25zdCBSRkMzMzM5X1JFR0VYID0gL15cXGR7NH0tXFxkezJ9LVxcZHsyfVRcXGR7Mn06XFxkezJ9OlxcZHsyfShcXC5cXGQrKT8oWnwoWy0rXVxcZHsyfTpcXGR7Mn0pKSQvO1xuZnVuY3Rpb24gcGFyc2VSRkMzMzM5KHN0cikge1xuICBpZiAoUkZDMzMzOV9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoc3RyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZvcm1hdFJGQzMzMzkoZCkge1xuICBjb25zdCB5ZWFyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENGdWxsWWVhcigpLCA0KTtcbiAgY29uc3QgbW9udGggPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01vbnRoKCkgKyAxLCAyKTtcbiAgY29uc3QgZGF5ID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENEYXRlKCksIDIpO1xuICBjb25zdCBob3VyID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENIb3VycygpLCAyKTtcbiAgY29uc3QgbWludXRlID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNaW51dGVzKCksIDIpO1xuICBjb25zdCBzZWNvbmQgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ1NlY29uZHMoKSwgMik7XG4gIGxldCBmcmFjdGlvbmFsU2Vjb25kID0gXCJcIjtcbiAgY29uc3QgbWlsbGlzID0gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgaWYgKG1pbGxpcyAhPSAwKSB7XG4gICAgZnJhY3Rpb25hbFNlY29uZCA9IGAuJHthZGRMZWFkaW5nWmVybyhtaWxsaXMsIDMpfWA7XG4gIH1cbiAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQke2hvdXJ9OiR7bWludXRlfToke3NlY29uZH0ke2ZyYWN0aW9uYWxTZWNvbmR9WmA7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKCk7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgc3RyID0gYDAke3N0cn1gO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nMykge1xuICByZXR1cm4gc3RyaW5nMy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG5mdW5jdGlvbiBwYXRoUmVnRXhwKHBhdHRlcm4pIHtcbiAgY29uc3QgcmUgPSBbXTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhdHRlcm4uc3BsaXQoXCIuXCIpKSB7XG4gICAgaWYgKHBhcnQgPT09IFwiKlwiKSB7XG4gICAgICByZS5wdXNoKFwiW14uXStcIik7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSBcIioqXCIpIHtcbiAgICAgIHJlLnB1c2goXCIuKlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmUucHVzaChlc2NhcGVSZWdFeHAocGFydCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmUuam9pbihcIi5cIil9JGApO1xufVxuY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIHRoaXMucGF0dGVyblJlID0gcGF0aFJlZ0V4cChwYXR0ZXJuKTtcbiAgfVxuICBtYXRjaGVzKHN0cikge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm5SZS50ZXN0KHN0cik7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnBhdHRlcm47XG4gIH1cbn1cbmNsYXNzIFN0cmVhbVZhbHVlIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgdGhpcy50eXBlID0gXCJzdHJlYW1cIjtcbiAgICB0aGlzLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICB0aGlzLnRpY2tlciA9IG51bGw7XG4gICAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGFzeW5jIGdldCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHRoaXMpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGZvciAoOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLl9uZXh0VGljaygpO1xuICAgIH1cbiAgfVxuICBfbmV4dFRpY2soKSB7XG4gICAgaWYgKHRoaXMudGlja2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gICAgfVxuICAgIGxldCBjdXJyZW50UmVzb2x2ZXI7XG4gICAgY29uc3Qgc2V0dXBUaWNrZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLnRpY2tlciA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKTtcbiAgICAgIHNldHVwVGlja2VyKCk7XG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRpY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgIHRpY2soKTtcbiAgICB9O1xuICAgIHNldHVwVGlja2VyKCk7XG4gICAgZmV0Y2goKTtcbiAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gIH1cbn1cbmNsYXNzIFN0YXRpY1ZhbHVlIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgdHlwZSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiYXJyYXlcIjtcbiAgfVxuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5kYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaXRlcmF0ZSBvdmVyOiAke3RoaXMudHlwZX1gKTtcbiAgfVxufVxuY29uc3QgTlVMTF9WQUxVRSA9IG5ldyBTdGF0aWNWYWx1ZShudWxsLCBcIm51bGxcIik7XG5jb25zdCBUUlVFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKHRydWUsIFwiYm9vbGVhblwiKTtcbmNvbnN0IEZBTFNFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKGZhbHNlLCBcImJvb2xlYW5cIik7XG5jbGFzcyBEYXRlVGltZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGUpIHtcbiAgICB0aGlzLmRhdGUgPSBkYXRlO1xuICB9XG4gIHN0YXRpYyBwYXJzZVRvVmFsdWUoc3RyKSB7XG4gICAgY29uc3QgZGF0ZSA9IHBhcnNlUkZDMzMzOShzdHIpO1xuICAgIGlmIChkYXRlKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgPT0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgYWRkKHNlY3MpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IERhdGUodGhpcy5kYXRlLmdldFRpbWUoKSk7XG4gICAgY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDFlMyk7XG4gICAgcmV0dXJuIG5ldyBEYXRlVGltZShjb3B5KTtcbiAgfVxuICBkaWZmZXJlbmNlKG90aGVyKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCkpIC8gMWUzO1xuICB9XG4gIGNvbXBhcmVUbyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpIC0gb3RoZXIuZGF0ZS5nZXRUaW1lKCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGZvcm1hdFJGQzMzMzkodGhpcy5kYXRlKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfVxufVxuZnVuY3Rpb24gZnJvbU51bWJlcihudW0pIHtcbiAgaWYgKE51bWJlci5pc0Zpbml0ZShudW0pKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShudW0sIFwibnVtYmVyXCIpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufVxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShzdHIsIFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZnJvbURhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoZHQsIFwiZGF0ZXRpbWVcIik7XG59XG5mdW5jdGlvbiBmcm9tUGF0aChwYXRoMikge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgyLCBcInBhdGhcIik7XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmoubmV4dCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZnJvbUpTKHZhbCkge1xuICBpZiAoaXNJdGVyYXRvcih2YWwpKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB2YWwpIHtcbiAgICAgICAgeWllbGQgZnJvbUpTKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHZhbCwgZ2V0VHlwZSh2YWwpKTtcbn1cbmZ1bmN0aW9uIGdldFR5cGUoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBcImFycmF5XCI7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgcmV0dXJuIFwicGF0aFwiO1xuICB9XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gXCJkYXRldGltZVwiO1xuICB9XG4gIHJldHVybiB0eXBlb2YgZGF0YTtcbn1cbmNvbnN0IFRZUEVfT1JERVIgPSB7XG4gIGRhdGV0aW1lOiAxLFxuICBudW1iZXI6IDIsXG4gIHN0cmluZzogMyxcbiAgYm9vbGVhbjogNFxufTtcbmZ1bmN0aW9uIHBhcnRpYWxDb21wYXJlKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRUeXBlKGEpO1xuICBjb25zdCBiVHlwZSA9IGdldFR5cGUoYik7XG4gIGlmIChhVHlwZSAhPT0gYlR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKGFUeXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgaWYgKGEgPCBiKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoYSA+IGIpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB0b3RhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSk7XG4gIGNvbnN0IGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgY29uc3QgYVR5cGVPcmRlciA9IFRZUEVfT1JERVJbYVR5cGVdIHx8IDEwMDtcbiAgY29uc3QgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcbiAgaWYgKGFUeXBlT3JkZXIgIT09IGJUeXBlT3JkZXIpIHtcbiAgICByZXR1cm4gYVR5cGVPcmRlciAtIGJUeXBlT3JkZXI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGEsIGIpO1xuICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgcmVzdWx0ID0gMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgQ0hBUlMgPSAvKFteIUAjJCVeJiooKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbmNvbnN0IENIQVJTX1dJVEhfV0lMRENBUkQgPSAvKFteIUAjJCVeJigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nO1xuY29uc3QgRURHRV9DSEFSUyA9IC8oXFxiXFwuK3xcXC4rXFxiKS9nO1xuY29uc3QgTUFYX1RFUk1fTEVOR1RIID0gMTAyNDtcbmZ1bmN0aW9uIG1hdGNoVGV4dCh0b2tlbnMsIHBhdHRlcm5zKSB7XG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcGF0dGVybnMuZXZlcnkoKHBhdHRlcm4pID0+IHBhdHRlcm4odG9rZW5zKSk7XG59XG5mdW5jdGlvbiBtYXRjaFRva2VuaXplKHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSUykgfHwgW107XG59XG5mdW5jdGlvbiBtYXRjaEFuYWx5emVQYXR0ZXJuKHRleHQpIHtcbiAgY29uc3QgdGVybXNSZSA9IG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpO1xuICByZXR1cm4gdGVybXNSZS5tYXAoKHJlKSA9PiAodG9rZW5zKSA9PiB0b2tlbnMuc29tZSgodG9rZW4pID0+IHJlLnRlc3QodG9rZW4pKSk7XG59XG5mdW5jdGlvbiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KSB7XG4gIGNvbnN0IHRlcm1zID0gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTX1dJVEhfV0lMRENBUkQpIHx8IFtdO1xuICByZXR1cm4gdGVybXMubWFwKCh0ZXJtKSA9PiBuZXcgUmVnRXhwKGBeJHt0ZXJtLnNsaWNlKDAsIE1BWF9URVJNX0xFTkdUSCkucmVwbGFjZSgvXFwqL2csIFwiLipcIil9JGAsIFwiaVwiKSk7XG59XG5hc3luYyBmdW5jdGlvbiBnYXRoZXJUZXh0KHZhbHVlLCBjYikge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNiKHZhbHVlLmRhdGEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBsZXQgc3VjY2VzcyA9IHRydWU7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYXJ0IG9mIHZhbHVlKSB7XG4gICAgICBpZiAocGFydC50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNiKHBhcnQuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IEJNMjVrID0gMS4yO1xuYXN5bmMgZnVuY3Rpb24gZXZhbHVhdGVTY29yZShub2RlLCBzY29wZSwgZXhlY3V0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIk9wQ2FsbFwiICYmIG5vZGUub3AgPT09IFwibWF0Y2hcIikge1xuICAgIHJldHVybiBldmFsdWF0ZU1hdGNoU2NvcmUobm9kZS5sZWZ0LCBub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XG4gICAgY29uc3QgaW5uZXJTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5hcmdzWzBdLCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgY29uc3QgYm9vc3QyID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAoYm9vc3QyLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5uZXJTY29yZSA+IDApIHtcbiAgICAgIHJldHVybiBpbm5lclNjb3JlICsgYm9vc3QyLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9yXCI6IHtcbiAgICAgIGNvbnN0IGxlZnRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5sZWZ0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICB9XG4gICAgY2FzZSBcIkFuZFwiOiB7XG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgY29uc3QgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgaWYgKGxlZnRTY29yZSA9PT0gMCB8fCByaWdodFNjb3JlID09PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjdXRlKG5vZGUsIHNjb3BlKTtcbiAgICAgIHJldHVybiByZXMudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgcmVzLmRhdGEgPT09IHRydWUgPyAxIDogMDtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlTWF0Y2hTY29yZShsZWZ0LCByaWdodCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdGV4dCA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICBjb25zdCBwYXR0ZXJuID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICBsZXQgdG9rZW5zID0gW107XG4gIGxldCB0ZXJtcyA9IFtdO1xuICBhd2FpdCBnYXRoZXJUZXh0KHRleHQsIChwYXJ0KSA9PiB7XG4gICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcbiAgfSk7XG4gIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHBhdHRlcm4sIChwYXJ0KSA9PiB7XG4gICAgdGVybXMgPSB0ZXJtcy5jb25jYXQobWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpO1xuICB9KTtcbiAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IHNjb3JlMiA9IDA7XG4gIGZvciAoY29uc3QgcmUgb2YgdGVybXMpIHtcbiAgICBjb25zdCBmcmVxID0gdG9rZW5zLnJlZHVjZSgoYywgdG9rZW4pID0+IGMgKyAocmUudGVzdCh0b2tlbikgPyAxIDogMCksIDApO1xuICAgIHNjb3JlMiArPSBmcmVxICogKEJNMjVrICsgMSkgLyAoZnJlcSArIEJNMjVrKTtcbiAgfVxuICByZXR1cm4gc2NvcmUyO1xufVxuYXN5bmMgZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xuICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBibG9ja1RleHQodmFsdWUuZGF0YSk7XG4gIH0gZWxzZSBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgY29uc3QgdGV4dHMgPSBhd2FpdCBhcnJheVRleHQodmFsdWUpO1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGV4dHMuam9pbihcIlxcblxcblwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBhcnJheVRleHQodmFsdWUsIHJlc3VsdCA9IFtdKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2YgdmFsdWUpIHtcbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdGV4dCA9IGJsb2NrVGV4dChibG9jay5kYXRhKTtcbiAgICAgIGlmICh0ZXh0ICE9PSBudWxsKVxuICAgICAgICByZXN1bHQucHVzaCh0ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGJsb2NrLmlzQXJyYXkoKSkge1xuICAgICAgYXdhaXQgYXJyYXlUZXh0KGJsb2NrLCByZXN1bHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmxvY2tUZXh0KG9iaikge1xuICBpZiAodHlwZW9mIG9iai5fdHlwZSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKGNoaWxkICYmIHR5cGVvZiBjaGlsZCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY2hpbGQuX3R5cGUgPT09IFwic3RyaW5nXCIgJiYgY2hpbGQuX3R5cGUgPT09IFwic3BhblwiICYmIHR5cGVvZiBjaGlsZC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQgKz0gY2hpbGQudGV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhc1JlZmVyZW5jZSh2YWx1ZSwgcGF0aFNldCkge1xuICBzd2l0Y2ggKGdldFR5cGUodmFsdWUpKSB7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAodmFsdWUuX3JlZikge1xuICAgICAgICByZXR1cm4gcGF0aFNldC5oYXModmFsdWUuX3JlZik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb3VudFVURjgoc3RyKSB7XG4gIGxldCBjb3VudDIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA+PSA1NTI5NiAmJiBjb2RlIDw9IDU2MzE5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY291bnQyKys7XG4gIH1cbiAgcmV0dXJuIGNvdW50Mjtcbn1cbmNvbnN0IGdsb2JhbCA9IHt9O1xuZ2xvYmFsLmNvYWxlc2NlID0gYXN5bmMgZnVuY3Rpb24gY29hbGVzY2UoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZ2xvYmFsLmNvdW50ID0gYXN5bmMgZnVuY3Rpb24gY291bnQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKCFpbm5lci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbnVtID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCBfIG9mIGlubmVyKSB7XG4gICAgbnVtKys7XG4gIH1cbiAgcmV0dXJuIGZyb21OdW1iZXIobnVtKTtcbn07XG5nbG9iYWwuY291bnQuYXJpdHkgPSAxO1xuZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24gZGF0ZVRpbWUoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xuZ2xvYmFsLmRlZmluZWQgPSBhc3luYyBmdW5jdGlvbiBkZWZpbmVkKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHJldHVybiBpbm5lci50eXBlID09PSBcIm51bGxcIiA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbn07XG5nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5nbG9iYWwuaWRlbnRpdHkgPSBhc3luYyBmdW5jdGlvbiBpZGVudGl0eShhcmdzLCBzY29wZSkge1xuICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LmlkZW50aXR5KTtcbn07XG5nbG9iYWwuaWRlbnRpdHkuYXJpdHkgPSAwO1xuZ2xvYmFsLmxlbmd0aCA9IGFzeW5jIGZ1bmN0aW9uIGxlbmd0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSk7XG4gIH1cbiAgaWYgKGlubmVyLmlzQXJyYXkoKSkge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgICAgbnVtKys7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZ2xvYmFsLmxlbmd0aC5hcml0eSA9IDE7XG5nbG9iYWwucGF0aCA9IGFzeW5jIGZ1bmN0aW9uIHBhdGgoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKGlubmVyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVBhdGgobmV3IFBhdGgoaW5uZXIuZGF0YSkpO1xufTtcbmdsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbmdsb2JhbC5zdHJpbmcgPSBhc3luYyBmdW5jdGlvbiBzdHJpbmcoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoYCR7dmFsdWUuZGF0YX1gKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcbmdsb2JhbC5yZWZlcmVuY2VzID0gYXN5bmMgZnVuY3Rpb24gcmVmZXJlbmNlcyhhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBwYXRoU2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgY29uc3QgcGF0aDIgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xuICAgIGlmIChwYXRoMi50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXRoU2V0LmFkZChwYXRoMi5kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHBhdGgyLmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHBhdGgyKSB7XG4gICAgICAgIGlmIChlbGVtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBwYXRoU2V0LmFkZChlbGVtLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYXRoU2V0LnNpemUgPT09IDApIHtcbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH1cbiAgY29uc3Qgc2NvcGVWYWx1ZSA9IGF3YWl0IHNjb3BlLnZhbHVlLmdldCgpO1xuICByZXR1cm4gaGFzUmVmZXJlbmNlKHNjb3BlVmFsdWUsIHBhdGhTZXQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xufTtcbmdsb2JhbC5yZWZlcmVuY2VzLmFyaXR5ID0gKGMpID0+IGMgPj0gMTtcbmdsb2JhbC5yb3VuZCA9IGFzeW5jIGZ1bmN0aW9uIHJvdW5kKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgbnVtID0gdmFsdWUuZGF0YTtcbiAgbGV0IHByZWMgPSAwO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBwcmVjVmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAocHJlY1ZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcHJlY1ZhbHVlLmRhdGEgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHByZWNWYWx1ZS5kYXRhKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHByZWMgPSBwcmVjVmFsdWUuZGF0YTtcbiAgfVxuICBpZiAocHJlYyA9PT0gMCkge1xuICAgIGlmIChudW0gPCAwKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcigtTWF0aC5yb3VuZCgtbnVtKSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKE1hdGgucm91bmQobnVtKSk7XG4gIH1cbiAgcmV0dXJuIGZyb21OdW1iZXIoTnVtYmVyKG51bS50b0ZpeGVkKHByZWMpKSk7XG59O1xuZ2xvYmFsLnJvdW5kLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDEgJiYgY291bnQyIDw9IDI7XG5nbG9iYWwubm93ID0gYXN5bmMgZnVuY3Rpb24gbm93KGFyZ3MsIHNjb3BlKSB7XG4gIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQudGltZXN0YW1wLnRvSVNPU3RyaW5nKCkpO1xufTtcbmdsb2JhbC5ub3cuYXJpdHkgPSAwO1xuZ2xvYmFsLmJvb3N0ID0gYXN5bmMgZnVuY3Rpb24gYm9vc3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgYm9vc3QgY2FsbFwiKTtcbn07XG5nbG9iYWwuYm9vc3QuYXJpdHkgPSAyO1xuY29uc3Qgc3RyaW5nMiA9IHt9O1xuc3RyaW5nMi5sb3dlciA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKTtcbn07XG5zdHJpbmcyLmxvd2VyLmFyaXR5ID0gMTtcbnN0cmluZzIudXBwZXIgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAodmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9VcHBlckNhc2UoKSk7XG59O1xuc3RyaW5nMi51cHBlci5hcml0eSA9IDE7XG5nbG9iYWwubG93ZXIgPSBzdHJpbmcyLmxvd2VyO1xuZ2xvYmFsLnVwcGVyID0gc3RyaW5nMi51cHBlcjtcbmNvbnN0IHB0ID0ge307XG5wdC50ZXh0ID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgY29uc3QgdGV4dCA9IGF3YWl0IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xuICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKHRleHQpO1xufTtcbnB0LnRleHQuYXJpdHkgPSAxO1xuY29uc3Qgc2FuaXR5ID0ge307XG5zYW5pdHkucHJvamVjdElkID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcbiAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuc2FuaXR5LmRhdGFzZXQpO1xuICB9XG4gIHJldHVybiBOVUxMX1ZBTFVFO1xufTtcbmNvbnN0IHBpcGVGdW5jdGlvbnMgPSB7fTtcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBhc3luYyBmdW5jdGlvbiBvcmRlcihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBhd2FpdCB0cnVlO1xuICBpZiAoIWJhc2UuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgbWFwcGVycyA9IFtdO1xuICBjb25zdCBkaXJlY3Rpb25zID0gW107XG4gIGxldCBuID0gMDtcbiAgZm9yIChsZXQgbWFwcGVyIG9mIGFyZ3MpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcbiAgICBpZiAobWFwcGVyLnR5cGUgPT09IFwiRGVzY1wiKSB7XG4gICAgICBkaXJlY3Rpb24gPSBcImRlc2NcIjtcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgIH0gZWxzZSBpZiAobWFwcGVyLnR5cGUgPT09IFwiQXNjXCIpIHtcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xuICAgIH1cbiAgICBtYXBwZXJzLnB1c2gobWFwcGVyKTtcbiAgICBkaXJlY3Rpb25zLnB1c2goZGlyZWN0aW9uKTtcbiAgICBuKys7XG4gIH1cbiAgY29uc3QgYXV4ID0gW107XG4gIGxldCBpZHggPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgY29uc3QgdHVwbGUgPSBbYXdhaXQgdmFsdWUuZ2V0KCksIGlkeF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGUobWFwcGVyc1tpXSwgbmV3U2NvcGUpO1xuICAgICAgdHVwbGUucHVzaChhd2FpdCByZXN1bHQuZ2V0KCkpO1xuICAgIH1cbiAgICBhdXgucHVzaCh0dXBsZSk7XG4gICAgaWR4Kys7XG4gIH1cbiAgYXV4LnNvcnQoKGFUdXBsZSwgYlR1cGxlKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGxldCBjID0gdG90YWxDb21wYXJlKGFUdXBsZVtpICsgMl0sIGJUdXBsZVtpICsgMl0pO1xuICAgICAgaWYgKGRpcmVjdGlvbnNbaV0gPT09IFwiZGVzY1wiKSB7XG4gICAgICAgIGMgPSAtYztcbiAgICAgIH1cbiAgICAgIGlmIChjICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xuICB9KTtcbiAgcmV0dXJuIGZyb21KUyhhdXgubWFwKCh2KSA9PiB2WzBdKSk7XG59O1xucGlwZUZ1bmN0aW9ucy5vcmRlci5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xucGlwZUZ1bmN0aW9ucy5zY29yZSA9IGFzeW5jIGZ1bmN0aW9uIHNjb3JlKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghYmFzZS5pc0FycmF5KCkpXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIGNvbnN0IHVua25vd24gPSBbXTtcbiAgY29uc3Qgc2NvcmVkID0gW107XG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB1bmtub3duLnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICBsZXQgdmFsdWVTY29yZSA9IHR5cGVvZiB2YWx1ZS5kYXRhLl9zY29yZSA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLmRhdGEuX3Njb3JlIDogMDtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICB2YWx1ZVNjb3JlICs9IGF3YWl0IGV2YWx1YXRlU2NvcmUoYXJnLCBuZXdTY29wZSwgZXhlY3V0ZSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlLmRhdGEsIHsgX3Njb3JlOiB2YWx1ZVNjb3JlIH0pO1xuICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XG4gIH1cbiAgc2NvcmVkLnNvcnQoKGEsIGIpID0+IGIuX3Njb3JlIC0gYS5fc2NvcmUpO1xuICByZXR1cm4gZnJvbUpTKHNjb3JlZCk7XG59O1xucGlwZUZ1bmN0aW9ucy5zY29yZS5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxO1xuY29uc3QgZGVsdGEgPSB7fTtcbmRlbHRhLm9wZXJhdGlvbiA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsO1xuICBjb25zdCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIGlmIChoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcInVwZGF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcImNyZWF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQmVmb3JlKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJkZWxldGVcIik7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG5hbWVzcGFjZXMgPSB7XG4gIGdsb2JhbCxcbiAgc3RyaW5nOiBzdHJpbmcyLFxuICBwdCxcbiAgZGVsdGEsXG4gIGRpZmYsXG4gIHNhbml0eVxufTtcbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvO1xuY29uc3QgTlVNID0gL15cXGQrLztcbmNvbnN0IElERU5UID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qLztcbmNvbnN0IFBSRUNfUEFJUiA9IDE7XG5jb25zdCBQUkVDX09SID0gMjtcbmNvbnN0IFBSRUNfQU5EID0gMztcbmNvbnN0IFBSRUNfQ09NUCA9IDQ7XG5jb25zdCBQUkVDX09SREVSID0gNDtcbmNvbnN0IFBSRUNfQUREID0gNjtcbmNvbnN0IFBSRUNfU1VCID0gNjtcbmNvbnN0IFBSRUNfTVVMID0gNztcbmNvbnN0IFBSRUNfRElWID0gNztcbmNvbnN0IFBSRUNfTU9EID0gNztcbmNvbnN0IFBSRUNfUE9XID0gODtcbmNvbnN0IFBSRUNfUE9TID0gMTA7XG5jb25zdCBQUkVDX05PVCA9IDEwO1xuY29uc3QgUFJFQ19ORUcgPSA4O1xuZnVuY3Rpb24gcGFyc2UkMShzdHIpIHtcbiAgbGV0IHBvcyA9IDA7XG4gIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICByZXR1cm4gcmVzdWx0O1xuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICBkZWxldGUgcmVzdWx0LnBvc2l0aW9uO1xuICBkZWxldGUgcmVzdWx0LmZhaWxQb3NpdGlvbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHIsIHBvcywgbGV2ZWwpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcbiAgbGV0IG1hcmtzO1xuICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgY2FzZSBcIitcIjoge1xuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCBQUkVDX1BPUyk7XG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJwb3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCItXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibmVnXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiKFwiOiB7XG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIDApO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInR1cGxlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJ0dXBsZV9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiKVwiOiB7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImdyb3VwXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCIhXCI6IHtcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19OT1QpO1xuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibm90XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiW1wiOlxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImFycmF5XCIsIHBvc2l0aW9uOiBwb3MgfV07XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X3NwbGF0XCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJlcy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlcy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmVzLnBvc2l0aW9uO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIikge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VTdHJpbmcoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiXlwiOiB7XG4gICAgICBwb3MrKztcbiAgICAgIG1hcmtzID0gW107XG4gICAgICB3aGlsZSAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCJeXCIpIHtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGJscGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICB9XG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwidGhpc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6XG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiZXZlcnl0aGluZ1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV07XG4gICAgICBwb3MrKztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIkXCI6IHtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgeyBuYW1lOiBcInBhcmFtXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgKyAxIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgIGlmIChudW1MZW4pIHtcbiAgICAgICAgcG9zICs9IG51bUxlbjtcbiAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIikge1xuICAgICAgICAgIGxldCBmcmFjTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIE5VTSk7XG4gICAgICAgICAgaWYgKGZyYWNMZW4pIHtcbiAgICAgICAgICAgIG5hbWUgPSBcImZsb2F0XCI7XG4gICAgICAgICAgICBwb3MgKz0gMSArIGZyYWNMZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJlXCIgfHwgc3RyW3Bvc10gPT09IFwiRVwiKSB7XG4gICAgICAgICAgbmFtZSA9IFwic2NpXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIitcIiB8fCBzdHJbcG9zXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZXhwTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgICBpZiAoIWV4cExlbilcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICAgICAgICAgIHBvcyArPSBleHBMZW47XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgeyBuYW1lLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICB7IG5hbWU6IG5hbWUgKyBcIl9lbmRcIiwgcG9zaXRpb246IHBvcyB9XG4gICAgICAgIF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyArPSBpZGVudExlbjtcbiAgICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xuICAgICAgICAgIGNhc2UgXCI6XCI6XG4gICAgICAgICAgY2FzZSBcIihcIjoge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbWFya3MgPSBbXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJ0aGlzX2F0dHJcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgICAgIHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIW1hcmtzKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gIH1cbiAgbGV0IGxoc0xldmVsID0gMTI7XG4gIGxldCB0cmF2O1xuICBsb29wOlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgaWYgKGlubmVyUG9zID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgIHBvcyA9IGlubmVyUG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIGlubmVyUG9zKTtcbiAgICAgIGlmICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInRyYXZlcnNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSB0cmF2LnBvc2l0aW9uO1xuICAgICAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInRyYXZlcnNhbF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgdG9rZW4yID0gc3RyW2lubmVyUG9zXTtcbiAgICAgIHN3aXRjaCAodG9rZW4yKSB7XG4gICAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgICBsZXQgbmV4dFRva2VuID0gc3RyW2lubmVyUG9zICsgMV07XG4gICAgICAgICAgc3dpdGNoIChuZXh0VG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6IHtcbiAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19QQUlSIHx8IGxoc0xldmVsIDw9IFBSRUNfUEFJUilcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QQUlSKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGFpclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BBSVI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIj1cIjoge1xuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDIgfSk7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIitcIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQUREIHx8IGxoc0xldmVsIDwgUFJFQ19BREQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFkZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIi1cIjoge1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfU1VCIHx8IGxoc0xldmVsIDwgUFJFQ19TVUIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInN1YlwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIipcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUE9XIHx8IGxoc0xldmVsIDw9IFBSRUNfUE9XKVxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJoczIgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX1BPVyk7XG4gICAgICAgICAgICBpZiAocmhzMi50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgIHJldHVybiByaHMyO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzMi5tYXJrcyk7XG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwb3dcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgcG9zID0gcmhzMi5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QT1c7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NVUwgfHwgbGhzTGV2ZWwgPCBQUkVDX01VTClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTVVMICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibXVsXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01VTDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiL1wiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19ESVYgfHwgbGhzTGV2ZWwgPCBQUkVDX0RJVilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfRElWICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiZGl2XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0RJVjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiJVwiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19NT0QgfHwgbGhzTGV2ZWwgPCBQUkVDX01PRClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTU9EICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwibW9kXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01PRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICBjYXNlIFwiPlwiOiB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IG5leHRQb3MgPSBpbm5lclBvcyArIDE7XG4gICAgICAgICAgaWYgKHN0cltuZXh0UG9zXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgIG5leHRQb3MrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICAgIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IG5leHRQb3MgfSk7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInxcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1IgfHwgbGhzTGV2ZWwgPCBQUkVDX09SKVxuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfT1IgKyAxKTtcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcIm9yXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSlcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICAgIGlmICghaWRlbnRMZW4pXG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IGlkZW50UG9zIH07XG4gICAgICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xuICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIihcIiB8fCBzdHJbcG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRnVuY0NhbGwoc3RyLCBpZGVudFBvcywgcG9zKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGlwZWNhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCImXCI6IHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gIT0gXCImXCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQU5EIHx8IGxoc0xldmVsIDwgUFJFQ19BTkQpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0FORCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImFuZFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BTkQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIiFcIjoge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8IFBSRUNfQ09NUClcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJkXCI6IHtcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDQpICE9PSBcImRlc2NcIilcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImRlc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgNDtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgMykgIT09IFwiYXNjXCIpXG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1JERVIgfHwgbGhzTGV2ZWwgPCBQUkVDX09SREVSKVxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgMztcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfT1JERVI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGxldCBpZGVudCA9IHBhcnNlUmVnZXhTdHIoc3RyLCBpbm5lclBvcywgSURFTlQpO1xuICAgICAgICAgIHN3aXRjaCAoaWRlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpblwiOiB7XG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKTtcbiAgICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGlzR3JvdXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIuXCIgJiYgc3RyW3BvcyArIDFdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiZXhjX3JhbmdlXCI7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJpbl9yYW5nZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJjb21wXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpXG4gICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibWF0Y2hcIjoge1xuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDUpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDUgfSk7XG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGxldCBmYWlsUG9zaXRpb24gPSAodHJhdiA9PSBudWxsID8gdm9pZCAwIDogdHJhdi50eXBlKSA9PT0gXCJlcnJvclwiICYmIHRyYXYucG9zaXRpb247XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcywgZmFpbFBvc2l0aW9uIH07XG59XG5mdW5jdGlvbiBwYXJzZVRyYXZlcnNhbChzdHIsIHBvcykge1xuICBsZXQgc3RhcnRQb3MgPSBwb3M7XG4gIHN3aXRjaCAoc3RyW3Bvc10pIHtcbiAgICBjYXNlIFwiLlwiOiB7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zO1xuICAgICAgbGV0IGlkZW50TGVuMiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIElERU5UKTtcbiAgICAgIGlmICghaWRlbnRMZW4yKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIHBvcyArPSBpZGVudExlbjI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFtcbiAgICAgICAgICB7IG5hbWU6IFwiYXR0cl9hY2Nlc3NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFN0YXJ0IH0sXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cbiAgICAgICAgXSxcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIi1cIjpcbiAgICAgIGlmIChzdHJbcG9zICsgMV0gIT09IFwiPlwiKVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwiZGVyZWZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xuICAgICAgcG9zICs9IDI7XG4gICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XG4gICAgICBpZiAoaWRlbnRMZW4pIHtcbiAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGVyZWZfYXR0clwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSwgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3MsXG4gICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgIH07XG4gICAgY2FzZSBcIltcIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwiYXJyYXlfcG9zdGZpeFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XG4gICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICB0eXBlID0gXCJleGNfcmFuZ2VcIjtcbiAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgICAgcmV0dXJuIHJocztcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICBtYXJrczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcInNsaWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxuICAgICAgICAgICAgeyBuYW1lOiB0eXBlLCBwb3NpdGlvbjogcmFuZ2VQb3MgfVxuICAgICAgICAgIF0uY29uY2F0KHJlc3VsdC5tYXJrcywgcmhzLm1hcmtzKSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIilcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwic3F1YXJlX2JyYWNrZXRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dLmNvbmNhdChyZXN1bHQubWFya3MpLFxuICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInxcIjoge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwie1wiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJlc3VsdC5tYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwcm9qZWN0aW9uXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwie1wiOiB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2NhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICBpZiAoc3RyW3Bvc10gPT09IFwiOlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCI6XCIpIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJuYW1lc3BhY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xuICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMik7XG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgaWYgKCFuYW1lTGVuKVxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gXCIoXCIpXG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgICBwb3MrKztcbiAgfSBlbHNlIHtcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICB9XG4gIGxldCBsYXN0UG9zID0gcG9zO1xuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgbGFzdFBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgICBicmVhaztcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdID09PSBcIilcIilcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcbiAgfVxuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJmdW5jX2FyZ3NfZW5kXCIsIHBvc2l0aW9uOiBsYXN0UG9zIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xuICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcIm9iamVjdFwiLCBwb3NpdGlvbjogcG9zIH1dO1xuICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgd2hpbGUgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIGxldCBwYWlyUG9zID0gcG9zO1xuICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChleHByLnR5cGUgPT09IFwiZXJyb3JcIilcbiAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3NwbGF0XCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9iamVjdF9zcGxhdF90aGlzXCIsIHBvc2l0aW9uOiBwYWlyUG9zIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgICAgbGV0IG5leHRQb3MgPSBza2lwV1Moc3RyLCBleHByLnBvc2l0aW9uKTtcbiAgICAgIGlmIChleHByLm1hcmtzWzBdLm5hbWUgPT09IFwic3RyXCIgJiYgc3RyW25leHRQb3NdID09PSBcIjpcIikge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zICsgMSksIDApO1xuICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib2JqZWN0X3BhaXJcIiwgcG9zaXRpb246IHBhaXJQb3MgfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKTtcbiAgICAgICAgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IFwib2JqZWN0X2V4cHJcIiwgcG9zaXRpb246IHBvcyB9LCBleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxuICAgICAgYnJlYWs7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cbiAgaWYgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xuICB9XG4gIHBvcysrO1xuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gIHJldHVybiB7IHR5cGU6IFwic3VjY2Vzc1wiLCBtYXJrcywgcG9zaXRpb246IHBvcyB9O1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIHBvcyA9IHBvcyArIDE7XG4gIGNvbnN0IG1hcmtzID0gW3sgbmFtZTogXCJzdHJcIiwgcG9zaXRpb246IHBvcyB9XTtcbiAgc3RyOlxuICAgIGZvciAoOyA7IHBvcysrKSB7XG4gICAgICBpZiAocG9zID4gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XG4gICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgIGNhc2UgdG9rZW46IHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgYnJlYWsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfcGF1c2VcIiwgcG9zaXRpb246IHBvcyB9KTtcbiAgICAgICAgICBpZiAoc3RyW3BvcyArIDFdID09PSBcInVcIikge1xuICAgICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDMgfSk7XG4gICAgICAgICAgICAgIHBvcyA9IHN0ci5pbmRleE9mKFwifVwiLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDIgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgNiB9KTtcbiAgICAgICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInNpbmdsZV9lc2NhcGVcIiwgcG9zaXRpb246IHBvcyArIDEgfSk7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic3RyX3N0YXJ0XCIsIHBvc2l0aW9uOiBwb3MgKyAxIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MgfTtcbn1cbmZ1bmN0aW9uIHNraXBXUyhzdHIsIHBvcykge1xuICByZXR1cm4gcG9zICsgcGFyc2VSZWdleChzdHIsIHBvcywgV1MpO1xufVxuZnVuY3Rpb24gcGFyc2VSZWdleChzdHIsIHBvcywgcmUpIHtcbiAgbGV0IG0gPSByZS5leGVjKHN0ci5zbGljZShwb3MpKTtcbiAgcmV0dXJuIG0gPyBtWzBdLmxlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4U3RyKHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsO1xufVxuZnVuY3Rpb24gam9pbihhLCBiKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gYihhKGJhc2UpKTtcbn1cbmZ1bmN0aW9uIG1hcChpbm5lcikge1xuICByZXR1cm4gKGJhc2UpID0+ICh7IHR5cGU6IFwiTWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJGbGF0TWFwXCIsIGJhc2UsIGV4cHI6IGlubmVyKHsgdHlwZTogXCJUaGlzXCIgfSkgfSk7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGJ1aWxkLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICBidWlsZFxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBtYXAocmlnaHQuYnVpbGQpKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgZmxhdE1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVBsYWluKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQcm9qZWN0aW9uKG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImItYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwKG1hcHBlciksIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gdHlwZTogJHtyaWdodC50eXBlfWApO1xuICB9XG59XG5jb25zdCBpc0VxdWFsID0gZXF1YWxpdHk7XG5mdW5jdGlvbiBlcXVhbGl0eShhLCBiKSB7XG4gIGlmIChhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBhLmRhdGEgPT09IGIuZGF0YTtcbiAgfVxuICBpZiAoYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICByZXR1cm4gYS5kYXRhLmVxdWFscyhiLmRhdGEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IG9wZXJhdG9ycyA9IHtcbiAgXCI9PVwiOiBmdW5jdGlvbiBlcShsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCIhPVwiOiBmdW5jdGlvbiBuZXEobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIFwiPlwiOiBmdW5jdGlvbiBndChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPiAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIj49XCI6IGZ1bmN0aW9uIGd0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIilcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPj0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgfSxcbiAgXCI8XCI6IGZ1bmN0aW9uIGx0KGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA8IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiPD1cIjogZnVuY3Rpb24gbHRlKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBpbjogYXN5bmMgZnVuY3Rpb24gaW5vcChsZWZ0LCByaWdodCkge1xuICAgIGlmIChyaWdodC50eXBlID09PSBcInBhdGhcIikge1xuICAgICAgaWYgKGxlZnQudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodC5kYXRhLm1hdGNoZXMobGVmdC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0LmlzQXJyYXkoKSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBiIG9mIHJpZ2h0KSB7XG4gICAgICAgIGlmIChpc0VxdWFsKGxlZnQsIGIpKSB7XG4gICAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIG1hdGNoOiBhc3luYyBmdW5jdGlvbiBtYXRjaChsZWZ0LCByaWdodCkge1xuICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgcGF0dGVybnMgPSBbXTtcbiAgICBhd2FpdCBnYXRoZXJUZXh0KGxlZnQsIChwYXJ0KSA9PiB7XG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHJpZ2h0LCAocGFydCkgPT4ge1xuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihwYXJ0KSk7XG4gICAgfSk7XG4gICAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZWQgPSBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucyk7XG4gICAgcmV0dXJuIG1hdGNoZWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiK1wiOiBmdW5jdGlvbiBwbHVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZChyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZyb21TdHJpbmcobGVmdC5kYXRhICsgcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGZyb21KUyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgbGVmdC5kYXRhKSwgcmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICByZXR1cm4gZnJvbUpTKGxlZnQuZGF0YS5jb25jYXQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCItXCI6IGZ1bmN0aW9uIG1pbnVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhIC0gcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICogYiksXG4gIFwiL1wiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgLyBiKSxcbiAgXCIlXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAlIGIpLFxuICBcIioqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gTWF0aC5wb3coYSwgYikpXG59O1xuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBpbXBsKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfTtcbn1cbmNsYXNzIFNjb3BlIHtcbiAgY29uc3RydWN0b3IocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcbiAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgY3JlYXRlTmVzdGVkKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzLnBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzKTtcbiAgfVxuICBjcmVhdGVIaWRkZW4odmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgcmVzdWx0LmlzSGlkZGVuID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBldmFsdWF0ZShub2RlLCBzY29wZSwgZXhlY3V0ZSA9IGV2YWx1YXRlKSB7XG4gIGNvbnN0IGZ1bmMgPSBFWEVDVVRPUlNbbm9kZS50eXBlXTtcbiAgcmV0dXJuIGZ1bmMobm9kZSwgc2NvcGUsIGV4ZWN1dGUpO1xufVxuZnVuY3Rpb24gcHJvbWlzZWxlc3NBcHBseSh2YWx1ZSwgY2IpIHtcbiAgaWYgKFwidGhlblwiIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRoZW4oY2IpO1xuICB9XG4gIHJldHVybiBjYih2YWx1ZSk7XG59XG5jb25zdCBFWEVDVVRPUlMgPSB7XG4gIFRoaXMoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUudmFsdWU7XG4gIH0sXG4gIEV2ZXJ5dGhpbmcoXywgc2NvcGUpIHtcbiAgICByZXR1cm4gc2NvcGUuc291cmNlO1xuICB9LFxuICBQYXJhbWV0ZXIoeyBuYW1lIH0sIHNjb3BlKSB7XG4gICAgcmV0dXJuIGZyb21KUyhzY29wZS5wYXJhbXNbbmFtZV0pO1xuICB9LFxuICBDb250ZXh0KHsga2V5IH0sIHNjb3BlKSB7XG4gICAgaWYgKGtleSA9PT0gXCJiZWZvcmVcIiB8fCBrZXkgPT09IFwiYWZ0ZXJcIikge1xuICAgICAgY29uc3QgdmFsdWUgPSBzY29wZS5jb250ZXh0W2tleV07XG4gICAgICByZXR1cm4gdmFsdWUgfHwgTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGNvbnRleHQga2V5OiAke2tleX1gKTtcbiAgfSxcbiAgUGFyZW50KHsgbiB9LCBzY29wZSkge1xuICAgIGxldCBjdXJyZW50ID0gc2NvcGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmICghY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICB9LFxuICBPcENhbGwoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGVyYXRvcjogJHtvcH1gKTtcbiAgICB9XG4gICAgY29uc3QgbGVmdFZhbHVlID0gZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAoXCJ0aGVuXCIgaW4gbGVmdFZhbHVlIHx8IFwidGhlblwiIGluIHJpZ2h0VmFsdWUpIHtcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4gZnVuYyhhd2FpdCBsZWZ0VmFsdWUsIGF3YWl0IHJpZ2h0VmFsdWUpKSgpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYyhsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpO1xuICB9LFxuICBhc3luYyBTZWxlY3QoeyBhbHRlcm5hdGl2ZXMsIGZhbGxiYWNrIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBhbHRDb25kID0gYXdhaXQgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgY29uc3QgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGJhc2VWYWx1ZSkge1xuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChlbGVtKTtcbiAgICAgICAgY29uc3QgZXhwclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChleHByVmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgZXhwclZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICB5aWVsZCBlbGVtO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGFzeW5jIFByb2plY3Rpb24oeyBiYXNlLCBleHByIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKGJhc2VWYWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoYmFzZVZhbHVlKTtcbiAgICByZXR1cm4gZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gIH0sXG4gIEZ1bmNDYWxsKHsgZnVuYywgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKHsgZnVuYywgYmFzZSwgYXJncyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiBmdW5jKGJhc2VWYWx1ZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xuICB9LFxuICBhc3luYyBBY2Nlc3NBdHRyaWJ1dGUoeyBiYXNlLCBuYW1lIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHZhbHVlID0gc2NvcGUudmFsdWU7XG4gICAgaWYgKGJhc2UpIHtcbiAgICAgIHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAodmFsdWUuZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gZnJvbUpTKHZhbHVlLmRhdGFbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzRWxlbWVudCh7IGJhc2UsIGluZGV4IH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKTtcbiAgICBjb25zdCBmaW5hbEluZGV4ID0gaW5kZXggPCAwID8gaW5kZXggKyBkYXRhLmxlbmd0aCA6IGluZGV4O1xuICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XG4gIH0sXG4gIGFzeW5jIFNsaWNlKHsgYmFzZSwgbGVmdCwgcmlnaHQsIGlzSW5jbHVzaXZlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXkgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgbGV0IGxlZnRJZHggPSBsZWZ0O1xuICAgIGxldCByaWdodElkeCA9IHJpZ2h0O1xuICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgbGVmdElkeCA9IGFycmF5Lmxlbmd0aCArIGxlZnRJZHg7XG4gICAgfVxuICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XG4gICAgfVxuICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgcmlnaHRJZHgrKztcbiAgICB9XG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XG4gICAgICBsZWZ0SWR4ID0gMDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgcmlnaHRJZHggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKGFycmF5LnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gIH0sXG4gIGFzeW5jIERlcmVmKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFzY29wZS5zb3VyY2UuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHZhbHVlLmRhdGEuX3JlZjtcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgaWQgPT09IGRvYy5kYXRhLl9pZCkge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgVmFsdWUoeyB2YWx1ZSB9KSB7XG4gICAgcmV0dXJuIGZyb21KUyh2YWx1ZSk7XG4gIH0sXG4gIEdyb3VwKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgfSxcbiAgYXN5bmMgT2JqZWN0KHsgYXR0cmlidXRlcyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCI6IHtcbiAgICAgICAgICBjb25zdCBjb25kID0gYXdhaXQgZXhlY3V0ZShhdHRyLmNvbmRpdGlvbiwgc2NvcGUpO1xuICAgICAgICAgIGlmIChjb25kLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IGNvbmQuZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPYmplY3RTcGxhdFwiOiB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHZhbHVlLmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7YXR0clR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tSlMocmVzdWx0KTtcbiAgfSxcbiAgQXJyYXkoeyBlbGVtZW50cyB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZWxlbWVudC52YWx1ZSwgc2NvcGUpO1xuICAgICAgICBpZiAoZWxlbWVudC5pc1NwbGF0KSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHlpZWxkIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIFR1cGxlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR1cGxlcyBjYW4gbm90IGJlIGV2YWx1YXRlZFwiKTtcbiAgfSxcbiAgYXN5bmMgT3IoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKGxlZnRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKHJpZ2h0VmFsdWUuZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBbmQoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgaWYgKGxlZnRWYWx1ZS5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBOb3QoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuZGF0YSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcbiAgfSxcbiAgTmVnKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpO1xuICAgIH0pO1xuICB9LFxuICBQb3MoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbU51bWJlcih2YWx1ZS5kYXRhKTtcbiAgICB9KTtcbiAgfSxcbiAgQXNjKCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBEZXNjKCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBhc3luYyBBcnJheUNvZXJjZSh7IGJhc2UgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyB2YWx1ZSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICB5aWVsZCBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgYXN5bmMgRmxhdE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICBjb25zdCBpbm5lclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChpbm5lclZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW5uZXIgb2YgaW5uZXJWYWx1ZSkge1xuICAgICAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIGlubmVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KTtcbiAgY29uc3QgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpO1xuICBjb25zdCBwYXJhbXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy5wYXJhbXMpO1xuICBjb25zdCBzY29wZSA9IG5ldyBTY29wZShwYXJhbXMsIGRhdGFzZXQsIHJvb3QsIHtcbiAgICB0aW1lc3RhbXA6IG9wdGlvbnMudGltZXN0YW1wIHx8IG5ldyBEYXRlKCksXG4gICAgaWRlbnRpdHk6IG9wdGlvbnMuaWRlbnRpdHkgPT09IHZvaWQgMCA/IFwibWVcIiA6IG9wdGlvbnMuaWRlbnRpdHksXG4gICAgc2FuaXR5OiBvcHRpb25zLnNhbml0eSxcbiAgICBhZnRlcjogb3B0aW9ucy5hZnRlciA/IGZyb21KUyhvcHRpb25zLmFmdGVyKSA6IG51bGwsXG4gICAgYmVmb3JlOiBvcHRpb25zLmJlZm9yZSA/IGZyb21KUyhvcHRpb25zLmJlZm9yZSkgOiBudWxsXG4gIH0sIG51bGwpO1xuICByZXR1cm4gZXZhbHVhdGUodHJlZSwgc2NvcGUpO1xufVxuZnVuY3Rpb24gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkdyb3VwXCI6XG4gICAgY2FzZSBcIlZhbHVlXCI6XG4gICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgIGNhc2UgXCJQb3NcIjpcbiAgICBjYXNlIFwiTmVnXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIFwiT3BDYWxsXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgY2FzZSBcIioqXCI6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlKHt9LCBOVUxMX1ZBTFVFLCBOVUxMX1ZBTFVFLCB7IHRpbWVzdGFtcDogbmV3IERhdGUoMCksIGlkZW50aXR5OiBcIm1lXCIsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSwgbnVsbCk7XG5jbGFzcyBDb25zdGFudEV2YWx1YXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5uYW1lID0gXCJDb25zdGFudEV2YWx1YXRlRXJyb3JcIjtcbiAgfVxufVxuZnVuY3Rpb24gdHJ5Q29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNvbnN0YW50RXZhbHVhdGUobm9kZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJDb25zdGFudEV2YWx1YXRlRXJyb3JcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufVxuZnVuY3Rpb24gY29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XG4gIGlmICghY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSkge1xuICAgIHRocm93IG5ldyBDb25zdGFudEV2YWx1YXRlRXJyb3IoXCJjYW5ub3QgY29uc3RhbnQgZXZhbHVhdGVcIik7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBldmFsdWF0ZShub2RlLCBEVU1NWV9TQ09QRSwgY29uc3RhbnRFdmFsdWF0ZSk7XG4gIGlmIChcInRoZW5cIiBpbiB2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJVRzogY29uc3RhbnQgZXZhbHVhdGUgc2hvdWxkIG5ldmVyIHJldHVybiBhIHByb21pc2VcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgRVNDQVBFX1NFUVVFTkNFID0ge1xuICBcIidcIjogXCInXCIsXG4gICdcIic6ICdcIicsXG4gIFwiXFxcXFwiOiBcIlxcXFxcIixcbiAgXCIvXCI6IFwiL1wiLFxuICBiOiBcIlxcYlwiLFxuICBmOiBcIlxcZlwiLFxuICBuOiBcIlxcblwiLFxuICByOiBcIlxcclwiLFxuICB0OiBcIlx0XCJcbn07XG5mdW5jdGlvbiBleHBhbmRIZXgoc3RyKSB7XG4gIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyLCAxNik7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbn1cbmNsYXNzIEdyb3FRdWVyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubmFtZSA9IFwiR3JvcVF1ZXJ5RXJyb3JcIjtcbiAgfVxufVxuY29uc3QgRVhQUl9CVUlMREVSID0ge1xuICBncm91cChwKSB7XG4gICAgY29uc3QgaW5uZXIgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJHcm91cFwiLFxuICAgICAgYmFzZTogaW5uZXJcbiAgICB9O1xuICB9LFxuICBldmVyeXRoaW5nKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiRXZlcnl0aGluZ1wiIH07XG4gIH0sXG4gIHRoaXMoKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJUaGlzXCIgfTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogMVxuICAgIH07XG4gIH0sXG4gIGRibHBhcmVudChwKSB7XG4gICAgY29uc3QgbmV4dCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhcmVudFwiLFxuICAgICAgbjogbmV4dC5uICsgMVxuICAgIH07XG4gIH0sXG4gIHRyYXZlcnNlKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgdHJhdmVyc2FsTGlzdCA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIikge1xuICAgICAgdHJhdmVyc2FsTGlzdC5wdXNoKHAucHJvY2VzcyhUUkFWRVJTRV9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBsZXQgdHJhdmVyc2FsID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gdHJhdmVyc2FsTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xuICAgIH1cbiAgICBpZiAoYmFzZS50eXBlID09PSBcIkV2ZXJ5dGhpbmdcIiB8fCBiYXNlLnR5cGUgPT09IFwiQXJyYXlcIiB8fCBiYXNlLnR5cGUgPT09IFwiUGlwZUZ1bmNDYWxsXCIpIHtcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNlQXJyYXkoKHZhbCkgPT4gdmFsLCB0cmF2ZXJzYWwpO1xuICAgIH1cbiAgICBpZiAodHJhdmVyc2FsID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcbiAgICByZXR1cm4gdHJhdmVyc2FsLmJ1aWxkKGJhc2UpO1xuICB9LFxuICB0aGlzX2F0dHIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBpZiAobmFtZSA9PT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiB0cnVlIH07XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IGZhbHNlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gIH0sXG4gIG5lZyhwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk5lZ1wiLFxuICAgICAgYmFzZVxuICAgIH07XG4gIH0sXG4gIHBvcyhwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvc1wiLFxuICAgICAgYmFzZVxuICAgIH07XG4gIH0sXG4gIGFkZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIrXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBzdWIocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiLVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgbXVsKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGRpdihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIvXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtb2QocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiJVwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgcG93KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIioqXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBjb21wKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3Qgb3AgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3AsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICBwLnNoaWZ0KCk7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiSW5SYW5nZVwiLFxuICAgICAgYmFzZSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGlzSW5jbHVzaXZlXG4gICAgfTtcbiAgfSxcbiAgc3RyKHApIHtcbiAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgIGxvb3A6XG4gICAgICB3aGlsZSAocC5oYXNNYXJrKCkpIHtcbiAgICAgICAgY29uc3QgbWFyayA9IHAuZ2V0TWFyaygpO1xuICAgICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHJfZW5kXCI6XG4gICAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgY2FzZSBcInN0cl9wYXVzZVwiOlxuICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyX3N0YXJ0XCI6XG4gICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2luZ2xlX2VzY2FwZVwiOiB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gcC5zbGljZSgxKTtcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IEVTQ0FQRV9TRVFVRU5DRVtjaGFyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidW5pY29kZV9oZXhcIjpcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IGV4cGFuZEhleChwLnByb2Nlc3NTdHJpbmdFbmQoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIG1hcms6ICR7bWFyay5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9O1xuICB9LFxuICBpbnRlZ2VyKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIGZsb2F0KHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgY29uc3Qgc3RyVmFsdWUgPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgdmFsdWU6IE51bWJlcihzdHJWYWx1ZSlcbiAgICB9O1xuICB9LFxuICBvYmplY3QocCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJvYmplY3RfZW5kXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMucHVzaChwLnByb2Nlc3MoT0JKRUNUX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImFycmF5X2VuZFwiKSB7XG4gICAgICBsZXQgaXNTcGxhdCA9IGZhbHNlO1xuICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiYXJyYXlfc3BsYXRcIikge1xuICAgICAgICBpc1NwbGF0ID0gdHJ1ZTtcbiAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIGVsZW1lbnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcIkFycmF5RWxlbWVudFwiLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaXNTcGxhdFxuICAgICAgfSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJBcnJheVwiLFxuICAgICAgZWxlbWVudHNcbiAgICB9O1xuICB9LFxuICB0dXBsZShwKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInR1cGxlX2VuZFwiKSB7XG4gICAgICBtZW1iZXJzLnB1c2gocC5wcm9jZXNzKEVYUFJfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVHVwbGVcIixcbiAgICAgIG1lbWJlcnNcbiAgICB9O1xuICB9LFxuICBmdW5jX2NhbGwocCkge1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgbmFtZSA9PT0gXCJzZWxlY3RcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBcIlNlbGVjdFwiLFxuICAgICAgICBhbHRlcm5hdGl2ZXM6IFtdXG4gICAgICB9O1xuICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiKSB7XG4gICAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcInBhaXJcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYHVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClgKTtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGB1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpYCk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuZmFsbGJhY2sgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcC5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSkge1xuICAgICAgaWYgKHAucGFyc2VPcHRpb25zLm1vZGUgPT09IFwiZGVsdGFcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiQ29udGV4dFwiLFxuICAgICAgICAgIGtleTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIG5hbWUgPT09IFwiYm9vc3RcIiAmJiAhcC5hbGxvd0Jvb3N0KVxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcbiAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICBpZiAoIWZ1bmNzKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWApO1xuICAgIH1cbiAgICBjb25zdCBmdW5jID0gZnVuY3NbbmFtZV07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIH1cbiAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMubW9kZSAhPT0gdm9pZCAwICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgZnVuY3Rpb246ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIikge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgbmFtZXNwYWNlOiAke25hbWVzcGFjZX1gKTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBjb25zdCBvbGRBbGxvd0Jvb3N0ID0gcC5hbGxvd0Jvb3N0O1xuICAgIGlmIChuYW1lID09PSBcInNjb3JlXCIpIHtcbiAgICAgIHAuYWxsb3dCb29zdCA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgaWYgKG1hcmtOYW1lID09PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcIm9yZGVyXCIpIHtcbiAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGFyZ3MucHVzaCh7IHR5cGU6IFwiQXNjXCIsIGJhc2U6IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1hcmtOYW1lID09PSBcImRlc2NcIikge1xuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiBcIkRlc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBwLmFsbG93Qm9vc3QgPSBvbGRBbGxvd0Jvb3N0O1xuICAgIGNvbnN0IGZ1bmMgPSBwaXBlRnVuY3Rpb25zW25hbWVdO1xuICAgIGlmICghZnVuYykge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogJHtuYW1lfWApO1xuICAgIH1cbiAgICBpZiAoZnVuYy5hcml0eSkge1xuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBpcGVGdW5jQ2FsbFwiLFxuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBhaXIocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgdW5leHBlY3RlZCA9PmApO1xuICB9LFxuICBhbmQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFuZFwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgb3IocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9yXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBub3QocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOb3RcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBhc2MocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXNjXCIpO1xuICB9LFxuICBkZXNjKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGRlc2NcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyYW1ldGVyXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IE9CSkVDVF9CVUlMREVSID0ge1xuICBvYmplY3RfZXhwcihwKSB7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIGNvbnN0IHZhbHVlMiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIsXG4gICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3BhaXIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBpZiAobmFtZS50eXBlICE9PSBcIlZhbHVlXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgc3RyaW5nXCIpO1xuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcbiAgICAgIG5hbWU6IG5hbWUudmFsdWUsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdChwKSB7XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9LFxuICBvYmplY3Rfc3BsYXRfdGhpcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RTcGxhdFwiLFxuICAgICAgdmFsdWU6IHsgdHlwZTogXCJUaGlzXCIgfVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBUUkFWRVJTRV9CVUlMREVSID0ge1xuICBzcXVhcmVfYnJhY2tldChwKSB7XG4gICAgY29uc3QgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShleHByKTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VFbGVtZW50KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0VsZW1lbnRcIiwgYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHtcbiAgICAgIHR5cGU6IFwiRmlsdGVyXCIsXG4gICAgICBiYXNlLFxuICAgICAgZXhwclxuICAgIH0pLCByaWdodCk7XG4gIH0sXG4gIHNsaWNlKHApIHtcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XG4gICAgcC5zaGlmdCgpO1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUobGVmdCk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IHRyeUNvbnN0YW50RXZhbHVhdGUocmlnaHQpO1xuICAgIGlmICghbGVmdFZhbHVlIHx8ICFyaWdodFZhbHVlIHx8IGxlZnRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwic2xpY2luZyBtdXN0IHVzZSBjb25zdGFudCBudW1iZXJzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKHJocykgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHtcbiAgICAgIHR5cGU6IFwiU2xpY2VcIixcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0OiBsZWZ0VmFsdWUuZGF0YSxcbiAgICAgIHJpZ2h0OiByaWdodFZhbHVlLmRhdGEsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0pLCByaHMpO1xuICB9LFxuICBwcm9qZWN0aW9uKHApIHtcbiAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVByb2plY3Rpb24oKGJhc2UpID0+ICh7IHR5cGU6IFwiUHJvamVjdGlvblwiLCBiYXNlLCBleHByOiBvYmogfSksIHJpZ2h0KTtcbiAgfSxcbiAgYXR0cl9hY2Nlc3MocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lIH0pLCByaWdodCk7XG4gIH0sXG4gIGRlcmVmKHApIHtcbiAgICBsZXQgYXR0ciA9IG51bGw7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXAgPSAoYmFzZSkgPT4gYXR0ciA/IHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZTogYXR0ciB9IDogYmFzZTtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZVBsYWluKChiYXNlKSA9PiB3cmFwKHtcbiAgICAgIHR5cGU6IFwiRGVyZWZcIixcbiAgICAgIGJhc2VcbiAgICB9KSwgcmlnaHQpO1xuICB9LFxuICBhcnJheV9wb3N0Zml4KHApIHtcbiAgICByZXR1cm4gKHJpZ2h0KSA9PiB0cmF2ZXJzZUFycmF5KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFycmF5Q29lcmNlXCIsIGJhc2UgfSksIHJpZ2h0KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQWNjZXNzQXR0cmlidXRlXCIgJiYgIW5vZGUuYmFzZSkge1xuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJEZXJlZlwiIHx8IG5vZGUudHlwZSA9PT0gXCJNYXBcIiB8fCBub2RlLnR5cGUgPT09IFwiUHJvamVjdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJTbGljZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJGaWx0ZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiQWNjZXNzRWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJBcnJheUNvZXJjZVwiKSB7XG4gICAgcmV0dXJuIGV4dHJhY3RQcm9wZXJ0eUtleShub2RlLmJhc2UpO1xuICB9XG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6ICR7bm9kZS50eXBlfWApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcml0eShuYW1lLCBhcml0eSwgY291bnQyKSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoY291bnQyICE9PSBhcml0eSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuIEV4cGVjdGVkICR7YXJpdHl9LCBnb3QgJHtjb3VudDJ9LmApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcml0eSkge1xuICAgIGlmICghYXJpdHkoY291bnQyKSkge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuYCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBHcm9xU3ludGF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHBvc2l0aW9uKSB7XG4gICAgc3VwZXIoYFN5bnRheCBlcnJvciBpbiBHUk9RIHF1ZXJ5IGF0IHBvc2l0aW9uICR7cG9zaXRpb259YCk7XG4gICAgdGhpcy5uYW1lID0gXCJHcm9xU3ludGF4RXJyb3JcIjtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UkMShpbnB1dCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24pO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NvciA9IG5ldyBNYXJrUHJvY2Vzc29yKGlucHV0LCByZXN1bHQubWFya3MsIG9wdGlvbnMpO1xuICByZXR1cm4gcHJvY2Vzc29yLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1cbmV4cG9ydCB7IGV2YWx1YXRlUXVlcnkgYXMgZXZhbHVhdGUsIHBhcnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm9xLWpzLmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IFBhdGNoZXIgfSBmcm9tICcuL2ludGVybmFsLXBhdGNoZXInO1xuaW1wb3J0IHsgdXRmOGNoYXJTaXplLCB1dGY4c3RyaW5nU2l6ZSwgY29tbW9uUHJlZml4LCBjb21tb25TdWZmaXggfSBmcm9tICcuL3V0ZjgnO1xudmFyIE1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1vZGVsKG1ldGEpIHtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG4gICAgTW9kZWwucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwV2l0aE1ldGEoZGF0YSwgdGhpcy5tZXRhLCB0aGlzLm1ldGEpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLndyYXBXaXRoTWV0YSA9IGZ1bmN0aW9uIChkYXRhLCBzdGFydE1ldGEsIGVuZE1ldGEpIHtcbiAgICAgICAgaWYgKGVuZE1ldGEgPT09IHZvaWQgMCkgeyBlbmRNZXRhID0gdGhpcy5tZXRhOyB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN0YXJ0TWV0YTogc3RhcnRNZXRhLCBlbmRNZXRhOiBlbmRNZXRhIH07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgZmllbGRzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModmFsdWUuZGF0YSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgZmllbGRzW2tleV0gPSB0aGlzLndyYXBXaXRoTWV0YSh2YWwsIHZhbHVlLnN0YXJ0TWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZS5jb250ZW50ID0geyB0eXBlOiAnb2JqZWN0JywgZmllbGRzOiBmaWVsZHMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5hc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdmFsdWUuZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIF90aGlzLndyYXBXaXRoTWV0YShpdGVtLCB2YWx1ZS5zdGFydE1ldGEpOyB9KTtcbiAgICAgICAgICAgIHZhciBtZXRhcyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXRhOyB9KTtcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB7IHR5cGU6ICdhcnJheScsIGVsZW1lbnRzOiBlbGVtZW50cywgbWV0YXM6IG1ldGFzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gdmFsdWUuZGF0YTtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgICAgICAgdXRmOHNpemU6IHV0ZjhzdHJpbmdTaXplKHN0ciksXG4gICAgICAgICAgICAgICAgdXNlczogW10sXG4gICAgICAgICAgICAgICAgc3RhcnRNZXRhOiB2YWx1ZS5zdGFydE1ldGEsXG4gICAgICAgICAgICAgICAgZW5kTWV0YTogdmFsdWUuZW5kTWV0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhbcGFydF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0Zyb21QYXJ0cyA9IGZ1bmN0aW9uIChwYXJ0cykge1xuICAgICAgICB2YXIgc3RyID0ge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBwYXJ0czogcGFydHNcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYXJ0c18xID0gcGFydHM7IF9pIDwgcGFydHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gcGFydHNfMVtfaV07XG4gICAgICAgICAgICBwYXJ0LnVzZXMucHVzaChzdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0R2V0S2V5cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlLmNvbnRlbnQuZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdEdldEZpZWxkID0gZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuYXNPYmplY3QodmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqLmZpZWxkc1trZXldO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5R2V0RWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLmFzQXJyYXkodmFsdWUpO1xuICAgICAgICByZXR1cm4gYXJyLmVsZW1lbnRzW2lkeF07XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEoY29udGVudCk7XG4gICAgICAgIHJldHVybiB7IGNvbnRlbnQ6IGNvbnRlbnQsIHN0YXJ0TWV0YTogdGhpcy5tZXRhLCBlbmRNZXRhOiB0aGlzLm1ldGEgfTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5tYXJrQ2hhbmdlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHVud3JhcCh2YWx1ZSkpO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnVwZGF0ZUVuZE1ldGEgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICBpZiAoY29udGVudC50eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gY29udGVudC5wYXJ0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBwYXJ0LmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IGNvbnRlbnQuZWxlbWVudHM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfY1tfYl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSBPYmplY3QudmFsdWVzKGNvbnRlbnQuZmllbGRzKTsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9lW19kXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kTWV0YSh2YWwuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nRnJvbVBhcnRzKG90aGVyLnBhcnRzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5T2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBvYmogPSB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGZpZWxkczoge31cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2JqLmZpZWxkcywgb3RoZXIuZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmNvcHlBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgYXJyID0gdmFsdWUgPyB0aGlzLmFzQXJyYXkodmFsdWUpIDogbnVsbDtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gYXJyID8gYXJyLmVsZW1lbnRzIDogW107XG4gICAgICAgIHZhciBtZXRhcyA9IGFyciA/IGFyci5tZXRhcyA6IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgICAgICAgIG1ldGFzOiBtZXRhc1xuICAgICAgICB9O1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdFNldEZpZWxkID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZmllbGRzW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3REZWxldGVGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgICBkZWxldGUgdGFyZ2V0LmZpZWxkc1trZXldO1xuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5QXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZWxlbWVudHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gICAgfTtcbiAgICBNb2RlbC5wcm90b3R5cGUuYXJyYXlBcHBlbmRTbGljZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuYXNBcnJheShzb3VyY2UpO1xuICAgICAgICB2YXIgc2FtZVBvc2l0aW9uID0gYXJyLmVsZW1lbnRzLmxlbmd0aCA9PT0gbGVmdDtcbiAgICAgICAgKF9hID0gdGFyZ2V0LmVsZW1lbnRzKS5wdXNoLmFwcGx5KF9hLCBhcnIuZWxlbWVudHMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgaWYgKHNhbWVQb3NpdGlvbikge1xuICAgICAgICAgICAgKF9iID0gdGFyZ2V0Lm1ldGFzKS5wdXNoLmFwcGx5KF9iLCBhcnIubWV0YXMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBsZWZ0OyBpIDwgcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHN0ci5wYXJ0czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRQYXJ0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFydCkge1xuICAgICAgICB0YXJnZXQucGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgcGFydC51c2VzLnB1c2godGFyZ2V0KTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5yZXNvbHZlU3RyaW5nUGFydCA9IGZ1bmN0aW9uIChzdHIsIGZyb20sIGxlbikge1xuICAgICAgICBpZiAobGVuID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgc3RyLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IHN0ci5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChsZW4gPT09IHBhcnQudXRmOHNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIHBlcmZlY3QhXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbiA8IHBhcnQudXRmOHNpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgcGFydCBvZiB0aGlzIGNodW5rLiBXZSBub3cgbmVlZCB0byBzcGxpdCBpdCB1cC5cbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0U3RyaW5nKHBhcnQsIGxlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuIC09IHBhcnQudXRmOHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdHRpbmcgc3RyaW5nIG91dCBvZiBib3VuZHMnKTtcbiAgICB9O1xuICAgIE1vZGVsLnByb3RvdHlwZS5zcGxpdFN0cmluZyA9IGZ1bmN0aW9uIChwYXJ0LCBpZHgpIHtcbiAgICAgICAgdmFyIGxlZnRWYWx1ZTtcbiAgICAgICAgdmFyIHJpZ2h0VmFsdWU7XG4gICAgICAgIHZhciBsZWZ0U2l6ZSA9IGlkeDtcbiAgICAgICAgdmFyIHJpZ2h0U2l6ZSA9IHBhcnQudXRmOHNpemUgLSBsZWZ0U2l6ZTtcbiAgICAgICAgLy8gaWR4IGlzIGhlcmUgaW4gVVRGLTggaW5kZXgsIG5vdCBjb2RlcG9pbnQgaW5kZXguXG4gICAgICAgIC8vIFRoaXMgbWVhbnMgd2UgbWlnaHQgdG8gYWRqdXN0IGZvciBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChwYXJ0LnV0ZjhzaXplICE9PSBwYXJ0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGJ5dGVDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGJ5dGVDb3VudCA8IGxlZnRTaXplOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcGFydC52YWx1ZS5jb2RlUG9pbnRBdChpZHgpO1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplID09PSA0KVxuICAgICAgICAgICAgICAgICAgICBpZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGVmdFZhbHVlID0gcGFydC52YWx1ZS5zbGljZSgwLCBpZHgpO1xuICAgICAgICByaWdodFZhbHVlID0gcGFydC52YWx1ZS5zbGljZShpZHgpO1xuICAgICAgICB2YXIgbmV3UGFydCA9IHtcbiAgICAgICAgICAgIHZhbHVlOiByaWdodFZhbHVlLFxuICAgICAgICAgICAgdXRmOHNpemU6IHJpZ2h0U2l6ZSxcbiAgICAgICAgICAgIHVzZXM6IHBhcnQudXNlcy5zbGljZSgpLFxuICAgICAgICAgICAgc3RhcnRNZXRhOiBwYXJ0LnN0YXJ0TWV0YSxcbiAgICAgICAgICAgIGVuZE1ldGE6IHBhcnQuZW5kTWV0YVxuICAgICAgICB9O1xuICAgICAgICBwYXJ0LnZhbHVlID0gbGVmdFZhbHVlO1xuICAgICAgICBwYXJ0LnV0ZjhzaXplID0gbGVmdFNpemU7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBwYXJ0LnVzZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdXNlID0gX2FbX2ldO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgcGFydC5cbiAgICAgICAgICAgIHZhciBpZHhfMSA9IHVzZS5wYXJ0cy5pbmRleE9mKHBhcnQpO1xuICAgICAgICAgICAgaWYgKGlkeF8xID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2J1ZzogbWlzbWF0Y2ggYmV0d2VlbiBzdHJpbmcgcGFydHMgYW5kIHVzZS4nKTtcbiAgICAgICAgICAgIHVzZS5wYXJ0cy5zcGxpY2UoaWR4XzEgKyAxLCAwLCBuZXdQYXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0FwcGVuZFNsaWNlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5hc1N0cmluZyhzb3VyY2UpO1xuICAgICAgICB2YXIgZmlyc3RQYXJ0ID0gdGhpcy5yZXNvbHZlU3RyaW5nUGFydChzdHIsIDAsIGxlZnQpO1xuICAgICAgICB2YXIgbGFzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgZmlyc3RQYXJ0LCByaWdodCAtIGxlZnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RQYXJ0OyBpIDwgbGFzdFBhcnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICAgICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1vZGVsO1xufSgpKTtcbi8vIFR1cm5zIGEgbmF0aXZlIEphdmFTY3JpcHQgb2JqZWN0IGludG8gYSBWYWx1ZSB3aXRoIGEgZ2l2ZW4gb3JpZ2luLlxuZXhwb3J0IGZ1bmN0aW9uIHdyYXAoZGF0YSwgbWV0YSkge1xuICAgIHJldHVybiB7IGRhdGE6IGRhdGEsIHN0YXJ0TWV0YTogbWV0YSwgZW5kTWV0YTogbWV0YSB9O1xufVxuLy8gQ29udmVydHMgYSBWYWx1ZSBpbnRvIGEgbmF0aXZlIEphdmFTY3JpcHQgdHlwZS5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlLmRhdGEgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdmFsdWUuZGF0YTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBjb250ZW50ID0gdmFsdWUuY29udGVudDtcbiAgICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmVzdWx0ID0gY29udGVudC5wYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHsgcmV0dXJuIHBhcnQudmFsdWU7IH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRlbnQuZWxlbWVudHMubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHVud3JhcCh2YWwpOyB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhjb250ZW50LmZpZWxkcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB1bndyYXAodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZS5kYXRhID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgVmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb250ZW50KVxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudC50eXBlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKVxuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICBpZiAodmFsdWUuZGF0YSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlLmRhdGE7XG59XG4vLyBVcGRhdGVzIHRoZSBgcmlnaHRgIHZhbHVlIHN1Y2ggdGhhdCBpdCByZXVzZXMgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBgbGVmdGAgdmFsdWUuXG5leHBvcnQgZnVuY3Rpb24gcmViYXNlVmFsdWUobGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgbGVmdFR5cGUgPSBnZXRUeXBlKGxlZnQpO1xuICAgIHZhciByaWdodFR5cGUgPSBnZXRUeXBlKHJpZ2h0KTtcbiAgICBpZiAobGVmdFR5cGUgIT09IHJpZ2h0VHlwZSlcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIHZhciBsZWZ0TW9kZWwgPSBuZXcgTW9kZWwobGVmdC5lbmRNZXRhKTtcbiAgICB2YXIgcmlnaHRNb2RlbCA9IG5ldyBNb2RlbChyaWdodC5lbmRNZXRhKTtcbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0T2JqID0gbGVmdE1vZGVsLmFzT2JqZWN0KGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0T2JqID0gcmlnaHRNb2RlbC5hc09iamVjdChyaWdodCk7XG4gICAgICAgICAgICAvLyBOdW1iZXIgb2YgZmllbGRzIHdoaWNoIGFyZSBpZGVudGljYWwgaW4gbGVmdCBhbmQgcmlnaHQuXG4gICAgICAgICAgICB2YXIgaWRlbnRpY2FsRmllbGRDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgbGVmdEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhsZWZ0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJpZ2h0RmllbGRDb3VudCA9IE9iamVjdC5rZXlzKHJpZ2h0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5lbnRyaWVzKHJpZ2h0T2JqLmZpZWxkcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgcmlnaHRWYWwgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFZhbCA9IGxlZnRPYmouZmllbGRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRPYmouZmllbGRzW2tleV0gPSByZWJhc2VWYWx1ZShsZWZ0VmFsLCByaWdodFZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyaWdodE9iai5maWVsZHNba2V5XSA9PT0gbGVmdFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpY2FsRmllbGRDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzSWRlbnRpY2FsID0gbGVmdEZpZWxkQ291bnQgPT09IHJpZ2h0RmllbGRDb3VudCAmJiBsZWZ0RmllbGRDb3VudCA9PT0gaWRlbnRpY2FsRmllbGRDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBpc0lkZW50aWNhbCA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0QXJyID0gbGVmdE1vZGVsLmFzQXJyYXkobGVmdCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRBcnIgPSByaWdodE1vZGVsLmFzQXJyYXkocmlnaHQpO1xuICAgICAgICAgICAgaWYgKGxlZnRBcnIuZWxlbWVudHMubGVuZ3RoICE9PSByaWdodEFyci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBudW1SZWJhc2VkID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByaWdodEFyci5lbGVtZW50c1tpXSA9IHJlYmFzZVZhbHVlKGxlZnRBcnIuZWxlbWVudHNbaV0sIHJpZ2h0QXJyLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRBcnIuZWxlbWVudHNbaV0gIT09IGxlZnRBcnIuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtUmViYXNlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudW1SZWJhc2VkID09PSAwID8gbGVmdCA6IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgaWYgKHVud3JhcChsZWZ0KSA9PT0gdW53cmFwKHJpZ2h0KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgIHZhciBsZWZ0UmF3ID0gdW53cmFwKGxlZnQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0UmF3ID0gdW53cmFwKHJpZ2h0KTtcbiAgICAgICAgICAgIGlmIChsZWZ0UmF3ID09PSByaWdodFJhdylcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByaWdodE1vZGVsLmNvcHlTdHJpbmcobnVsbCk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29tbW9uUHJlZml4KGxlZnRSYXcsIHJpZ2h0UmF3KTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBjb21tb25TdWZmaXgobGVmdFJhdywgcmlnaHRSYXcsIHByZWZpeCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRMZW4gPSB1dGY4c3RyaW5nU2l6ZShyaWdodFJhdyk7XG4gICAgICAgICAgICB2YXIgbGVmdExlbiA9IHV0ZjhzdHJpbmdTaXplKGxlZnRSYXcpO1xuICAgICAgICAgICAgaWYgKDAgPCBwcmVmaXgpIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgMCwgcHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmVmaXggPCByaWdodExlbiAtIHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCByaWdodCwgcHJlZml4LCByaWdodExlbiAtIHN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdExlbiAtIHN1ZmZpeCA8IGxlZnRMZW4pIHtcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgbGVmdExlbiAtIHN1ZmZpeCwgbGVmdExlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByaWdodE1vZGVsLmZpbmFsaXplKHJlc3VsdCk7XG4gICAgICAgICAgICBpZiAodW53cmFwKHZhbHVlKSAhPT0gcmlnaHRSYXcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3Qgc3RyaW5nIHJlYmFzZScpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByaWdodDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoLCBzdGFydE1ldGEpIHtcbiAgICB2YXIgbW9kZWwgPSBuZXcgTW9kZWwoc3RhcnRNZXRhKTtcbiAgICB2YXIgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKG1vZGVsLCBsZWZ0LCBwYXRjaCk7XG4gICAgcmV0dXJuIHBhdGNoZXIucHJvY2VzcygpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5jcmVtZW50YWwtcGF0Y2hlci5qcy5tYXAiLCJpbXBvcnQgKiBhcyBpbmNyZW1lbnRhbF8xIGZyb20gJy4vaW5jcmVtZW50YWwtcGF0Y2hlcic7XG5leHBvcnQgeyBpbmNyZW1lbnRhbF8xIGFzIGluY3JlbWVudGFsIH07XG5leHBvcnQgeyBhcHBseVBhdGNoIH0gZnJvbSAnLi9zaW1wbGUtcGF0Y2hlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgT1BTID0gW1xuICAgICdWYWx1ZScsXG4gICAgJ0NvcHknLFxuICAgICdCbGFuaycsXG4gICAgJ1JldHVybkludG9BcnJheScsXG4gICAgJ1JldHVybkludG9PYmplY3QnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleScsXG4gICAgJ1B1c2hGaWVsZCcsXG4gICAgJ1B1c2hFbGVtZW50JyxcbiAgICAnUHVzaFBhcmVudCcsXG4gICAgJ1BvcCcsXG4gICAgJ1B1c2hGaWVsZENvcHknLFxuICAgICdQdXNoRmllbGRCbGFuaycsXG4gICAgJ1B1c2hFbGVtZW50Q29weScsXG4gICAgJ1B1c2hFbGVtZW50QmxhbmsnLFxuICAgICdSZXR1cm5JbnRvT2JqZWN0UG9wJyxcbiAgICAnUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AnLFxuICAgICdSZXR1cm5JbnRvQXJyYXlQb3AnLFxuICAgICdPYmplY3RTZXRGaWVsZFZhbHVlJyxcbiAgICAnT2JqZWN0Q29weUZpZWxkJyxcbiAgICAnT2JqZWN0RGVsZXRlRmllbGQnLFxuICAgICdBcnJheUFwcGVuZFZhbHVlJyxcbiAgICAnQXJyYXlBcHBlbmRTbGljZScsXG4gICAgJ1N0cmluZ0FwcGVuZFN0cmluZycsXG4gICAgJ1N0cmluZ0FwcGVuZFNsaWNlJ1xuXTtcbnZhciBQYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGNoZXIobW9kZWwsIHJvb3QsIHBhdGNoKSB7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xuICAgIH1cbiAgICBQYXRjaGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRjaFt0aGlzLmkrK107XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XG4gICAgICAgIGZvciAoOyB0aGlzLmkgPCB0aGlzLnBhdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHZhciBvcGNvZGUgPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgICAgIHZhciBvcCA9IE9QU1tvcGNvZGVdO1xuICAgICAgICAgICAgaWYgKCFvcClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wY29kZTogXCIgKyBvcGNvZGUpO1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NvciA9IFwicHJvY2Vzc1wiICsgb3A7XG4gICAgICAgICAgICB0aGlzW3Byb2Nlc3Nvcl0uYXBwbHkodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUuaW5wdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRTdGFja1t0aGlzLmlucHV0U3RhY2subGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEtleSA9IGZ1bmN0aW9uIChlbnRyeSwgaWR4KSB7XG4gICAgICAgIGlmICghZW50cnkua2V5cykge1xuICAgICAgICAgICAgZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5rZXlzW2lkeF07XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0U3RhY2tbdGhpcy5vdXRwdXRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weUFycmF5KGVudHJ5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dE9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgICAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgICAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlPYmplY3QoZW50cnkudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dEVudHJ5KCk7XG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5maW5hbGl6ZU91dHB1dCA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZmluYWxpemUoZW50cnkud3JpdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFByb2Nlc3NvcnM6XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7IHZhbHVlOiBpbnB1dC52YWx1ZSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NCbGFuayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IG51bGwgfSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHZhciBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRWYWx1ZShhcnIsIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwubWFya0NoYW5nZWQocmVzdWx0KTtcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMub3V0cHV0T2JqZWN0KCk7XG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBrZXksIHJlc3VsdCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xuICAgICAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwgaW5wdXQua2V5LCByZXN1bHQpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwub2JqZWN0R2V0RmllbGQoZW50cnkudmFsdWUsIGtleSk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBrZXk6IGtleSB9KTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NQdXNoRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5hcnJheUdldEVsZW1lbnQoZW50cnkudmFsdWUsIGlkeCk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1BvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnB1dFN0YWNrLnBvcCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkQmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hFbGVtZW50KCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdFBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgICB9O1xuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0U2V0RmllbGRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzVmFsdWUoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdENvcHlGaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlYWQoKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5vYmplY3REZWxldGVGaWVsZChvYmosIGtleSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICAgICAgdmFyIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgdmFsdWUpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xuICAgIH07XG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XG4gICAgICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kVmFsdWUoc3RyLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmVhZCgpO1xuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xuICAgICAgICB0aGlzLm1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGF0Y2hlcjtcbn0oKSk7XG5leHBvcnQgeyBQYXRjaGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC1wYXRjaGVyLmpzLm1hcCIsImltcG9ydCB7IFBhdGNoZXIgfSBmcm9tICcuL2ludGVybmFsLXBhdGNoZXInO1xuaW1wb3J0IHsgdXRmOHJlc29sdmVJbmRleCB9IGZyb20gJy4vdXRmOCc7XG52YXIgTW9kZWwgPSB7XG4gICAgd3JhcDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGIuZGF0YTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWFya0NoYW5nZWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBvYmplY3RHZXRLZXlzOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICB9LFxuICAgIG9iamVjdEdldEZpZWxkOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgICB9LFxuICAgIGFycmF5R2V0RWxlbWVudDogZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2lkeF07XG4gICAgfSxcbiAgICBjb3B5T2JqZWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgZGF0YToge31cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModmFsdWUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbCA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHJlcy5kYXRhW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGNvcHlBcnJheTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gICAgfSxcbiAgICBjb3B5U3RyaW5nOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGF0YTogdmFsdWUgPT09IG51bGwgPyAnJyA6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvYmplY3RTZXRGaWVsZDogZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXQuZGF0YVtrZXldID0gdmFsdWU7XG4gICAgfSxcbiAgICBvYmplY3REZWxldGVGaWVsZDogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0YXJnZXQuZGF0YVtrZXldO1xuICAgIH0sXG4gICAgYXJyYXlBcHBlbmRWYWx1ZTogZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LnB1c2godmFsdWUpO1xuICAgIH0sXG4gICAgYXJyYXlBcHBlbmRTbGljZTogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgICAgICB0YXJnZXQucHVzaC5hcHBseSh0YXJnZXQsIHNvdXJjZS5zbGljZShsZWZ0LCByaWdodCkpO1xuICAgIH0sXG4gICAgc3RyaW5nQXBwZW5kU2xpY2U6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIHNvdXJjZVN0cmluZyA9IHNvdXJjZTtcbiAgICAgICAgdmFyIGxlZnRQb3MgPSB1dGY4cmVzb2x2ZUluZGV4KHNvdXJjZVN0cmluZywgbGVmdCk7XG4gICAgICAgIHZhciByaWdodFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCByaWdodCwgbGVmdFBvcyk7XG4gICAgICAgIHRhcmdldC5kYXRhICs9IHNvdXJjZVN0cmluZy5zbGljZShsZWZ0UG9zLCByaWdodFBvcyk7XG4gICAgfSxcbiAgICBzdHJpbmdBcHBlbmRWYWx1ZTogZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgdGFyZ2V0LmRhdGEgKz0gdmFsdWU7XG4gICAgfVxufTtcbi8vIEFwcGxpZXMgYSBwYXRjaCBvbiBhIEphdmFTY3JpcHQgb2JqZWN0LlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2gobGVmdCwgcGF0Y2gpIHtcbiAgICB2YXIgcm9vdCA9IGxlZnQ7IC8vIE5vIG5lZWQgdG8gd3JhcCBiZWNhdXNlIHRoZSByZXByZXNlbnRhdGlvbiBpcyB0aGUgc2FtZS5cbiAgICB2YXIgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKE1vZGVsLCByb290LCBwYXRjaCk7XG4gICAgcmV0dXJuIHBhdGNoZXIucHJvY2VzcygpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxlLXBhdGNoZXIuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIHV0ZjhjaGFyU2l6ZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj4gMTYpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPj4gMTEpIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPj4gNykge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB1dGY4c3RyaW5nU2l6ZShzdHIpIHtcbiAgICB2YXIgYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGNvZGUpO1xuICAgICAgICBpZiAoc2l6ZSA9PSA0KVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICBiICs9IHNpemU7XG4gICAgfVxuICAgIHJldHVybiBiO1xufVxuLyoqIENvbnZlcnRzIGFuIFVURi04IGJ5dGUgaW5kZXggaW50byBhIFVDUy0yIGluZGV4LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhyZXNvbHZlSW5kZXgoc3RyLCBpZHgsIHN0YXJ0KSB7XG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XG4gICAgdmFyIGJ5dGVDb3VudCA9IHN0YXJ0O1xuICAgIHZhciB1Y3NJZHggPSAwO1xuICAgIGZvciAodWNzSWR4ID0gc3RhcnQ7IGJ5dGVDb3VudCA8IGlkeDsgdWNzSWR4KyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY29kZVBvaW50QXQodWNzSWR4KTtcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgICAgIGlmIChzaXplID09PSA0KVxuICAgICAgICAgICAgdWNzSWR4Kys7IC8vIFN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICBieXRlQ291bnQgKz0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVjc0lkeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21tb25QcmVmaXgoc3RyLCBzdHIyKSB7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKTtcbiAgICB2YXIgYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIHZhciBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICAgIHZhciBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KGkpO1xuICAgICAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICAgICAgYiArPSBzaXplO1xuICAgICAgICBpICs9IHNpemUgPT09IDQgPyAyIDogMTtcbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3VmZml4KHN0ciwgc3RyMiwgcHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PT0gdm9pZCAwKSB7IHByZWZpeCA9IDA7IH1cbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgc3RyMi5sZW5ndGgpIC0gcHJlZml4O1xuICAgIHZhciBiID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgdmFyIGFQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChzdHIubGVuZ3RoIC0gMSAtIGkpO1xuICAgICAgICB2YXIgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChzdHIyLmxlbmd0aCAtIDEgLSBpKTtcbiAgICAgICAgaWYgKGFQb2ludCAhPT0gYlBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XG4gICAgICAgIGIgKz0gc2l6ZTtcbiAgICAgICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XG4gICAgfVxuICAgIHJldHVybiBiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCxuby1wYXJhbS1yZWFzc2lnbixuby1zaGFkb3cgKi9cblxuLyoqXG4gKiBUaHJvdHRsZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi4gRXNwZWNpYWxseSB1c2VmdWwgZm9yIHJhdGUgbGltaXRpbmdcbiAqIGV4ZWN1dGlvbiBvZiBoYW5kbGVycyBvbiBldmVudHMgbGlrZSByZXNpemUgYW5kIHNjcm9sbC5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgIGRlbGF5IC0gICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXG4gKiBAcGFyYW0gIHtib29sZWFufSAgIFtub1RyYWlsaW5nXSAtICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub1RyYWlsaW5nIGlzIHRydWUsIGNhbGxiYWNrIHdpbGwgb25seSBleGVjdXRlIGV2ZXJ5IGBkZWxheWAgbWlsbGlzZWNvbmRzIHdoaWxlIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9uZSBmaW5hbCB0aW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIHRoZSBsYXN0IHRocm90dGxlZC1mdW5jdGlvbiBjYWxsLiAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBgZGVsYXlgIG1pbGxpc2Vjb25kcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGludGVybmFsIGNvdW50ZXIgaXMgcmVzZXQpLlxuICogQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAtICAgICAgIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLiBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4gKiBAcGFyYW0gIHtib29sZWFufSAgIFtkZWJvdW5jZU1vZGVdIC0gSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy4gSWYgYGRlYm91bmNlTW9kZWAgaXMgZmFsc2UgKGF0IGVuZCksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gIEEgbmV3LCB0aHJvdHRsZWQsIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0aHJvdHRsZSAoZGVsYXksIG5vVHJhaWxpbmcsIGNhbGxiYWNrLCBkZWJvdW5jZU1vZGUpIHtcbiAgLypcbiAgICogQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcbiAgICogYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXG4gICAqIGRlYm91bmNlIG1vZGVzLlxuICAgKi9cbiAgdmFyIHRpbWVvdXRJRDtcbiAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHRpbWUgYGNhbGxiYWNrYCB3YXMgZXhlY3V0ZWQuXG5cbiAgdmFyIGxhc3RFeGVjID0gMDsgLy8gRnVuY3Rpb24gdG8gY2xlYXIgZXhpc3RpbmcgdGltZW91dFxuXG4gIGZ1bmN0aW9uIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCkge1xuICAgIGlmICh0aW1lb3V0SUQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICAgIH1cbiAgfSAvLyBGdW5jdGlvbiB0byBjYW5jZWwgbmV4dCBleGVjXG5cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgY2xlYXJFeGlzdGluZ1RpbWVvdXQoKTtcbiAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICB9IC8vIGBub1RyYWlsaW5nYCBkZWZhdWx0cyB0byBmYWxzeS5cblxuXG4gIGlmICh0eXBlb2Ygbm9UcmFpbGluZyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZGVib3VuY2VNb2RlID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBub1RyYWlsaW5nO1xuICAgIG5vVHJhaWxpbmcgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLypcbiAgICogVGhlIGB3cmFwcGVyYCBmdW5jdGlvbiBlbmNhcHN1bGF0ZXMgYWxsIG9mIHRoZSB0aHJvdHRsaW5nIC8gZGVib3VuY2luZ1xuICAgKiBmdW5jdGlvbmFsaXR5IGFuZCB3aGVuIGV4ZWN1dGVkIHdpbGwgbGltaXQgdGhlIHJhdGUgYXQgd2hpY2ggYGNhbGxiYWNrYFxuICAgKiBpcyBleGVjdXRlZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNfID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJndW1lbnRzX1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gbGFzdEV4ZWM7XG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBFeGVjdXRlIGBjYWxsYmFja2AgYW5kIHVwZGF0ZSB0aGUgYGxhc3RFeGVjYCB0aW1lc3RhbXAuXG5cblxuICAgIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICBsYXN0RXhlYyA9IERhdGUubm93KCk7XG4gICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHNfKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBJZiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbikgdGhpcyBpcyB1c2VkIHRvIGNsZWFyIHRoZSBmbGFnXG4gICAgICogdG8gYWxsb3cgZnV0dXJlIGBjYWxsYmFja2AgZXhlY3V0aW9ucy5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aW1lb3V0SUQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlYm91bmNlTW9kZSAmJiAhdGltZW91dElEKSB7XG4gICAgICAvKlxuICAgICAgICogU2luY2UgYHdyYXBwZXJgIGlzIGJlaW5nIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXG4gICAgICAgKiBgZGVib3VuY2VNb2RlYCBpcyB0cnVlIChhdCBiZWdpbiksIGV4ZWN1dGUgYGNhbGxiYWNrYC5cbiAgICAgICAqL1xuICAgICAgZXhlYygpO1xuICAgIH1cblxuICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XG5cbiAgICBpZiAoZGVib3VuY2VNb2RlID09PSB1bmRlZmluZWQgJiYgZWxhcHNlZCA+IGRlbGF5KSB7XG4gICAgICAvKlxuICAgICAgICogSW4gdGhyb3R0bGUgbW9kZSwgaWYgYGRlbGF5YCB0aW1lIGhhcyBiZWVuIGV4Y2VlZGVkLCBleGVjdXRlXG4gICAgICAgKiBgY2FsbGJhY2tgLlxuICAgICAgICovXG4gICAgICBleGVjKCk7XG4gICAgfSBlbHNlIGlmIChub1RyYWlsaW5nICE9PSB0cnVlKSB7XG4gICAgICAvKlxuICAgICAgICogSW4gdHJhaWxpbmcgdGhyb3R0bGUgbW9kZSwgc2luY2UgYGRlbGF5YCB0aW1lIGhhcyBub3QgYmVlblxuICAgICAgICogZXhjZWVkZWQsIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBgZGVsYXlgIG1zIGFmdGVyIG1vc3RcbiAgICAgICAqIHJlY2VudCBleGVjdXRpb24uXG4gICAgICAgKlxuICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgdHJ1ZSAoYXQgYmVnaW4pLCBzY2hlZHVsZSBgY2xlYXJgIHRvIGV4ZWN1dGVcbiAgICAgICAqIGFmdGVyIGBkZWxheWAgbXMuXG4gICAgICAgKlxuICAgICAgICogSWYgYGRlYm91bmNlTW9kZWAgaXMgZmFsc2UgKGF0IGVuZCksIHNjaGVkdWxlIGBjYWxsYmFja2AgdG9cbiAgICAgICAqIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cbiAgICAgICAqL1xuICAgICAgdGltZW91dElEID0gc2V0VGltZW91dChkZWJvdW5jZU1vZGUgPyBjbGVhciA6IGV4ZWMsIGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkID8gZGVsYXkgLSBlbGFwc2VkIDogZGVsYXkpO1xuICAgIH1cbiAgfVxuXG4gIHdyYXBwZXIuY2FuY2VsID0gY2FuY2VsOyAvLyBSZXR1cm4gdGhlIHdyYXBwZXIgZnVuY3Rpb24uXG5cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCAqL1xuLyoqXG4gKiBEZWJvdW5jZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi4gRGVib3VuY2luZywgdW5saWtlIHRocm90dGxpbmcsXG4gKiBndWFyYW50ZWVzIHRoYXQgYSBmdW5jdGlvbiBpcyBvbmx5IGV4ZWN1dGVkIGEgc2luZ2xlIHRpbWUsIGVpdGhlciBhdCB0aGVcbiAqIHZlcnkgYmVnaW5uaW5nIG9mIGEgc2VyaWVzIG9mIGNhbGxzLCBvciBhdCB0aGUgdmVyeSBlbmQuXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSAgIGRlbGF5IC0gICAgICAgICBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudCBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cbiAqIEBwYXJhbSAge2Jvb2xlYW59ICBbYXRCZWdpbl0gLSAgICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBhdEJlZ2luIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYGRlbGF5YCBtaWxsaXNlY29uZHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyIHRoZSBsYXN0IGRlYm91bmNlZC1mdW5jdGlvbiBjYWxsLiBJZiBhdEJlZ2luIGlzIHRydWUsIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb25seSBhdCB0aGUgZmlyc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBgZGVsYXlgIG1pbGxpc2Vjb25kcywgdGhlIGludGVybmFsIGNvdW50ZXIgaXMgcmVzZXQpLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIC0gICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIGRlYm91bmNlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3LCBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gZGVib3VuY2UgKGRlbGF5LCBhdEJlZ2luLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IHRocm90dGxlKGRlbGF5LCBhdEJlZ2luLCBmYWxzZSkgOiB0aHJvdHRsZShkZWxheSwgY2FsbGJhY2ssIGF0QmVnaW4gIT09IGZhbHNlKTtcbn1cblxuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlO1xuZXhwb3J0cy50aHJvdHRsZSA9IHRocm90dGxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9